[{"author":"xiaoyu","categories":null,"content":" Dromara 源码阅读（Soul 2021 首次活动）  日期：2021年1月24日，星期日 时间：15:00 – 17:00 地点：线上腾讯会议室  活动详情 15:00 - 15:10 开场介绍梦码分享流程 by kimming \u0026amp;amp; 崔\n15:10 - 15:25 Soul 数据同步之websocket by 婷\n15:25 - 15:50 Http 探活分享 by 朱明\n15:50 - 16:10 基于Sofa-Rpc协议的分析 by 东东\n16:10 - 16:25 Metrics 监控 by 葛天野\n16:25 - 16:40 Http 长轮询分享 by 杜宇航\n16:40 - 16:55 数据同步整体架构分享与介绍 by 夏文涛\n16:55 - 17:05 微内核架构分享 by 沈祥俊\n17:05 - 17:20 分享读源码的心得与感悟 by 金泽\n17:20 - 17:30 Soul 作者 猫大人 总结与 社区发展 展望 by 猫大人\n","date":1611241200,"description":"","dir":"activities/dromara-cloud-native-meet/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"3f682cfa859cefa1b40f4c24b06f09b9","permalink":"/activities/dromara-cloud-native-meet/","publishdate":"2021-01-21T15:00:00Z","readingtime":1,"relpermalink":"/activities/dromara-cloud-native-meet/","summary":"Dromara 源码阅读（Soul 2021 首次活动） 日期：2021年1月24日，星期日 时间：15:00 – 17:00 地点：线上腾讯会议室 活动详情 15:00 - 15:10 开场介绍梦码分享流程","tags":["Soul","Dromara","Reactor"],"title":"Dromara Soul 源码阅读分享会","type":"activities","url":"/activities/dromara-cloud-native-meet/","wordcount":222},{"author":"fanjinpeng","categories":"Soul","content":" HTTP 用户接入 Soul 网关注册逻辑分析 1. 注册入口 HTTP 用户接入 Soul 网关时，会调用 soul-admin 一个接口，把需要 Soul 网关管理的接口注册，今天就具体看看到底干了点儿啥。\n先看下调用的接口信息如下：\n// SpringMvcClientBeanPostProcessor.java /** * Instantiates a new Soul client bean post processor. * * @param soulSpringMvcConfig the soul spring mvc config */ public SpringMvcClientBeanPostProcessor(final SoulSpringMvcConfig soulSpringMvcConfig) { ValidateUtils.validate(soulSpringMvcConfig); this.soulSpringMvcConfig = soulSpringMvcConfig; url = soulSpringMvcConfig.getAdminUrl() + \u0026amp;quot;/soul-client/springmvc-register\u0026amp;quot;; executorService = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026amp;lt;\u0026amp;gt;()); }  2. springmvc-register 接口逻辑 全局搜索 \u0026amp;ldquo;springmvc-register\u0026amp;rdquo;，找到 soul-admin 模块下的 SoulClientController，看到这里，对于经常写 CRUD 的我们是不是很熟悉？哈哈~\n// SoulClientController.java /** * Register spring mvc string. * * @param springMvcRegisterDTO the spring mvc register dto * @return the string */ @PostMapping(\u0026amp;quot;/springmvc-register\u0026amp;quot;) public String registerSpringMvc(@RequestBody final SpringMvcRegisterDTO springMvcRegisterDTO) { return soulClientRegisterService.registerSpringMvc(springMvcRegisterDTO); }  Service 层实现类：\n// SoulClientRegisterServiceImpl.java @Override @Transactional public String registerSpringMvc(final SpringMvcRegisterDTO dto) { if (dto.isRegisterMetaData()) { MetaDataDO exist = metaDataMapper.findByPath(dto.getPath()); if (Objects.isNull(exist)) { saveSpringMvcMetaData(dto); } } String selectorId = handlerSpringMvcSelector(dto); handlerSpringMvcRule(selectorId, dto); return SoulResultMessage.SUCCESS; }  dto.isRegisterMetaData() 这个是否注册元数据信息的判断，不知道什么时候用，存疑 //TODO，先往下走。\n2.1 先看看这个方法 handlerSpringMvcSelector，处理 Selector。 // SoulClientRegisterServiceImpl.java private String handlerSpringMvcSelector(final SpringMvcRegisterDTO dto) { String contextPath = dto.getContext(); // 根据 contextPath 到数据库里查询，是否已经注册过。 SelectorDO selectorDO = selectorService.findByName(contextPath); String selectorId; String uri = String.join(\u0026amp;quot;:\u0026amp;quot;, dto.getHost(), String.valueOf(dto.getPort())); if (Objects.isNull(selectorDO)) { // 还没有注册过 selectorId = registerSelector(contextPath, dto.getRpcType(), dto.getAppName(), uri); } else { // 已经注册过，业务系统重启了会到这里 selectorId = selectorDO.getId(); //update upstream String handle = selectorDO.getHandle(); String handleAdd; DivideUpstream addDivideUpstream = buildDivideUpstream(uri); SelectorData selectorData = selectorService.buildByName(contextPath); if (StringUtils.isBlank(handle)) { handleAdd = GsonUtils.getInstance().toJson(Collections.singletonList(addDivideUpstream)); } else { List\u0026amp;lt;DivideUpstream\u0026amp;gt; exist = GsonUtils.getInstance().fromList(handle, DivideUpstream.class); for (DivideUpstream upstream : exist) { if (upstream.getUpstreamUrl().equals(addDivideUpstream.getUpstreamUrl())) { return selectorId; } } exist.add(addDivideUpstream); handleAdd = GsonUtils.getInstance().toJson(exist); } selectorDO.setHandle(handleAdd); selectorData.setHandle(handleAdd); // update db …","date":1610928000,"description":"Soul Learning (2) HTTP Client Access Source Code Parsing","dir":"blog/soul_source_learning_02_http_client_register/","fuzzywordcount":2600,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"0250f632e321a9fb3bd295f4597266e6","permalink":"/en/blog/soul_source_learning_02_http_client_register/","publishdate":"2021-01-18T00:00:00Z","readingtime":6,"relpermalink":"/en/blog/soul_source_learning_02_http_client_register/","summary":"HTTP 用户接入 Soul 网关注册逻辑分析 1. 注册入口 HTTP 用户接入 Soul 网关时，会调用 soul-admin 一个接口，把需要 Soul 网关管理的接口注册，今天就具体看看到底干了点儿啥。 先看下","tags":["Soul"],"title":"Soul Gateway Learning (2) HTTP Client Access Source Code Parsing","type":"blog","url":"/en/blog/soul_source_learning_02_http_client_register/","wordcount":2520},{"author":"范金鹏","categories":"Soul","content":" HTTP 用户接入 Soul 网关注册逻辑分析 1. 注册入口 HTTP 用户接入 Soul 网关时，会调用 soul-admin 一个接口，把需要 Soul 网关管理的接口注册，今天就具体看看到底干了点儿啥。\n先看下调用的接口信息如下：\n// SpringMvcClientBeanPostProcessor.java /** * Instantiates a new Soul client bean post processor. * * @param soulSpringMvcConfig the soul spring mvc config */ public SpringMvcClientBeanPostProcessor(final SoulSpringMvcConfig soulSpringMvcConfig) { ValidateUtils.validate(soulSpringMvcConfig); this.soulSpringMvcConfig = soulSpringMvcConfig; url = soulSpringMvcConfig.getAdminUrl() + \u0026amp;quot;/soul-client/springmvc-register\u0026amp;quot;; executorService = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026amp;lt;\u0026amp;gt;()); }  2. springmvc-register 接口逻辑 全局搜索 \u0026amp;ldquo;springmvc-register\u0026amp;rdquo;，找到 soul-admin 模块下的 SoulClientController，看到这里，对于经常写 CRUD 的我们是不是很熟悉？哈哈~\n// SoulClientController.java /** * Register spring mvc string. * * @param springMvcRegisterDTO the spring mvc register dto * @return the string */ @PostMapping(\u0026amp;quot;/springmvc-register\u0026amp;quot;) public String registerSpringMvc(@RequestBody final SpringMvcRegisterDTO springMvcRegisterDTO) { return soulClientRegisterService.registerSpringMvc(springMvcRegisterDTO); }  Service 层实现类：\n// SoulClientRegisterServiceImpl.java @Override @Transactional public String registerSpringMvc(final SpringMvcRegisterDTO dto) { if (dto.isRegisterMetaData()) { MetaDataDO exist = metaDataMapper.findByPath(dto.getPath()); if (Objects.isNull(exist)) { saveSpringMvcMetaData(dto); } } String selectorId = handlerSpringMvcSelector(dto); handlerSpringMvcRule(selectorId, dto); return SoulResultMessage.SUCCESS; }  dto.isRegisterMetaData() 这个是否注册元数据信息的判断，不知道什么时候用，存疑 //TODO，先往下走。\n2.1 先看看这个方法 handlerSpringMvcSelector，处理 Selector。 // SoulClientRegisterServiceImpl.java private String handlerSpringMvcSelector(final SpringMvcRegisterDTO dto) { String contextPath = dto.getContext(); // 根据 contextPath 到数据库里查询，是否已经注册过。 SelectorDO selectorDO = selectorService.findByName(contextPath); String selectorId; String uri = String.join(\u0026amp;quot;:\u0026amp;quot;, dto.getHost(), String.valueOf(dto.getPort())); if (Objects.isNull(selectorDO)) { // 还没有注册过 selectorId = registerSelector(contextPath, dto.getRpcType(), dto.getAppName(), uri); } else { // 已经注册过，业务系统重启了会到这里 selectorId = selectorDO.getId(); //update upstream String handle = selectorDO.getHandle(); String handleAdd; DivideUpstream addDivideUpstream = buildDivideUpstream(uri); SelectorData selectorData = selectorService.buildByName(contextPath); if (StringUtils.isBlank(handle)) { handleAdd = GsonUtils.getInstance().toJson(Collections.singletonList(addDivideUpstream)); } else { List\u0026amp;lt;DivideUpstream\u0026amp;gt; exist = GsonUtils.getInstance().fromList(handle, DivideUpstream.class); for (DivideUpstream upstream : exist) { if (upstream.getUpstreamUrl().equals(addDivideUpstream.getUpstreamUrl())) { return selectorId; } } exist.add(addDivideUpstream); handleAdd = GsonUtils.getInstance().toJson(exist); } selectorDO.setHandle(handleAdd); selectorData.setHandle(handleAdd); // update db …","date":1610928000,"description":"Soul网关学习(2-3)Http客户端接入源码解析","dir":"blog/soul_source_learning_02_http_client_register/","fuzzywordcount":2600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"0250f632e321a9fb3bd295f4597266e6","permalink":"/blog/soul_source_learning_02_http_client_register/","publishdate":"2021-01-18T00:00:00Z","readingtime":6,"relpermalink":"/blog/soul_source_learning_02_http_client_register/","summary":"HTTP 用户接入 Soul 网关注册逻辑分析 1. 注册入口 HTTP 用户接入 Soul 网关时，会调用 soul-admin 一个接口，把需要 Soul 网关管理的接口注册，今天就具体看看到底干了点儿啥。 先看下","tags":["Soul"],"title":"Soul网关学习(2-3)Http客户端接入源码解析","type":"blog","url":"/blog/soul_source_learning_02_http_client_register/","wordcount":2520},{"author":"jipeng","categories":"Soul","content":" Divide 插件如何转发http请求 先来设想一下，网关如果收到了一个请求http://xxx.com/openapi/appname/order/findById?id=3，那么怎么将请求转发给对应的业务？\n可以想象一下大概是这几个步骤：\n 1.解析url 2.查看配置文件，看这个url是对应于哪个业务线 3.读配置文件，获取该业务线在网关注册的所有api列表 4.判断该用户的这个api请求在不在业务的api列表里面 5.进行相关的鉴权操作（用户AK/SK鉴权、用户Quota/QPS有没有超） 6.如果网关有负载均衡功能，那么需要获取业务具体给API配置的负载均衡策略 7.网关向具体的业务API发起请求 8.网关将收到的业务API的response发送给用户  这篇笔记主要来学习一下suol网关是怎么转发http请求的。\n先看一下官方文档的相关介绍http用户、Divide插件\n官方文档里面介绍到，如果网关需要支持http转发，那么需要在网关的pom里面有以下依赖：\n \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--if you use http proxy end this--\u0026amp;gt;  那么可以知道http请求的代理与plugin-divide,plugin-httpclient这两个插件有关。\n插件链 官方文档中说到divide这个插件是实现http请求代理的核心，下面看一下soul-plugin/soul-plugin-divide这个模块的代码，可以看到有一个DividePlugin类，继承自AbstractPlugin，而AbstractPlugin实现了SoulPlugin接口\n可以看到SoulPlugin是DividePlugin的父类，那么猜测一下SoulPlugin是所有插件的父类。全局搜索一下SoulPlugin果然如此，它是诸多插件的父类。\n在全局搜索SoulPlugin的时候，发现soul-web/src/main/java/org/dromara/soul/web/handler里有一个类SoulWebHandler里面有一个属性是List\u0026amp;lt;SoulPlugin\u0026amp;gt;，猜测SoulWebHandler可以操作多个插件。\n看一下SoulWebHandler的继承关系图，发现它是继承了WebHandler，而WebHandler是spring框架里面的一个接口。\n由于对WebFlux不了解，上网快速搜索了一下WebHandler，得知这是WebFlux里面一个很重要的东西，它提供了一套通用的http请求处理方案。\n而soul网关的源码里面，自己实现了一个实现了WebHandler接口的SoulWebHandler类，无疑是希望框架使用soul实现的这套东西来处理请求。\n在soul-web/src/main/java/org/dromara/soul/web/configuration里的SoulConfiguration类，它在类头上声明了注解@Configuration，表明它是一个配置。SoulConfiguration类里面向spring容器注入了一个名为webHandler的bean，该bean是SoulWebHandler类型的。Application会在启动的时候扫描被@Configuration注解的类，所以通过以下代码，SoulWebHandler就被注入到spring容器中去了。\n @Bean(\u0026amp;quot;webHandler\u0026amp;quot;) public SoulWebHandler soulWebHandler(final ObjectProvider\u0026amp;lt;List\u0026amp;lt;SoulPlugin\u0026amp;gt;\u0026amp;gt; plugins) { List\u0026amp;lt;SoulPlugin\u0026amp;gt; pluginList = plugins.getIfAvailable(Collections::emptyList); final List\u0026amp;lt;SoulPlugin\u0026amp;gt; soulPlugins = pluginList.stream() .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList()); soulPlugins.forEach(soulPlugin -\u0026amp;gt; log.info(\u0026amp;quot;load plugin:[{}] [{}]\u0026amp;quot;, soulPlugin.named(), soulPlugin.getClass().getName())); return new SoulWebHandler(soulPlugins); }  初始化SoulWebHandler的时候，将排好序的插件传入其构造函数中。各个插件都有一个order属性，可以根据这个属性来对插件进行优先级排序。以DividePlugin为例，看下它的order属性是从一个枚举类里面来的。\n @Override public int getOrder() { return PluginEnum.DIVIDE.getCode(); }  而各个插件的order的具体值是在soul-common/src/main/java/org/dromara/soul/common/enums/PluginEnums这个枚举类里面定义的。PluginEnum的code即为各个插件的order。\n插件的顺序为：global -\u0026amp;gt; sign -\u0026amp;gt; waf -\u0026amp;gt; rate-limiter -\u0026amp;gt; hystrix -\u0026amp;gt; resilience4j -\u0026amp;gt; divide -\u0026amp;gt; webClient -\u0026amp;gt; …………\n每次有一个请求的时候，WebHandler即SoulWebHandler的handle方法都会被调用，该方法里面最主要的就是初始化了一个插件链DefaultSoulPluginChain，并执行该插件链。\n看一下DefaultSoulPluginChain …","date":1610841600,"description":"How Does The Divide Plugin Forward HTTP Requests","dir":"blog/soul_source_larning_02_divide_plugin_source/","fuzzywordcount":3100,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"e807091742fc0e5091beed30749f9489","permalink":"/en/blog/soul_source_larning_02_divide_plugin_source/","publishdate":"2021-01-17T00:00:00Z","readingtime":7,"relpermalink":"/en/blog/soul_source_larning_02_divide_plugin_source/","summary":"Divide 插件如何转发http请求 先来设想一下，网关如果收到了一个请求http://xxx.com/openapi/appname/order/fi","tags":["Soul"],"title":"Soul Learning(2) How Does The Divide Plugin Forward Http Requests","type":"blog","url":"/en/blog/soul_source_larning_02_divide_plugin_source/","wordcount":3042},{"author":"季鹏","categories":"Soul","content":" Divide 插件如何转发http请求 先来设想一下，网关如果收到了一个请求http://xxx.com/openapi/appname/order/findById?id=3，那么怎么将请求转发给对应的业务？\n可以想象一下大概是这几个步骤：\n 1.解析url 2.查看配置文件，看这个url是对应于哪个业务线 3.读配置文件，获取该业务线在网关注册的所有api列表 4.判断该用户的这个api请求在不在业务的api列表里面 5.进行相关的鉴权操作（用户AK/SK鉴权、用户Quota/QPS有没有超） 6.如果网关有负载均衡功能，那么需要获取业务具体给API配置的负载均衡策略 7.网关向具体的业务API发起请求 8.网关将收到的业务API的response发送给用户  这篇笔记主要来学习一下suol网关是怎么转发http请求的。\n先看一下官方文档的相关介绍http用户、Divide插件\n官方文档里面介绍到，如果网关需要支持http转发，那么需要在网关的pom里面有以下依赖：\n \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--if you use http proxy end this--\u0026amp;gt;  那么可以知道http请求的代理与plugin-divide,plugin-httpclient这两个插件有关。\n插件链 官方文档中说到divide这个插件是实现http请求代理的核心，下面看一下soul-plugin/soul-plugin-divide这个模块的代码，可以看到有一个DividePlugin类，继承自AbstractPlugin，而AbstractPlugin实现了SoulPlugin接口\n可以看到SoulPlugin是DividePlugin的父类，那么猜测一下SoulPlugin是所有插件的父类。全局搜索一下SoulPlugin果然如此，它是诸多插件的父类。\n在全局搜索SoulPlugin的时候，发现soul-web/src/main/java/org/dromara/soul/web/handler里有一个类SoulWebHandler里面有一个属性是List\u0026amp;lt;SoulPlugin\u0026amp;gt;，猜测SoulWebHandler可以操作多个插件。\n看一下SoulWebHandler的继承关系图，发现它是继承了WebHandler，而WebHandler是spring框架里面的一个接口。\n由于对WebFlux不了解，上网快速搜索了一下WebHandler，得知这是WebFlux里面一个很重要的东西，它提供了一套通用的http请求处理方案。\n而soul网关的源码里面，自己实现了一个实现了WebHandler接口的SoulWebHandler类，无疑是希望框架使用soul实现的这套东西来处理请求。\n在soul-web/src/main/java/org/dromara/soul/web/configuration里的SoulConfiguration类，它在类头上声明了注解@Configuration，表明它是一个配置。SoulConfiguration类里面向spring容器注入了一个名为webHandler的bean，该bean是SoulWebHandler类型的。Application会在启动的时候扫描被@Configuration注解的类，所以通过以下代码，SoulWebHandler就被注入到spring容器中去了。\n @Bean(\u0026amp;quot;webHandler\u0026amp;quot;) public SoulWebHandler soulWebHandler(final ObjectProvider\u0026amp;lt;List\u0026amp;lt;SoulPlugin\u0026amp;gt;\u0026amp;gt; plugins) { List\u0026amp;lt;SoulPlugin\u0026amp;gt; pluginList = plugins.getIfAvailable(Collections::emptyList); final List\u0026amp;lt;SoulPlugin\u0026amp;gt; soulPlugins = pluginList.stream() .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList()); soulPlugins.forEach(soulPlugin -\u0026amp;gt; log.info(\u0026amp;quot;load plugin:[{}] [{}]\u0026amp;quot;, soulPlugin.named(), soulPlugin.getClass().getName())); return new SoulWebHandler(soulPlugins); }  初始化SoulWebHandler的时候，将排好序的插件传入其构造函数中。各个插件都有一个order属性，可以根据这个属性来对插件进行优先级排序。以DividePlugin为例，看下它的order属性是从一个枚举类里面来的。\n @Override public int getOrder() { return PluginEnum.DIVIDE.getCode(); }  而各个插件的order的具体值是在soul-common/src/main/java/org/dromara/soul/common/enums/PluginEnums这个枚举类里面定义的。PluginEnum的code即为各个插件的order。\n插件的顺序为：global -\u0026amp;gt; sign -\u0026amp;gt; waf -\u0026amp;gt; rate-limiter -\u0026amp;gt; hystrix -\u0026amp;gt; resilience4j -\u0026amp;gt; divide -\u0026amp;gt; webClient -\u0026amp;gt; …………\n每次有一个请求的时候，WebHandler即SoulWebHandler的handle方法都会被调用，该方法里面最主要的就是初始化了一个插件链DefaultSoulPluginChain，并执行该插件链。\n看一下DefaultSoulPluginChain …","date":1610841600,"description":"Soul网关学习(2-2)divide插件源码解析","dir":"blog/soul_source_learning_02_divide_plugin_source/","fuzzywordcount":3100,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"87d7b3afe46aadf1a286650e6cd702ec","permalink":"/blog/soul_source_learning_02_divide_plugin_source/","publishdate":"2021-01-17T00:00:00Z","readingtime":7,"relpermalink":"/blog/soul_source_learning_02_divide_plugin_source/","summary":"Divide 插件如何转发http请求 先来设想一下，网关如果收到了一个请求http://xxx.com/openapi/appname/order/fi","tags":["Soul"],"title":"Soul网关学习(2-2)Http代理之divide插件源码解析","type":"blog","url":"/blog/soul_source_learning_02_divide_plugin_source/","wordcount":3042},{"author":"yuanjie","categories":"Soul","content":" Divide 插件使用 一、启动项目 先启动soul-bootstrap（9195）、soul-admin（9095）两个模块，我们通过bootstrap配置文件可以看到，两者是通过WebSocket协议进行数据同步：\n通过bootstrap日志也可以看到：\n所谓的数据同步是指将soul-admin中配置的数据，同步到soul集群中的JVM内存里面，是网关高性能的关键。\n我们启动两个项目之后就可以通过后台管理系统测试divide插件了。\n二、divide插件介绍 divide插件是网关处理http协议请求的核心处理插件，也是soul唯一默认开启的插件：\n我们可以想象一下网关到底是做什么的，去猜测一下处理http请求的divide插件可能具备哪些功能呢？\n首先，作为微服务网关，它的背后一定存在多条业务线的分布式微服务集群，而网关作为所有服务的统一入口，必须具备的能力就是流量分发/路由/负载均衡等，而divide这个单词顾名思义就是分配、分发的意思，所以我们可以猜测divide插件就是对http请求进行各种规则的路由转发，这也是网关最基础的能力。\n我们打开管理界面上的插件列表，可以看到所有插件都是由两部分组成：选择器（selector）和选择器规则。\n插件化设计思想是soul网关最核心的设计思想，而选择器和规则这两个概念也是soul网关的灵魂所在，理论上来说，我们掌握好它，就能对任何接入网关的流量进行管理。\n一个插件有多个选择器，一个选择器对应多种规则。选择器相当于是对流量的第一次筛选，规则就是最终的筛选。\n选择器 * **名称**：为你的选择器起一个容易分辨的名字 * **类型**：custom flow 是自定义流量。full flow 是全流量。自定义流量就是请求会走你下面的匹配方式与条件。全流量则不走。 * **匹配方式**：and 或者or 是指下面多个条件是按照and 还是or的方式来组合。 * **条件**： * uri：是指你根据uri的方式来筛选流量，match的方式支持模糊匹配（/**） * header：是指根据请求头里面的字段来筛选流量。 * query：是指根据uri的查询条件来进行筛选流量。 * ip：是指根据你请求的真实ip，来筛选流量。 * host：是指根据你请求的真实host，来筛选流量。 * post：建议不要使用。 * 条件匹配： * match : 模糊匹配，建议和uri条件搭配，支持 restful风格的匹配。（/test/**） * = : 前后值相等，才能匹配。 * regEx : 正则匹配，表示前面一个值去匹配后面的正则表达式。 * like ：字符串模糊匹配。 * **是否开启**：打开才会生效 * **打印日志**：打开的时候，当匹配上的时候，会打印匹配日志。 * **执行顺序**：当多个选择器的时候，执行顺序小的优先执行。  选择器规则 可以看到，规则的配置和选择器类似，可以理解为更细粒度的自定义配置。\n三、divide插件使用 废话少说，我们直接运行soul提供的examples模块来演示divide插件。\n注意，我们最终运行的是soul-examples-http模块。配置文件可以使用默认的，也可以自定义contextPath和appName，如上图。\n我们需要注意，contextPath这个属性非常重要，相当于是我们所有http请求的namespace，和选择器一一对齐。一般来说，我们可以配置一个业务对应一个contextPath，一个业务下面配置相同contextPath的多个服务实例会自动映射到同一个选择器进行负载均衡。\n我们启动端口为8188的这个进程后，可以发现管理控制台divide插件列表中自动配置了这个实例对应的选择器、规则：\n可以看到我启动的这个8188项目地址自动注册上去了：\n测试网关路由 通过postman先测试不经过网关转发：\nhttp://localhost:8188/order/findById?id=1  然后再测试通过网关转发到这个接口：\nhttp://localhost:9195/my-http/order/findById?id=1  看日志发现确实经过了网关转发到了8188接口地址：\n测试负载均衡 我们修改端口为8189，启动第二个进程。\n注意IDEA需要取消 Single instance only 的限制：\n我们再进入管理控制台，发现my-http选择器下出现两个配置地址：\n此时我们继续测试，发现负载均衡策略确实生效了：\n今天只是演示了divide插件最基础的配置，还有其他各种规则配置后面都可以试一试~\n","date":1610755200,"description":"Soul Learning(2) Use Divide Plugin","dir":"blog/soul_source_learning_02_divide_plugin/","fuzzywordcount":1800,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"2f8e9ee0f9bd97eb4313cd7e08719204","permalink":"/en/blog/soul_source_learning_02_divide_plugin/","publishdate":"2021-01-16T00:00:00Z","readingtime":4,"relpermalink":"/en/blog/soul_source_learning_02_divide_plugin/","summary":"Divide 插件使用 一、启动项目 先启动soul-bootstrap（9195）、soul-admin（9095）两个模块，我们通过bootstrap配","tags":["Soul"],"title":"Soul Learning(2) Use Divide Plugin","type":"blog","url":"/en/blog/soul_source_learning_02_divide_plugin/","wordcount":1717},{"author":"袁杰","categories":"Soul","content":" Divide 插件使用 一、启动项目 先启动soul-bootstrap（9195）、soul-admin（9095）两个模块，我们通过bootstrap配置文件可以看到，两者是通过WebSocket协议进行数据同步：\n通过bootstrap日志也可以看到：\n所谓的数据同步是指将soul-admin中配置的数据，同步到soul集群中的JVM内存里面，是网关高性能的关键。\n我们启动两个项目之后就可以通过后台管理系统测试divide插件了。\n二、divide插件介绍 divide插件是网关处理http协议请求的核心处理插件，也是soul唯一默认开启的插件：\n我们可以想象一下网关到底是做什么的，去猜测一下处理http请求的divide插件可能具备哪些功能呢？\n首先，作为微服务网关，它的背后一定存在多条业务线的分布式微服务集群，而网关作为所有服务的统一入口，必须具备的能力就是流量分发/路由/负载均衡等，而divide这个单词顾名思义就是分配、分发的意思，所以我们可以猜测divide插件就是对http请求进行各种规则的路由转发，这也是网关最基础的能力。\n我们打开管理界面上的插件列表，可以看到所有插件都是由两部分组成：选择器（selector）和选择器规则。\n插件化设计思想是soul网关最核心的设计思想，而选择器和规则这两个概念也是soul网关的灵魂所在，理论上来说，我们掌握好它，就能对任何接入网关的流量进行管理。\n一个插件有多个选择器，一个选择器对应多种规则。选择器相当于是对流量的第一次筛选，规则就是最终的筛选。\n选择器 * **名称**：为你的选择器起一个容易分辨的名字 * **类型**：custom flow 是自定义流量。full flow 是全流量。自定义流量就是请求会走你下面的匹配方式与条件。全流量则不走。 * **匹配方式**：and 或者or 是指下面多个条件是按照and 还是or的方式来组合。 * **条件**： * uri：是指你根据uri的方式来筛选流量，match的方式支持模糊匹配（/**） * header：是指根据请求头里面的字段来筛选流量。 * query：是指根据uri的查询条件来进行筛选流量。 * ip：是指根据你请求的真实ip，来筛选流量。 * host：是指根据你请求的真实host，来筛选流量。 * post：建议不要使用。 * 条件匹配： * match : 模糊匹配，建议和uri条件搭配，支持 restful风格的匹配。（/test/**） * = : 前后值相等，才能匹配。 * regEx : 正则匹配，表示前面一个值去匹配后面的正则表达式。 * like ：字符串模糊匹配。 * **是否开启**：打开才会生效 * **打印日志**：打开的时候，当匹配上的时候，会打印匹配日志。 * **执行顺序**：当多个选择器的时候，执行顺序小的优先执行。  选择器规则 可以看到，规则的配置和选择器类似，可以理解为更细粒度的自定义配置。\n三、divide插件使用 废话少说，我们直接运行soul提供的examples模块来演示divide插件。\n注意，我们最终运行的是soul-examples-http模块。配置文件可以使用默认的，也可以自定义contextPath和appName，如上图。\n我们需要注意，contextPath这个属性非常重要，相当于是我们所有http请求的namespace，和选择器一一对齐。一般来说，我们可以配置一个业务对应一个contextPath，一个业务下面配置相同contextPath的多个服务实例会自动映射到同一个选择器进行负载均衡。\n我们启动端口为8188的这个进程后，可以发现管理控制台divide插件列表中自动配置了这个实例对应的选择器、规则：\n可以看到我启动的这个8188项目地址自动注册上去了：\n测试网关路由 通过postman先测试不经过网关转发：\nhttp://localhost:8188/order/findById?id=1  然后再测试通过网关转发到这个接口：\nhttp://localhost:9195/my-http/order/findById?id=1  看日志发现确实经过了网关转发到了8188接口地址：\n测试负载均衡 我们修改端口为8189，启动第二个进程。\n注意IDEA需要取消 Single instance only 的限制：\n我们再进入管理控制台，发现my-http选择器下出现两个配置地址：\n此时我们继续测试，发现负载均衡策略确实生效了：\n今天只是演示了divide插件最基础的配置，还有其他各种规则配置后面都可以试一试~\n","date":1610755200,"description":"Soul网关学习(2-1)divide插件使用","dir":"blog/soul_source_learning_02_divide_plugin/","fuzzywordcount":1800,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"2f8e9ee0f9bd97eb4313cd7e08719204","permalink":"/blog/soul_source_learning_02_divide_plugin/","publishdate":"2021-01-16T00:00:00Z","readingtime":4,"relpermalink":"/blog/soul_source_learning_02_divide_plugin/","summary":"Divide 插件使用 一、启动项目 先启动soul-bootstrap（9195）、soul-admin（9095）两个模块，我们通过bootstrap配","tags":["Soul"],"title":"Soul网关学习(2-1)Http代理之divide插件使用","type":"blog","url":"/blog/soul_source_learning_02_divide_plugin/","wordcount":1717},{"author":"chenxi","categories":"Soul","content":" Analysis of soul (1) Set up soul environment  soul is a High-Performance Java API Gateway\nGitHub：https://github.com/dromara/soul\ndocument：https://dromara.org/zh-cn/docs/soul/soul.html\n 1. Prepare source code 1.1. Fork dromara/soul repository to my github cchenxi/soul 1.2. Clone the repository git clone https://github.com/cchenxi/soul.git  1.3.Open the source code with idea 1.4. Compile the soul source code You can compile the project as follows.\nmvn clean package install -Dmaven.test.skip=true -Dmaven.javadoc.skip=true -Drat.skip=true -Dcheckstyle.skip=true  2. Startup soul 2.1. Startup soul-admin module  soul-admin is the management system for soul.\n Choose to use MySQL to storage gateway data and modify the datasource config.\nRun org.dromara.soul.admin.SoulAdminBootstrap.\nWhen success, please visit the website http://localhost:9095/, then jump to the login page, and input the corresponding user name and password to log in.\nThe user name is admin and the password is 123456.\n2.2. Startup soul-bootstrap module  soul-bootstrap is the core of soul.\n Check the configuration of soul-bootstrap.\nPlease make sure the ip and the port has been configured for soul-admin.\nIf the console output as follows, it means the startup is successful.\n2021-01-14 15:01:15.832 INFO 17943 --- [ main] b.s.s.d.w.WebsocketSyncDataConfiguration : you use websocket sync soul data....... 2021-01-14 15:01:15.924 INFO 17943 --- [ main] o.d.s.p.s.d.w.WebsocketSyncDataService : websocket connection is successful..... 2021-01-14 15:01:16.113 INFO 17943 --- [ main] o.s.b.a.e.web.EndpointLinksResolver : Exposing 2 endpoint(s) beneath base path \u0026#39;/actuator\u0026#39; log4j:WARN No appenders could be found for logger (com.alibaba.dubbo.common.logger.LoggerFactory). log4j:WARN Please initialize the log4j system properly. log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. 2021-01-14 15:01:17.150 INFO 17943 --- [ main] o.s.b.web.embedded.netty.NettyWebServer : Netty started on port(s): 9195 2021-01-14 15:01:17.154 INFO 17943 --- [ main] o.d.s.b.SoulBootstrapApplication : Started SoulBootstrapApplication in 5.508 seconds (JVM running for 6.762)  3. Test  Add the soul-examples module to soul\u0026amp;rsquo;s pom.xml for test.\n 3.1. Startup an HTTP backend service Startup soul-examples-http\nYou can see the dependency in soul-examples-http\u0026amp;rsquo;s pom.xml.\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${soul.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Configure the application.yml\nsoul: http: adminUrl: http://localhost:9095 port: 8188 contextPath: /http appName: http full: false  If soul.http.full=false, you need to add the @SoulSpringMvcClient annotation in controller or controller method.\n3.1.1. Test the service Visit http://localhost:8188/test/findByUserId?userId=1 and the result as follows.\n3.1.2. Test forward HTTP request Visit …","date":1610668800,"description":"Soul Learning(1) Environment Configuration","dir":"blog/soul_source_learning_01/","fuzzywordcount":1000,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"acd16484c415b96fd1431107b88a9ce6","permalink":"/en/blog/soul_source_learning_01/","publishdate":"2021-01-15T00:00:00Z","readingtime":5,"relpermalink":"/en/blog/soul_source_learning_01/","summary":"Analysis of soul (1) Set up soul environment  soul is a High-Performance Java API Gateway\nGitHub：https://github.com/dromara/soul\ndocument：https://dromara.org/zh-cn/docs/soul/soul.html\n 1. Prepare source code 1.1. Fork dromara/soul repository to my github cchenxi/soul 1.2. Clone the repository git clone https://github.com/cchenxi/soul.git  1.3.Open the source code with idea 1.4. Compile the soul source code You can compile the project as follows.\nmvn clean package install -Dmaven.test.skip=true -Dmaven.javadoc.skip=true -Drat.skip=true -Dcheckstyle.skip=true  2. Startup soul 2.","tags":["Soul"],"title":"Soul Learning(1) Environment Configuration","type":"blog","url":"/en/blog/soul_source_learning_01/","wordcount":933},{"author":"陈曦","categories":"Soul","content":" Soul源码分析（1） 环境配置  soul is a High-Performance Java API Gateway\nGitHub：https://github.com/dromara/soul\n官方文档：https://dromara.org/zh-cn/docs/soul/soul.html\n 1. 源代码准备 1.1. fork dromara/soul源代码至自己的仓库cchenxi/soul 1.2. clone自己仓库中的soul源代码至本地 git clone https://github.com/cchenxi/soul.git  1.3.使用idea打开soul源代码 1.4.编译soul源代码 执行以下maven命令，等待编译完成\nmvn clean package install -Dmaven.test.skip=true -Dmaven.javadoc.skip=true -Drat.skip=true -Dcheckstyle.skip=true  2. 启动 soul 2.1. 启动soul-admin模块  soul-admin是soul网关的后台管理系统\n 选择使用MySQL数据库存储网关数据，修改数据源配置为自己的数据库配置。\n运行启动类 org.dromara.soul.admin.SoulAdminBootstrap。\n启动成功后，访问地址 http://localhost:9095/ ，跳转到登录页↓\n使用用户名admin，密码 123456 登录。\n2.2. 启动soul-bootstrap模块  soul-bootstrap是网关系统的核心\n 检查soul-bootstrap的配置\n这里需要配置成 soul-admin的ip和端口\n控制台输出如下内容表示 soul-bootstrap启动成功\n2021-01-14 15:01:15.832 INFO 17943 --- [ main] b.s.s.d.w.WebsocketSyncDataConfiguration : you use websocket sync soul data....... 2021-01-14 15:01:15.924 INFO 17943 --- [ main] o.d.s.p.s.d.w.WebsocketSyncDataService : websocket connection is successful..... 2021-01-14 15:01:16.113 INFO 17943 --- [ main] o.s.b.a.e.web.EndpointLinksResolver : Exposing 2 endpoint(s) beneath base path \u0026#39;/actuator\u0026#39; log4j:WARN No appenders could be found for logger (com.alibaba.dubbo.common.logger.LoggerFactory). log4j:WARN Please initialize the log4j system properly. log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. 2021-01-14 15:01:17.150 INFO 17943 --- [ main] o.s.b.web.embedded.netty.NettyWebServer : Netty started on port(s): 9195 2021-01-14 15:01:17.154 INFO 17943 --- [ main] o.d.s.b.SoulBootstrapApplication : Started SoulBootstrapApplication in 5.508 seconds (JVM running for 6.762)  3. 测试http请求转发  为了方便测试，把soul-examples模块添加到soul的pom里\n 3.1. 启动一个服务 启动soul-examples-http项目\nsoul-examples-http的pom中引入了依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${soul.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  在 application.yml中配置\nsoul: http: adminUrl: http://localhost:9095 port: 8188 contextPath: /http appName: http full: false  如果soul.http.full=false，则需要在具体的http接口上配置 @SoulSpringMvcClient 注解\n3.1.1. 测试http服务 执行http请求 http://localhost:8188/test/findByUserId?userId=1 结果如下图\n3.1.2. 测试网关转发 执行http请求 http://localhost:9195/http/test/findByUserId?userId=1 结果如下图\n在soul-bootstrap的控制台中输出如下信息\n2021-01-14 20:42:57.123 INFO 29812 --- [work-threads-11] o.d.soul.plugin.base.AbstractSoulPlugin : divide selector success match , selector name :/http 2021-01-14 20:42:57.125 INFO 29812 --- [work-threads-11] o.d.soul.plugin.base.AbstractSoulPlugin : divide selector success match , selector name :/http/test/** 2021-01-14 20:42:57.126 INFO 29812 --- [work-threads-11] o.d.s.plugin.httpclient.WebClientPlugin : The request urlPath is http://172.27.121.155:8188/test/findByUserId?userId=1, retryTimes is 0  可以观察到网关可以将请求正常转发。\n3.2. 启动两个服务模拟负载均衡 勾选 Allow parallel run，修改端口为8189，再次启动soul-examples-http …","date":1610668800,"description":"Soul网关学习(1)环境配置","dir":"blog/soul_source_learning_01/","fuzzywordcount":1700,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"acd16484c415b96fd1431107b88a9ce6","permalink":"/blog/soul_source_learning_01/","publishdate":"2021-01-15T00:00:00Z","readingtime":4,"relpermalink":"/blog/soul_source_learning_01/","summary":"Soul源码分析（1） 环境配置 soul is a High-Performance Java API Gateway GitHub：https://github.com/dromara/soul 官方文档：https","tags":["Soul"],"title":"Soul网关学习(1)环境配置","type":"blog","url":"/blog/soul_source_learning_01/","wordcount":1625},{"author":"SOFA 团队","categories":"Service Mesh","content":" 2020 年 2 月 4 日到 2 月11 日，ServiceMesher 社区发起了 Service Mesh 终端用户调查，以下为问卷调查结果。\n参与问卷调查的人员情况 共收集到 516 份问卷结果，问卷填写者 94.2% 来自 ServiceMesher 社区，21.7% 的人参与过社区线上活动，27.5% 的人参与过社区 meetup，86.6% 看好 Service Mesh 的未来发展前景。\n下面是参与问卷调查人员的基本情况。\n公司所属行业\n所在公司的 Service Mesh 使用情况\n工作年限\n在公司中担任的职务\n关注 Service Mesh 技术的时长\n周围关注或了解 Service Mesh 技术的人员情况\n学习 Service Mesh 技术的方式\n关注的 Service Mesh 相关开源项目\n除了 Service Mesh 外关注的其他云原生领域\n对 Service Mesh 的了解程度\n关注 Service Mesh 技术中的哪部分\n社区参与 了解社区活动的情况\n对社区的建议\n还有很多对社区的建议，反馈比较多的如下：\n 更多落地实践和指南 发布一些入门级的文章，结合案例，让技术在中小企业中落地 组织一些线上或线下活动 对普通开发者的职业发展的建议 出系列教程  结论 从结果中可以看出，Service Mesh 在互联网公司中关注的比例最高，但是它仍然还在高速发展中，还缺乏完善的教程和案例。\n本次问卷调查旨在了解 ServiceMesher 社区成员对 Service Mesh 的了解及社区参与程度，帮助 ServiceMesher 社区做的更好，还需要社区成员们共同的努力。\n欢迎关注 Service Mesh 技术的小伙伴们加入 ServiceMesher 社区，共同交流学习和成长。\n关于本次调查问卷的最终解释权归 ServiceMesher 社区所有。\n","date":1581667200,"description":"2020 年 2 月 4 日到 2 月11 日，ServiceMesher 社区发起了 Service Mesh 终端用户调查，以下为问卷调查结果。","dir":"service-mesh-end-user-survey-report/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"894b42fb32c6c3c39986e020fd53a13e","permalink":"/service-mesh-end-user-survey-report/","publishdate":"2020-02-14T16:00:00+08:00","readingtime":2,"relpermalink":"/service-mesh-end-user-survey-report/","summary":"2020 年 2 月 4 日到 2 月11 日，ServiceMesher 社区发起了 Service Mesh 终端用户调查，以下为问卷调查结果。 参与问卷调查的人员情况 共收集到 516 份问卷结","tags":["Service Mesh"],"title":"Service Mesh 终端用户调查报告","type":"page","url":"/service-mesh-end-user-survey-report/","wordcount":530},{"author":"Jimmy Song","categories":null,"content":" SOFAStack Cloud Native Workshop hosted by Ant Financial (KubeCon China 2019 Co-Located Event)  Date: Monday, 24 June, 2019 Time: 9:00 – 16:00 Location: Shanghai Expo Centre Room 616 Registration Fees: Complimentary Register here: https://www.lfasiallc.com/events/kubecon-cloudnativecon-china-2019/co-located-events/#sofastack-cloud-native-workshop Note: This event is hands-on, please bring your personal computer. The language of communication in this workshop is Chinese.  SOFAStack (Scalable Open Financial Architecture Stack) is a financial-grade distributed architecture independently developed and open sourced by Ant Financial. It contains the components required to build a financial-grade cloud native architecture. It is a best practice tempered in financial scenarios. SOFAStack official website: https://www.sofastack.tech/\nAttendees can get:\n Rapidly build microservices based on SOFAStack Best Practices for Distributed Transactions in Financial Scenarios Cloud native deployment experience based on Kubernetes Service Mesh basic usage scenario experience on the cloud Get started on Serverless apps Easily build applications on the cloud based on Serverless  How to Register: Pre-registration is required. To register for SOFAStack Cloud Native Workshop, add it on during your KubeCon + CloudNativeCon + Open Source Summit registration. You can get KubeCon half price tickets with KCCN19COMATF coupon code!\nFor questions regarding this event, please reach out to jingchao.sjc@antfin.com.\nEvent details 9:00 - 9:20 Opening speech SOFAStack Cloud Native\n9:20 - 10:10 Quickly build microservices with SOFAStack by Jie Cao\nBuilding a microservices application based on the SOFAStack. Through this workshop, you can learn how to report application monitoring data, service link data, and publish and subscribe services in the SOFAStack.\n10:15 - 11:05 SOFABoot dynamic module practice by Guolei Song\nIn this workshop, you can implement the combined deployment and dynamic module push capabilities provided by SOFAArk based on the ARK control capabilities of SOFADashboard.\n11:10 - 12:00 Using Seata to guarantee the consistency of payment by Long Chen\nUnder the microservice architecture, the distributed transaction problem is an industry problem. Through this workshop, you can understand the background of distributed transaction problems under distributed architecture, as well as common distributed transaction solutions and experience on how to use the open source distributed transaction framework - Seata\u0026amp;rsquo;s AT mode, TCC mode to solve the ultimate consistency of the business data.\n12:00 - 13:00 Lunch time\n13:00 - 13:30 Cloud Native exlporation and practice in Ant Fnancial by Renjie Yu\n13:30 - 14:40 Migrating to cloud based on Serverless by Yitao Dong\nAs one of the pioneering technologies of cloud technology, Serverless architecture allows you to further improve resource utilization and focus on business development. Through our workshop, you can experience new product …","date":1559643600,"description":"","dir":"activities/sofastack-cloud-native-workshop/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"57c6b0262af34c2010179000834d8363","permalink":"/en/activities/sofastack-cloud-native-workshop/","publishdate":"2019-06-04T10:20:00Z","readingtime":3,"relpermalink":"/en/activities/sofastack-cloud-native-workshop/","summary":"SOFAStack Cloud Native Workshop hosted by Ant Financial (KubeCon China 2019 Co-Located Event)  Date: Monday, 24 June, 2019 Time: 9:00 – 16:00 Location: Shanghai Expo Centre Room 616 Registration Fees: Complimentary Register here: https://www.lfasiallc.com/events/kubecon-cloudnativecon-china-2019/co-located-events/#sofastack-cloud-native-workshop Note: This event is hands-on, please bring your personal computer. The language of communication in this workshop is Chinese.  SOFAStack (Scalable Open Financial Architecture Stack) is a financial-grade distributed architecture independently developed and open sourced by Ant Financial.","tags":["KubeCon","Workshop","Cloud Native"],"title":"KubeCon China 2019 Co-Located Event SOFAStack Cloud Native Workshop","type":"activities","url":"/en/activities/sofastack-cloud-native-workshop/","wordcount":515},{"author":"xiaoyu","categories":"Soul","content":" Soul网关发布1.0.4-RELEASE版本  修复在1.0.3版本的后台管理中，出现的bug。 配置信息序列化方式支持自定义扩展。默认的序列化方式由kroy 改为了java序列化方式。 dubbo框架支持的更改。  对dubbo用户使用的更改。  在以前的版本中（1.0.2 or 1.0.3），dubbo的参数是通过header头上传递，在1.0.4版本中是通过body传递\n 更新了相关的文档信息。\n  关于使用1.0.4版本的建议。  1.0.4 版本支持用户自定义插件开发，支持正则表达式的匹配。\n dubbo参数传递的更改，我觉得这样会更加友好。\n  如果您之前使用的1.0.2版本，想要更新到1.0.4版本。  在插件表新增role字段。\n 重新启动1.0.4版本的管理后台。\n 执行同步所有插件（因为序列化方式的更改）\n 启动1.0.4版本的soul-web服务。\n  遇到问题？  添加qq群（429951241）\n 官网文档：https://dromara.org/website/zh-cn/docs/soul/soul.html\n github地址: https://github.com/Dromara/soul\n gitee地址： https://gitee.com/shuaiqiyu/soul\n  ","date":1554768000,"description":"Soul网关发布1.0.4-RELEASE版本","dir":"community/soul_1.0.4/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"702f107e83d5e99cba8e3ffdf47f2874","permalink":"/community/soul_1.0.4/","publishdate":"2019-04-09T00:00:00Z","readingtime":1,"relpermalink":"/community/soul_1.0.4/","summary":"Soul网关发布1.0.4-RELEASE版本 修复在1.0.3版本的后台管理中，出现的bug。 配置信息序列化方式支持自定义扩展。默认的序列化","tags":["Soul"],"title":"Soul网关发布1.0.4-RELEASE版本","type":"community","url":"/community/soul_1.0.4/","wordcount":452},{"author":"xiaoyu","categories":"hmily","content":" Hmily 发布2.0.2-RELEASE 版本  解决SpringCloud 使用hystrix 配置线程池策略的问题。\n 新增对springcloud 内嵌事务调用的问题。\n 新增Hmily负载均衡策略。\n 其他bug的修护，与代码的优化。\n 去除不必须的第三方jar包。\n 零侵入方式的引入。\n  Hmily对现在流行RPC框架以及Spring的支持情况。  dubbo 2.7.0以下所有版本。\n Springcloud Dalston以上版本，包括支持现在的Finchley 与 Greenwich\n Motan 所有版本。\n 3.0以上所有Spring版本。\n  Hmily 在2.0.2版本对使用者RPC集群时候负载均衡策略。  hmily提供了自己实现的负载均衡策略，只是针对加了@Hmily的接口  dubbo 集群配置,配置负载方式为：loadbalance=\u0026amp;ldquo;hmily\u0026amp;rdquo;\n\u0026amp;lt;dubbo:reference timeout=\u0026amp;quot;50000\u0026amp;quot; interface=\u0026amp;quot;org.dromara.hmily.demo.dubbo.account.api.service.AccountService\u0026amp;quot; id=\u0026amp;quot;accountService\u0026amp;quot; retries=\u0026amp;quot;0\u0026amp;quot; check=\u0026amp;quot;false\u0026amp;quot; actives=\u0026amp;quot;20\u0026amp;quot; loadbalance=\u0026amp;quot;hmily\u0026amp;quot;/\u0026amp;gt;  Springcloud 在调用方的yml配置文件中新增：\nhmily ： ribbon: rule enabled : true  Hmily的具体使用文档：  官网文档 ：https://dromara.org/website/zh-cn/docs/hmily/index.html\n github地址: https://github.com/yu199195/hmily\n gitee地址： https://gitee.com/shuaiqiyu/hmily\n 欢迎大家star fork ，提供优秀的代码与建议。\n  ","date":1554422400,"description":"Hmily发布2.0.2-RELEASE版本","dir":"community/hmily_2.0.2/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"f6519d40a5bc7ba97fcebc76bb59f36d","permalink":"/community/hmily_2.0.2/","publishdate":"2019-04-05T00:00:00Z","readingtime":1,"relpermalink":"/community/hmily_2.0.2/","summary":"Hmily 发布2.0.2-RELEASE 版本 解决SpringCloud 使用hystrix 配置线程池策略的问题。 新增对springcloud 内嵌事务调","tags":["hmily"],"title":"Hmily发布2.0.2-RELEASE版本","type":"community","url":"/community/hmily_2.0.2/","wordcount":474},{"author":"xiaoyu","categories":"hmily","content":" Hmily高并发事务处理 开始先打个小小的广告 Hmily在参开源中国年度受欢迎投票 https://www.oschina.net/project/top_cn_2018?origin=zhzd 点击链接，搜索Hmily帮忙投下票,在第11横排第二个，感谢大家！ 也欢迎大家关注，或者提交pr，让Hmily变的更好，更完美。 gitHub: [https://github.com/yu199195/hmily] gitee: [https://gitee.com/shuaiqiyu/hmily]\n接下来回答一下 社区的一些问题，和大家一些疑惑的地方！\n1. Hmily的性能问题？ 答：Hmily是采用AOP切面的方式与你的RPC方法绑定，无非就是在你RPC调用的时候，保存了日志（通过异步disruptor），传递了一些参数。现在confrim，cancel也都为异步的调用，因此其性能与你的rpc性能一样。记住Hmily不生产事务，Hmily只是分布式事务的搬运工。之前Hmily在AOP切面加了一把锁，导致了性能下降，也就是Spring cloud 中国社区做的那篇文章。现在已经全部修复，并且全部异步化。其实那么测试时不合理的，因为是压测的demo，都是默认的配置。下文我会讲解，怎么样才能提高Hmiy性能。\n2. 关于RPC调用超时Hmily是怎么处理的？ 答： 我们支持在分布式环境中调用一个RPC方法，如果超时了。比如dubbo设置的超时时间是100ms,可能你的方法用了140ms,但是你的方法是执行成功了的。但是对调用方来说，你是失败的。这个时候需要回滚。所以Hmily的做法是。调用者认为你是失败的，不会将加入的回滚调用链条中。因此超时的rpc接口方，进行自身的回滚。会有一个定时任务来进行回滚，因为日志状态是try阶段，会调用cancel方法进行回滚，从而到达最终一致性！\n3.Hmily支持集群部署的问题？以及集群环境中，定时任务日志恢复的问题？ 答：Hmily是和你的应用AOP切面绑定在一起的，天然支持集群。集群环境中定时恢复问题，其实几乎没有，除非你的集群同时一下挂掉，才会有这个问题。当你集群同时挂掉，在恢复的时候，日志会有一个version字段，更新成功的，才会去进行恢复。\n4.Hmily是异步保存日志的，那么很极端情况下（代码刚好执行到这一行,然后jvm退出，断电啦什么的），日志还没保存那怎么处理呢？ 答:这种想法的，肯定是没看源码，或者是看了没怎么看懂。在AOP切面中，会先进行日志的异步保存，注意状态是PRE_TRY。在try执行完成后，更新为try。就算存在可能你说的什么断电，什么你在打断电调试，然后kill服务之类的。（Mysql我都可以让他事务失效，你信不信？）我只能说，不要花大力气去解决那些偶然的事情，最好的解决办法是不解决它。 Hmily针对高并发时候的参数配置调优。 可能这部门内容针对熟悉Hmily的人来说，不熟悉的也没关系。直接上github上看相关文档就好。 hmily支持Spring bean xml 方式的配置，同时也支持spring boot start yml方式的配置。\n\u0026amp;lt;bean id=\u0026amp;quot;hmilyTransactionBootstrap\u0026amp;quot; class=\u0026amp;quot;com.hmily.tcc.core.bootstrap.HmilyTransactionBootstrap\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serializer\u0026amp;quot; value=\u0026amp;quot;kryo\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;recoverDelayTime\u0026amp;quot; value=\u0026amp;quot;120\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;retryMax\u0026amp;quot; value=\u0026amp;quot;3\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;loadFactor\u0026amp;quot; value=\u0026amp;quot;2\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;scheduledDelay\u0026amp;quot; value=\u0026amp;quot;120\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;scheduledThreadMax\u0026amp;quot; value=\u0026amp;quot;4\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;bufferSize\u0026amp;quot; value=\u0026amp;quot;4096\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;consumerThreads\u0026amp;quot; value=\u0026amp;quot;32\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;started\u0026amp;quot; value=\u0026amp;quot;false\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;asyncThreads\u0026amp;quot; value=\u0026amp;quot;32\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;repositorySupport\u0026amp;quot; value=\u0026amp;quot;db\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;tccDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;bean class=\u0026amp;quot;com.hmily.tcc.common.config.TccDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;url\u0026amp;quot; value=\u0026amp;quot;jdbc:mysql://192.168.1.98:3306/tcc?useUnicode=true\u0026amp;amp;amp;characterEncoding=utf8\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;driverClassName\u0026amp;quot; value=\u0026amp;quot;com.mysql.jdbc.Driver\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;username\u0026amp;quot; value=\u0026amp;quot;root\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;password\u0026amp;quot; value=\u0026amp;quot;123456\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;   serializer :这里我推荐使用是kroy。当然hmily也支持hessian,protostuff,jdk。在我们测试中表现为: kroy\u0026amp;gt;hessian\u0026amp;gt;protostuff\u0026amp;gt;jdk\n recoverDelayTime :定时任务延迟时间（单位是秒，默认120。这个参数只是要大于你的rpc调用的超时时间设置。\n retryMax : 最大重复次数，默认3次。当你的服务down机，定时任务会执行retryMax次数去执行你的cancel还是confrim。 …","date":1542153600,"description":"Hmily Configuration Optimization For High Concurrent Transactions","dir":"blog/hmily_current/","fuzzywordcount":1900,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"01e8b6c6e0037b9f9474b7e435a4736e","permalink":"/en/blog/hmily_current/","publishdate":"2018-11-14T00:00:00Z","readingtime":4,"relpermalink":"/en/blog/hmily_current/","summary":"Hmily高并发事务处理 开始先打个小小的广告 Hmily在参开源中国年度受欢迎投票 https://www.oschina.net/project/top_cn_2018?origin=zhzd 点击链接，搜索Hmily帮忙投下票,在第11横排第二个，感","tags":["hmily"],"title":"Hmily: Easy Handle Highly Concurrent Distributed Transactions","type":"blog","url":"/en/blog/hmily_current/","wordcount":1871},{"author":"xiaoyu","categories":"hmily","content":" Hmily高并发事务处理 开始先打个小小的广告 Hmily在参开源中国年度受欢迎投票 https://www.oschina.net/project/top_cn_2018?origin=zhzd 点击链接，搜索Hmily帮忙投下票,在第11横排第二个，感谢大家！ 也欢迎大家关注，或者提交pr，让Hmily变的更好，更完美。 gitHub: [https://github.com/yu199195/hmily] gitee: [https://gitee.com/shuaiqiyu/hmily]\n接下来回答一下 社区的一些问题，和大家一些疑惑的地方！\n1. Hmily的性能问题？ 答：Hmily是采用AOP切面的方式与你的RPC方法绑定，无非就是在你RPC调用的时候，保存了日志（通过异步disruptor），传递了一些参数。现在confrim，cancel也都为异步的调用，因此其性能与你的rpc性能一样。记住Hmily不生产事务，Hmily只是分布式事务的搬运工。之前Hmily在AOP切面加了一把锁，导致了性能下降，也就是Spring cloud 中国社区做的那篇文章。现在已经全部修复，并且全部异步化。其实那么测试时不合理的，因为是压测的demo，都是默认的配置。下文我会讲解，怎么样才能提高Hmiy性能。\n2. 关于RPC调用超时Hmily是怎么处理的？ 答： 我们支持在分布式环境中调用一个RPC方法，如果超时了。比如dubbo设置的超时时间是100ms,可能你的方法用了140ms,但是你的方法是执行成功了的。但是对调用方来说，你是失败的。这个时候需要回滚。所以Hmily的做法是。调用者认为你是失败的，不会将加入的回滚调用链条中。因此超时的rpc接口方，进行自身的回滚。会有一个定时任务来进行回滚，因为日志状态是try阶段，会调用cancel方法进行回滚，从而到达最终一致性！\n3.Hmily支持集群部署的问题？以及集群环境中，定时任务日志恢复的问题？ 答：Hmily是和你的应用AOP切面绑定在一起的，天然支持集群。集群环境中定时恢复问题，其实几乎没有，除非你的集群同时一下挂掉，才会有这个问题。当你集群同时挂掉，在恢复的时候，日志会有一个version字段，更新成功的，才会去进行恢复。\n4.Hmily是异步保存日志的，那么很极端情况下（代码刚好执行到这一行,然后jvm退出，断电啦什么的），日志还没保存那怎么处理呢？ 答:这种想法的，肯定是没看源码，或者是看了没怎么看懂。在AOP切面中，会先进行日志的异步保存，注意状态是PRE_TRY。在try执行完成后，更新为try。就算存在可能你说的什么断电，什么你在打断电调试，然后kill服务之类的。（Mysql我都可以让他事务失效，你信不信？）我只能说，不要花大力气去解决那些偶然的事情，最好的解决办法是不解决它。 Hmily针对高并发时候的参数配置调优。 可能这部门内容针对熟悉Hmily的人来说，不熟悉的也没关系。直接上github上看相关文档就好。 hmily支持Spring bean xml 方式的配置，同时也支持spring boot start yml方式的配置。\n\u0026amp;lt;bean id=\u0026amp;quot;hmilyTransactionBootstrap\u0026amp;quot; class=\u0026amp;quot;com.hmily.tcc.core.bootstrap.HmilyTransactionBootstrap\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serializer\u0026amp;quot; value=\u0026amp;quot;kryo\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;recoverDelayTime\u0026amp;quot; value=\u0026amp;quot;120\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;retryMax\u0026amp;quot; value=\u0026amp;quot;3\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;loadFactor\u0026amp;quot; value=\u0026amp;quot;2\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;scheduledDelay\u0026amp;quot; value=\u0026amp;quot;120\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;scheduledThreadMax\u0026amp;quot; value=\u0026amp;quot;4\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;bufferSize\u0026amp;quot; value=\u0026amp;quot;4096\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;consumerThreads\u0026amp;quot; value=\u0026amp;quot;32\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;started\u0026amp;quot; value=\u0026amp;quot;false\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;asyncThreads\u0026amp;quot; value=\u0026amp;quot;32\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;repositorySupport\u0026amp;quot; value=\u0026amp;quot;db\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;tccDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;bean class=\u0026amp;quot;com.hmily.tcc.common.config.TccDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;url\u0026amp;quot; value=\u0026amp;quot;jdbc:mysql://192.168.1.98:3306/tcc?useUnicode=true\u0026amp;amp;amp;characterEncoding=utf8\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;driverClassName\u0026amp;quot; value=\u0026amp;quot;com.mysql.jdbc.Driver\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;username\u0026amp;quot; value=\u0026amp;quot;root\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;password\u0026amp;quot; value=\u0026amp;quot;123456\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;   serializer :这里我推荐使用是kroy。当然hmily也支持hessian,protostuff,jdk。在我们测试中表现为: kroy\u0026amp;gt;hessian\u0026amp;gt;protostuff\u0026amp;gt;jdk\n recoverDelayTime :定时任务延迟时间（单位是秒，默认120。这个参数只是要大于你的rpc调用的超时时间设置。\n retryMax : 最大重复次数，默认3次。当你的服务down机，定时任务会执行retryMax次数去执行你的cancel还是confrim。 …","date":1542153600,"description":"Hmily针对高并发事务的配置优化","dir":"blog/hmily_current/","fuzzywordcount":1900,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"01e8b6c6e0037b9f9474b7e435a4736e","permalink":"/blog/hmily_current/","publishdate":"2018-11-14T00:00:00Z","readingtime":4,"relpermalink":"/blog/hmily_current/","summary":"Hmily高并发事务处理 开始先打个小小的广告 Hmily在参开源中国年度受欢迎投票 https://www.oschina.net/project/top_cn_2018?origin=zhzd 点击链接，搜索Hmily帮忙投下票,在第11横排第二个，感","tags":["hmily"],"title":"Hmily: 轻松搞定高并发分布式事务","type":"blog","url":"/blog/hmily_current/","wordcount":1871},{"author":"xiaoyu","categories":"hmily","content":" Hmily框架特性[https://github.com/yu199195/hmily]  无缝集成Spring,Spring boot start。\n 无缝集成Dubbo,SpringCloud,Motan等rpc框架。\n 多种事务日志的存储方式（redis，mongdb,mysql等）。\n 多种不同日志序列化方式（Kryo,protostuff,hession）。\n 事务自动恢复。\n 支持内嵌事务的依赖传递。\n 代码零侵入,配置简单灵活。   Hmily为什么这么高性能？ 1.采用disruptor进行事务日志的异步读写（disruptor是一个无锁，无GC的并发编程框架） package com.hmily.tcc.core.disruptor.publisher; import com.hmily.tcc.common.bean.entity.TccTransaction; import com.hmily.tcc.common.enums.EventTypeEnum; import com.hmily.tcc.core.concurrent.threadpool.HmilyThreadFactory; import com.hmily.tcc.core.coordinator.CoordinatorService; import com.hmily.tcc.core.disruptor.event.HmilyTransactionEvent; import com.hmily.tcc.core.disruptor.factory.HmilyTransactionEventFactory; import com.hmily.tcc.core.disruptor.handler.HmilyConsumerDataHandler; import com.hmily.tcc.core.disruptor.translator.HmilyTransactionEventTranslator; import com.lmax.disruptor.BlockingWaitStrategy; import com.lmax.disruptor.IgnoreExceptionHandler; import com.lmax.disruptor.RingBuffer; import com.lmax.disruptor.dsl.Disruptor; import com.lmax.disruptor.dsl.ProducerType; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.util.concurrent.Executor; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; /** * event publisher. * * @author xiaoyu(Myth) */ @Component public class HmilyTransactionEventPublisher implements DisposableBean { private Disruptor\u0026amp;lt;HmilyTransactionEvent\u0026amp;gt; disruptor; private final CoordinatorService coordinatorService; @Autowired public HmilyTransactionEventPublisher(final CoordinatorService coordinatorService) { this.coordinatorService = coordinatorService; } /** * disruptor start. * * @param bufferSize this is disruptor buffer size. * @param threadSize this is disruptor consumer thread size. */ public void start(final int bufferSize, final int threadSize) { disruptor = new Disruptor\u0026amp;lt;\u0026amp;gt;(new HmilyTransactionEventFactory(), bufferSize, r -\u0026amp;gt; { AtomicInteger index = new AtomicInteger(1); return new Thread(null, r, \u0026amp;quot;disruptor-thread-\u0026amp;quot; + index.getAndIncrement()); }, ProducerType.MULTI, new BlockingWaitStrategy()); final Executor executor = new ThreadPoolExecutor(threadSize, threadSize, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026amp;lt;\u0026amp;gt;(), HmilyThreadFactory.create(\u0026amp;quot;hmily-log-disruptor\u0026amp;quot;, false), new ThreadPoolExecutor.AbortPolicy()); HmilyConsumerDataHandler[] consumers = new HmilyConsumerDataHandler[threadSize]; for (int i = 0; i \u0026amp;lt; threadSize; i++) { consumers[i] = new HmilyConsumerDataHandler(executor, coordinatorService); } disruptor.handleEventsWithWorkerPool(consumers); disruptor.setDefaultExceptionHandler(new IgnoreExceptionHandler()); disruptor.start(); } /** * publish disruptor event. * * @param tccTransaction {@linkplain …","date":1537833600,"description":"High-Performance Asynchronous Distributed Transaction TCC Framework","dir":"blog/hmily_introuduction/","fuzzywordcount":2700,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"06b55ed1b90453efe5d9d7cefdf0ecf1","permalink":"/en/blog/hmily_introuduction/","publishdate":"2018-09-25T00:00:00Z","readingtime":6,"relpermalink":"/en/blog/hmily_introuduction/","summary":"Hmily框架特性[https://github.com/yu199195/hmily] 无缝集成Spring,Spring boot start。 无缝","tags":["hmily","TCC"],"title":"Hmily: High-Performance Asynchronous Distributed Transaction TCC Framework","type":"blog","url":"/en/blog/hmily_introuduction/","wordcount":2682},{"author":"xiaoyu","categories":"hmily","content":" Hmily框架特性[https://github.com/yu199195/hmily]  无缝集成Spring,Spring boot start。\n 无缝集成Dubbo,SpringCloud,Motan等rpc框架。\n 多种事务日志的存储方式（redis，mongdb,mysql等）。\n 多种不同日志序列化方式（Kryo,protostuff,hession）。\n 事务自动恢复。\n 支持内嵌事务的依赖传递。\n 代码零侵入,配置简单灵活。   Hmily为什么这么高性能？ 1.采用disruptor进行事务日志的异步读写（disruptor是一个无锁，无GC的并发编程框架） package com.hmily.tcc.core.disruptor.publisher; import com.hmily.tcc.common.bean.entity.TccTransaction; import com.hmily.tcc.common.enums.EventTypeEnum; import com.hmily.tcc.core.concurrent.threadpool.HmilyThreadFactory; import com.hmily.tcc.core.coordinator.CoordinatorService; import com.hmily.tcc.core.disruptor.event.HmilyTransactionEvent; import com.hmily.tcc.core.disruptor.factory.HmilyTransactionEventFactory; import com.hmily.tcc.core.disruptor.handler.HmilyConsumerDataHandler; import com.hmily.tcc.core.disruptor.translator.HmilyTransactionEventTranslator; import com.lmax.disruptor.BlockingWaitStrategy; import com.lmax.disruptor.IgnoreExceptionHandler; import com.lmax.disruptor.RingBuffer; import com.lmax.disruptor.dsl.Disruptor; import com.lmax.disruptor.dsl.ProducerType; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.util.concurrent.Executor; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; /** * event publisher. * * @author xiaoyu(Myth) */ @Component public class HmilyTransactionEventPublisher implements DisposableBean { private Disruptor\u0026amp;lt;HmilyTransactionEvent\u0026amp;gt; disruptor; private final CoordinatorService coordinatorService; @Autowired public HmilyTransactionEventPublisher(final CoordinatorService coordinatorService) { this.coordinatorService = coordinatorService; } /** * disruptor start. * * @param bufferSize this is disruptor buffer size. * @param threadSize this is disruptor consumer thread size. */ public void start(final int bufferSize, final int threadSize) { disruptor = new Disruptor\u0026amp;lt;\u0026amp;gt;(new HmilyTransactionEventFactory(), bufferSize, r -\u0026amp;gt; { AtomicInteger index = new AtomicInteger(1); return new Thread(null, r, \u0026amp;quot;disruptor-thread-\u0026amp;quot; + index.getAndIncrement()); }, ProducerType.MULTI, new BlockingWaitStrategy()); final Executor executor = new ThreadPoolExecutor(threadSize, threadSize, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026amp;lt;\u0026amp;gt;(), HmilyThreadFactory.create(\u0026amp;quot;hmily-log-disruptor\u0026amp;quot;, false), new ThreadPoolExecutor.AbortPolicy()); HmilyConsumerDataHandler[] consumers = new HmilyConsumerDataHandler[threadSize]; for (int i = 0; i \u0026amp;lt; threadSize; i++) { consumers[i] = new HmilyConsumerDataHandler(executor, coordinatorService); } disruptor.handleEventsWithWorkerPool(consumers); disruptor.setDefaultExceptionHandler(new IgnoreExceptionHandler()); disruptor.start(); } /** * publish disruptor event. * * @param tccTransaction {@linkplain …","date":1537833600,"description":"高性能一部分不是事务TCC框架","dir":"blog/hmily_introduction/","fuzzywordcount":2700,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"431e9fae892749e4773d003d30d3b18e","permalink":"/blog/hmily_introduction/","publishdate":"2018-09-25T00:00:00Z","readingtime":6,"relpermalink":"/blog/hmily_introduction/","summary":"Hmily框架特性[https://github.com/yu199195/hmily] 无缝集成Spring,Spring boot start。 无缝","tags":["hmily","TCC"],"title":"Hmily: 高性能异步分布式事务TCC框架","type":"blog","url":"/blog/hmily_introduction/","wordcount":2682},{"author":null,"categories":null,"content":" Committer Promotion After you have made a lot of contributions, the community will nominate. Become a committer you will have\n Permissions written by Soul repository\n Idea is used legally\n  Committer Responsibilities  Develop new features; Refactor codes; Review pull requests reliably and in time; Consider and accept feature requests; Answer questions; Update documentation and example; Improve processes and tools; Guide new contributors join community.  Committer Routine  A committer needs to review every day the Pull Request and issue list to be processed by the community, and assign a suitable committer, that is, Assignee.\n After a committer is assigned with an issue, the following work is required:\n   Estimate whether it is a long-term issue. If it is, please label it as pending; Add issue labels, such as bug, enhancement, discussion, etc; Add milestone.  Notice: Whether it is a community issue or not, there must be Assignee until the issue is completed.\n","date":-62135596800,"description":"Soul Committer's Guide","dir":"projects/soul/committer/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"f2c436ec0696f0dd9de31b8e0505ff3c","permalink":"/en/projects/soul/committer/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/committer/","summary":"Committer Promotion After you have made a lot of contributions, the community will nominate. Become a committer you will have\n Permissions written by Soul repository\n Idea is used legally\n  Committer Responsibilities  Develop new features; Refactor codes; Review pull requests reliably and in time; Consider and accept feature requests; Answer questions; Update documentation and example; Improve processes and tools; Guide new contributors join community.  Committer Routine  A committer needs to review every day the Pull Request and issue list to be processed by the community, and assign a suitable committer, that is, Assignee.","tags":null,"title":"","type":"projects","url":"/en/projects/soul/committer/","wordcount":149},{"author":null,"categories":null,"content":" As one of the developing directions of cloud native technology, Serverless architecture enables you to further improve resource utilization and focus on service development. With our workshop, you can experience new features such as quick creation of Serveless applications, automatic second-level 0-1-N scaling based on service requests, and quick troubleshooting via log viewer.\nWorkshop procedure Flow diagram Preview Preparation  Access to Serverless application service address Login with account and password Git clone this project to local  Step 1-1: Publish backend Java application  Select Create quickly Select Java Runtime Upload the code package balance-mng.jar The entry method can be automatically recognized Port: 8080 Copy and save the backend service address after creation View the number of computing instances of backend service: 0  Step 1-2: Publish frontend NodeJS application  Select create an application Select the buildpack NodeJS Upload the code package stock-mng.zip The entry method can be automatically recognized Select nodejs-0.0.1.1-pre at runtime Port: 3000 Set the environment variable BALANCEMNG_URL as the backend service address  Step 2: 0-1 cold boot capability  Access frontend service View the changes in the number of the computing instances of backend service  Step 3: Log and monitoring  View application service logs via Log Shell View usage amount via monitoring  Step 4: Configure time trigger  Configure timing trigger to call application at fixed time View the triggering results via operation records  Step 5: Create versions and control traffic  Clone the frontend application and create a new version Upload the code package stock-mng-v2.zip Configure router to visit V1 and V2 at 1:1 ratio View the effect in the browser  Step 6: Quick M-n capability for high-concurrency  Simulate high concurrency situtation via scripts and access the frontend application service Check how the Serverless application perform quick M-N computing instance changes  ","date":-62135596800,"description":"With this guide, you can experience new features such as quick creation of Serveless applications, automatic second-level 0-1-N scaling based on service requests, quick troubleshooting via log viewer, and application startup at fixed time.","dir":"guides/kc-serverless-demo/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"f355d1b598fed47b730bd74ad25f3683","permalink":"/en/guides/kc-serverless-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/guides/kc-serverless-demo/","summary":"As one of the developing directions of cloud native technology, Serverless architecture enables you to further improve resource utilization and focus on service development. With our workshop, you can experience new features such as quick creation of Serveless applications, automatic second-level 0-1-N scaling based on service requests, and quick troubleshooting via log viewer.\nWorkshop procedure Flow diagram Preview Preparation  Access to Serverless application service address Login with account and password Git clone this project to local  Step 1-1: Publish backend Java application  Select Create quickly Select Java Runtime Upload the code package balance-mng.","tags":null,"title":"Build applications on the cloud based on Serverless","type":"guides","url":"/en/guides/kc-serverless-demo/","wordcount":290},{"author":null,"categories":null,"content":" Procedure This guide introduces how to quickly build a microservice based on SOFAStack. It mainly includes the following steps.\n Publish service using SOFABoot and SOFARPC Call service using SOFABoot and SOFARPC View Tracer information reported by SOFATracer via ZipKin View Metrics information via SOFALookout  Architecture Tasks 1. Preparation Clone the project demo from GitHub to local\ngit clone https://github.com/sofastack-guides/kc-sofastack-demo.git  Import the project into IDEA or Eclipse. After import, the interface is as follows:\n balance-mng: account management system, providing deduction balance service stock-mng: account system, providing deduction inventory service  2. Introduce dependencies Add the following dependencies into the pom.xml files of balance-mng and stock-mng project modules.\n\u0026amp;lt;!--SOFARPC dependency--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;rpc-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--SOFATracer dependency--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;tracer-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--SOFARegistry dependency--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;registry-client-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--runtime dependency--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;runtime-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--SOFALookout dependency--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa.lookout\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;lookout-sofa-boot-starter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  For balance-mng project, you need to introduce the dependencies into the pom file of balance-mng-imp module.\nFor stock-mng project, you need to introduce the dependencies into the pom file of stock-mng module.\n3. Add configurations Copy the following configurations into the application.properties file of balance-mng and stock-mng project module.\n# 1、Add Service Registry address com.alipay.sofa.rpc.registry.address=sofa://118.31.43.62:9603 # 2、Add the zipkin address where tracer data is reported com.alipay.sofa.tracer.zipkin.base-url=http://139.224.123.199:9411 # 3、Add the server-side address where the metrics data is reported com.alipay.sofa.lookout.agent-host-address=139.224.123.35  For balance-mng project, you need to add configurations to the application.properties file in balance-mng-bootstrap module.\nFor stock-mng project, you need to add configurations to the application.properties file in stock-mng module.\n4. Modify unique id Since everyone shares a set of service discoveries, to differentiate the services published by different users, it is required to add a unique id to the service.\nKubeCon workshop will prepare a SOFAStack account for each user in the format ofuser0@sofastack.io to user99@sofastack.io. The first half of the account, namely …","date":-62135596800,"description":"This guide introduces how to quickly build a microservice based on SOFAStack. ","dir":"guides/sofastack-quick-start/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"78bfd4806a86dc15ac86eee16fb85c82","permalink":"/en/guides/sofastack-quick-start/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/guides/sofastack-quick-start/","summary":"Procedure This guide introduces how to quickly build a microservice based on SOFAStack. It mainly includes the following steps.\n Publish service using SOFABoot and SOFARPC Call service using SOFABoot and SOFARPC View Tracer information reported by SOFATracer via ZipKin View Metrics information via SOFALookout  Architecture Tasks 1. Preparation Clone the project demo from GitHub to local\ngit clone https://github.com/sofastack-guides/kc-sofastack-demo.git  Import the project into IDEA or Eclipse. After import, the interface is as follows:","tags":null,"title":"Build microservices with SOFAStack","type":"guides","url":"/en/guides/sofastack-quick-start/","wordcount":586},{"author":null,"categories":null,"content":" Description  This article introduces the flow of synchronizing to the gateway after the data operation of admin backend system.  Usage  User can arbitrary modify data in soul-admin backend and this will immediately synchronize to the jvm memory of the gateway.\n Synchronize the plugin data of soul,selector,rule data, metadata, signature data, etc.\n All the rules of plugin selectors are dynamically configured and take effect immediately without restarting the service.\n Data Flow Chart:   Feature  All the configurations of user can be dynamically updated, there is no need to restart the service for any modification.\n Local cache is used to provide efficient performance during high concurrency.\n  ","date":-62135596800,"description":"Configuration Flow Introduction","dir":"projects/soul/config/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"bfc2353dc4f9a2d42ba75eb2e8734faa","permalink":"/en/projects/soul/config/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/config/","summary":"Description  This article introduces the flow of synchronizing to the gateway after the data operation of admin backend system.  Usage  User can arbitrary modify data in soul-admin backend and this will immediately synchronize to the jvm memory of the gateway.\n Synchronize the plugin data of soul,selector,rule data, metadata, signature data, etc.\n All the rules of plugin selectors are dynamically configured and take effect immediately without restarting the service.","tags":null,"title":"Configuration Flow Introduction","type":"projects","url":"/en/projects/soul/config/","wordcount":103},{"author":null,"categories":null,"content":" Description  This article mainly explains three ways of database synchronization and their principles.  Preface Gateway is the entrance of request and it is a very important part in micro service architecture,therefore the importance of gateway high availability is self-evident.When we use gateway,we have to change configuration such as flow rule,route rule for satisfying business requirement.Therefore,the dynamic configuration of the gateway is an important factor to ensure the high availability of the gateway.Then,how does Soul support dynamic configuration?\nAnyone who has used Soul knows,Soul plugin are hot swap,and the selector,rule of all plugins are dynamic configured,they take effect immediately without restarting service.But during using Soul gateway,users also report many problems\n Rely on zookeeper,this troubles users who use etcd,consul,nacos registry Rely on redis,influxdb,I have not used the limiting plugin, monitoring plugin, why do I need these  Therefore,we have done a partial reconstruction of Soul,after two months of version iteration,we released version 2.0\n Data Synchronization removes the strong dependence on zookeeper,and we add http long polling and websocket Limiting plugin and monitoring plugin realize real dynamic configuration,we use admin backend for dynamic configuration instead of yml configuration before  1.Someone may ask me,why don\u0026amp;rsquo;t you use configuration center for synchronization? Answer:First of all,it will add extra costs,not only for maintenance,but also make Soul heavy;in addition,using configuration center,data format is uncontrollable and it is not convenient for soul-admin to do configuration management.\n2.Someone may also ask,dynamic configuration update?Every time I can get latest data from database or redis,why are you making it complicated? Answer:As a gateway,soul cached all the configuration in the Hashmap of JVM in order to provide higher response speed,we use local cache for every request,it is very fast.So this article can also be understood as three ways of memory synchronization in a distributed environment.\nPrinciple analysis This is a HD uncoded image,it shows the flow of Soul data synchronization,when Soul gateway starts,it will synchronize configuration data from the configuration service,and support push-pull mode to obtain configuration change information, and update the local cache.When administrator changes user,rule,plugin,flow configuration in the backend,modified information will synchronize to the Soul gateway through the push-pull mode,whether it is the push mode or the pull mode depends on the configuration.About the configuration synchronization module,it is actually a simplified configuration center. At version 1.x ,configuration service depends on zookeeper,management backend push the modified information to gateway.But version 2.x supports webosocket,http,zookeeper,it can specify the corresponding synchronization strategy through soul.sync.strategy and use http long …","date":-62135596800,"description":"Data Synchronization Design","dir":"projects/soul/data-sync/","fuzzywordcount":1400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"44541232a1c4007603f020e22e1b918f","permalink":"/en/projects/soul/data-sync/","publishdate":"0001-01-01T00:00:00Z","readingtime":7,"relpermalink":"/en/projects/soul/data-sync/","summary":"Description  This article mainly explains three ways of database synchronization and their principles.  Preface Gateway is the entrance of request and it is a very important part in micro service architecture,therefore the importance of gateway high availability is self-evident.When we use gateway,we have to change configuration such as flow rule,route rule for satisfying business requirement.Therefore,the dynamic configuration of the gateway is an important factor to ensure the high availability of the gateway.","tags":null,"title":"Data Synchronization Design","type":"projects","url":"/en/projects/soul/data-sync/","wordcount":1390},{"author":null,"categories":null,"content":" Plugin use database to store plugin,selector,rule configuration data and relationship.\n Database Table UML Diagram:\n   Detailed design:\n one plugin corresponds to multiple selectors,one selector corresponds to multiple rules.\n one selector corresponds to multiple match conditions,one rule corresponds to multiple match conditions.\n Each rule handles differently in corresponding plugin according to field handler,field handler is a json string.You can view detail during the use of admin.\n   ","date":-62135596800,"description":"Database Design","dir":"projects/soul/database-design/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"8f46db9ca33a0c500e83211cca567d46","permalink":"/en/projects/soul/database-design/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/database-design/","summary":"Plugin use database to store plugin,selector,rule configuration data and relationship.\n Database Table UML Diagram:\n   Detailed design:\n one plugin corresponds to multiple selectors,one selector corresponds to multiple rules.\n one selector corresponds to multiple match conditions,one rule corresponds to multiple match conditions.\n Each rule handles differently in corresponding plugin according to field handler,field handler is a json string.You can view detail during the use of admin.","tags":null,"title":"Database Design","type":"projects","url":"/en/projects/soul/database-design/","wordcount":64},{"author":null,"categories":null,"content":" Prerequisites  JDK 1.8+ Maven 3.2.x Git Zookeeper  Cloning the GitHub Repository and Quick Installation  \u0026amp;gt; git clone https://github.com/dromara/hmily.git \u0026amp;gt; cd hmily \u0026amp;gt; mvn -DskipTests clean install -U  Executing SQL(s) in Demo Module sql\nOpen with Your Favourite Editor (IDEA) and Locate on hmily-demo-dubbo Module Configuring（hmily-demo-dubbo-account module for instance）  Configure with your business database (account module for instance)  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026amp;lt;db_host_ip\u0026amp;gt;:\u0026amp;lt;db_host_port\u0026amp;gt;/hmily_account?useUnicode=true\u0026amp;amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   Modify hmily.yml, with mysql persistence backend  repository: database: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026amp;lt;db_host_ip\u0026amp;gt;:\u0026amp;lt;db_host_port\u0026amp;gt;/hmily?useUnicode=true\u0026amp;amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   Configure with your zookeeper address(es)(can run one locally)  \u0026amp;lt;dubbo:registry protocol=\u0026amp;quot;zookeeper\u0026amp;quot; address=\u0026amp;quot;localhost:2181\u0026amp;quot;/\u0026amp;gt;   run DubboHmilyAccountApplication.java  Run hmily-demo-dubbo-inventory(refer to simillar instructions above). Run hmily-demo-dubbo-order(refer to simillar instructions above). Access on http://127.0.0.1:8087/swagger-ui.html for more. ","date":-62135596800,"description":"Dubbo Quick Start","dir":"projects/hmily/quick-start-dubbo/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"559586953294644ad030b2d360281bf5","permalink":"/en/projects/hmily/quick-start-dubbo/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/quick-start-dubbo/","summary":"Prerequisites  JDK 1.8+ Maven 3.2.x Git Zookeeper  Cloning the GitHub Repository and Quick Installation  \u0026gt; git clone https://github.com/dromara/hmily.git \u0026gt; cd hmily \u0026gt; mvn -DskipTests clean install -U  Executing SQL(s) in Demo Module sql\nOpen with Your Favourite Editor (IDEA) and Locate on hmily-demo-dubbo Module Configuring（hmily-demo-dubbo-account module for instance）  Configure with your business database (account module for instance)  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026lt;db_host_ip\u0026gt;:\u0026lt;db_host_port\u0026gt;/hmily_account?useUnicode=true\u0026amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   Modify hmily.","tags":null,"title":"Dubbo Quick Start","type":"projects","url":"/en/projects/hmily/quick-start-dubbo/","wordcount":153},{"author":null,"categories":null,"content":" The Dubbo Interface Sectioon  Introduce the jar packages into your interface project.  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-annotation\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add the @Hmily annotation on the interface method in which you need to perform Hmily distributed transactions.\npublic interface HelloService { @Hmily void say(String hello); }  The project with Dubbo implementation  Step 1 ： Introduce the jar package of the hmily dependency\n Step 2 ： Add Hmily configuration\n Step 3 ： Add the specific annotation to the implementation method. you need to complete the development of confirm and cancel method, if in TCC mode.\n  Introduce The Maven dependency Spring-Namespace  for Alibaba-Dubbo Users  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  for Aapche-Dubbo Users\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   the configuration should be made in the xml file like below  \u0026amp;lt;!-- set up to enable the aspectj-autoproxy --\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id = \u0026amp;quot;hmilyTransactionAspect\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.aop.SpringHmilyTransactionAspect\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id = \u0026amp;quot;hmilyApplicationContextAware\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.HmilyApplicationContextAware\u0026amp;quot;/\u0026amp;gt;  Spring-Boot  for Alibaba-Dubbo Users  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   for Aapche-Dubbo Users  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Introduce the Hmily configuration  new a configuration file named hmily.yml under the resource directory of the current project\n the specific parameter configuration can refer to configuration detail,Local configuration mode, Zookeeper configuration mode, nacos configuration mode,apollo configuration mode\n  Add annotations on the implementation interface We have completed the integration described above,and the next we will talk about the specific implementation.\nTCC Mode  Add @HmilyTCC (confirmMethod = \u0026amp;quot;confirm\u0026amp;quot;, cancelMethod = \u0026amp;quot;cancel\u0026amp;quot;) annotation to the concrete implementation of the interface method identified by \u0026amp;lsquo;@Hmily\u0026amp;rsquo;.\n confirmMethod : the method name for confirm，The method parameter list and return type should be consistent with the identification method.\n cancelMethod : the method for cancel，The method parameter list and return type should be …","date":-62135596800,"description":"Dubbo user guide","dir":"projects/hmily/user-dubbo/","fuzzywordcount":700,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"c28d182a0aec22568b1dbf4e64014041","permalink":"/en/projects/hmily/user-dubbo/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/projects/hmily/user-dubbo/","summary":"The Dubbo Interface Sectioon  Introduce the jar packages into your interface project.  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hmily-annotation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;{last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Add the @Hmily annotation on the interface method in which you need to perform Hmily distributed transactions.\npublic interface HelloService { @Hmily void say(String hello); }  The project with Dubbo implementation  Step 1 ： Introduce the jar package of the hmily dependency\n Step 2 ： Add Hmily configuration","tags":null,"title":"Dubbo user guide","type":"projects","url":"/en/projects/hmily/user-dubbo/","wordcount":630},{"author":null,"categories":null,"content":" 环境准备  JDK 1.8+ Maven 3.2.x Git Zookeeper  代码拉取  \u0026amp;gt; git clone https://github.com/dromara/hmily.git \u0026amp;gt; cd hmily \u0026amp;gt; mvn -DskipTests clean install -U  执行demo 模块的sql语句。 sql语句\n使用你的工具 idea 打开项目，找到hmily-demo-dubbo项目。 修改项目配置（hmily-demo-dubbo-account为列子）  修改业务数据库(account项目为列子)  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://改成你的ip+端口/hmily_account?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: #改成你的用户名 password: #改成你的密码   修改 hmily.yml,这里使用mysql来存储  repository: database: driverClassName: com.mysql.jdbc.Driver url : jdbc:mysql://改成你的ip+端口/hmily?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: root #改成你的用户名 password: #改成你的密码   在spring-dubbo中修改你的zookeeper地址（可以在自己电脑本地启动一个zookeeper服务）  \u0026amp;lt;dubbo:registry protocol=\u0026amp;quot;zookeeper\u0026amp;quot; address=\u0026amp;quot;localhost:2181\u0026amp;quot;/\u0026amp;gt;   run DubboHmilyAccountApplication.java  启动hmily-demo-dubbo-inventory 参考上述。 启动hmily-demo-dubbo-order 参考上述。 访问：http://127.0.0.1:8087/swagger-ui.html。 ","date":-62135596800,"description":"Dubbo快速体验","dir":"projects/hmily/quick-start-dubbo/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"559586953294644ad030b2d360281bf5","permalink":"/projects/hmily/quick-start-dubbo/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/quick-start-dubbo/","summary":"环境准备 JDK 1.8+ Maven 3.2.x Git Zookeeper 代码拉取 \u0026gt; git clone https://github.com/dromara/hmily.git \u0026gt; cd hmily \u0026gt; mvn -DskipTests clean install -U 执行demo 模块的sql语句。 sql语句 使用你的工具 idea 打开项目，找到hmily-dem","tags":null,"title":"Dubbo快速体验","type":"projects","url":"/projects/hmily/quick-start-dubbo/","wordcount":519},{"author":null,"categories":null,"content":" Features  soul is an open source plugin framework, which is flexibility and extensibility since 2.2.0 version. With soul you can easily create application with your own gateway.\n System Requirment: JDK 1.8+, Mysql 5.0 +.\n  Invoke Soul-Admin  Download soul-admin.jar, then run it with arguments. ```yaml \u0026amp;gt; wget https://yu199195.github.io/jar/soul-admin.jar   java -jar soul-admin.jar \u0026amp;ndash;spring.datasource.url=\u0026amp;ldquo;jdbc:mysql://yoururl:3306/soul?useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;useSSL=false\u0026amp;rdquo;\n\u0026amp;ndash;spring.datasource.username=\u0026amp;lsquo;you username\u0026amp;rsquo; \u0026amp;ndash;spring.datasource.password=\u0026amp;lsquo;you password\u0026amp;rsquo;\n * Visit `http://localhost:9095/index.html ` default username：admin password: 123456. ## Build your own gateway（recommend） * First of all, create a new Spring Boot project, pls refer to soul-bootstrap, or visit Spring Initializr:[https://spring.io/quickstart] * Add these JAR into your local Maven repository: ```xml \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul gateway start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul data sync start use websocket--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-websocket\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add these config values into your application.yaml： ```yaml spring: main: allow-bean-definition-overriding: true  management: health: defaults: enabled: false soul : sync: websocket : urls: ws://localhost:9095/websocket //设置成你的soul-admin地址 swagger: enable: true ``` * Environment Setup has finished, kick off your project.\n","date":-62135596800,"description":"Environment Setup","dir":"projects/soul/soul-set-up/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"b1ffa97596d36706e58789420d76db64","permalink":"/en/projects/soul/soul-set-up/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/soul-set-up/","summary":"Features soul is an open source plugin framework, which is flexibility and extensibility since 2.2.0 version. With soul you can easily create application with your own gateway. System Requirment: JDK 1.8+, Mysql 5.0 +. Invoke Soul-Admin Download soul-admin.jar, then run it with arguments. ```yaml \u0026gt; wget https://yu199195.github.io/jar/soul-admin.jar java -jar soul-admin.jar \u0026ndash;spring.datasource.url=\u0026ldquo;jdbc:mysql://yoururl:3306/soul?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\u0026rdquo; \u0026ndash;spring.datasource.username=\u0026lsquo;you username\u0026rsquo; \u0026ndash;spring.datasource.password=\u0026lsquo;you password\u0026rsquo; * Visit `http://localhost:9095/index.html ` default username：a","tags":null,"title":"Environment Setup","type":"projects","url":"/en/projects/soul/soul-set-up/","wordcount":227},{"author":null,"categories":null,"content":" description  This doc demonstrates how to get correct IP address and host when soul serves behind nginx reverse proxy.\n After fetched real IP and host, you can match them with plugins and selectors.\n  default implementation  The embedded implementation in soul is :org.dromara.soul.web.forwarde.ForwardedRemoteAddressResolver。\n You need to config X-Forwarded-For in nginx first to get correct IP address and host.\n  implement through a plugin  Declare a new class named \u0026amp;ldquo;A\u0026amp;rdquo; and implements org.dromara.soul.plugin.api.RemoteAddressResolver.  public interface RemoteAddressResolver { /** * Resolve inet socket address. * * @param exchange the exchange * @return the inet socket address */ default InetSocketAddress resolve(ServerWebExchange exchange) { return exchange.getRequest().getRemoteAddress(); } }   Register defined class as a Spring Bean.  @Bean public SignService a() { return new A }  ","date":-62135596800,"description":"Fetching correct IP address and host","dir":"projects/soul/custom-parsing-ip-and-host/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"7c452779344f84418d0b5890de4a2be3","permalink":"/en/projects/soul/custom-parsing-ip-and-host/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/custom-parsing-ip-and-host/","summary":"description  This doc demonstrates how to get correct IP address and host when soul serves behind nginx reverse proxy.\n After fetched real IP and host, you can match them with plugins and selectors.\n  default implementation  The embedded implementation in soul is :org.dromara.soul.web.forwarde.ForwardedRemoteAddressResolver。\n You need to config X-Forwarded-For in nginx first to get correct IP address and host.\n  implement through a plugin  Declare a new class named \u0026ldquo;A\u0026rdquo; and implements org.","tags":null,"title":"Fetching correct IP address and host","type":"projects","url":"/en/projects/soul/custom-parsing-ip-and-host/","wordcount":118},{"author":null,"categories":null,"content":" Prerequisites  JDK 1.8+ Maven 3.2.x Git Zookeeper  Cloning the GitHub Repository and Quick Installation  \u0026amp;gt; git clone https://github.com/dromara/hmily.git \u0026amp;gt; cd hmily \u0026amp;gt; mvn -DskipTests clean install -U  Executing SQL(s) in Demo Module sql\nOpen with Your Favourite Editor (IDEA) and Locate on hmily-demo-grpc Module Configuring（hmily-demo-grpc-accoun module for instance）  Configure with your business database (account module for instance)  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026amp;lt;db_host_ip\u0026amp;gt;:\u0026amp;lt;db_host_port\u0026amp;gt;/hmily_account?useUnicode=true\u0026amp;amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   Modify hmily.yml, with mysql persistence backend  repository: database: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026amp;lt;db_host_ip\u0026amp;gt;:\u0026amp;lt;db_host_port\u0026amp;gt;/hmily?useUnicode=true\u0026amp;amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   run GrpcHmilyAccountApplication.java  Run hmily-demo-tars-springboot-inventory(refer to simillar instructions above). Run hmily-demo-tars-springboot-order(refer to simillar instructions above). Access on http://127.0.0.1:28087/swagger-ui.html for more. ","date":-62135596800,"description":"Grpc Quick Start","dir":"projects/hmily/quick-start-grpc/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"a7e77647d234ed18a0a917bc12e9b229","permalink":"/en/projects/hmily/quick-start-grpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/quick-start-grpc/","summary":"Prerequisites  JDK 1.8+ Maven 3.2.x Git Zookeeper  Cloning the GitHub Repository and Quick Installation  \u0026gt; git clone https://github.com/dromara/hmily.git \u0026gt; cd hmily \u0026gt; mvn -DskipTests clean install -U  Executing SQL(s) in Demo Module sql\nOpen with Your Favourite Editor (IDEA) and Locate on hmily-demo-grpc Module Configuring（hmily-demo-grpc-accoun module for instance）  Configure with your business database (account module for instance)  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026lt;db_host_ip\u0026gt;:\u0026lt;db_host_port\u0026gt;/hmily_account?useUnicode=true\u0026amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   Modify hmily.","tags":null,"title":"Grpc Quick Start","type":"projects","url":"/en/projects/hmily/quick-start-grpc/","wordcount":142},{"author":null,"categories":null,"content":" Grpc User Guide  Unary synchronous calls to GRPC are supported only at present.\n Introduce the jar packages\n Introduce the Hmily configuration\n Add @HmilyTCC or @HmilyTAC annotation on the concrete implementation method(Service provider).\n  Introduce The Maven dependency Spring-Namespace\n Introduce the hmily-grpc dependency   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-grpc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   make the configuration in the XML configuration file as below:\n\u0026amp;lt;!--Configure the base packages that the Hmily framework need to scan --\u0026amp;gt; \u0026amp;lt;context:component-scan base-package=\u0026amp;quot;org.dromara.hmily.*\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;!-- set up to enable the aspectj-autoproxy --\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;!-- Configure the bean parameters for Hmily startup --\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;hmilyApplicationContextAware\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.HmilyApplicationContextAware\u0026amp;quot;/\u0026amp;gt;  Spring-Boot\n Introduce the hmily-spring-boot-starter-grpc dependency\nxml \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-grpc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;    Introduce the Hmily configuration  new a configuration file named hmily.yml under the resource directory of the current project\n the specific parameter configuration can refer to configuration detail,Local configuration mode, Zookeeper configuration mode, nacos configuration mode,apollo configuration mode\n  Grpc Filter configuration  Add filter GrpcHmilyTransactionFilter to GRPC client. Add filter GrpcHmilyServerFilter to GRPC server.  Grpc client call  Use the GrpcHmilyClient to make the remote call instead of the original call.  AccountResponse response = GrpcHmilyClient.syncInvoke(accountServiceBlockingStub, \u0026amp;quot;payment\u0026amp;quot;, request, AccountResponse.class);  The input parameters are the called AbstratcSub, the method name, the specific parameter, and the return value type,respectively.\nTCC Mode  Add the @HmilyTCC(confirmMethod = \u0026amp;quot;confirm\u0026amp;quot;, cancelMethod = \u0026amp;quot;cancel\u0026amp;quot;) annotation on the concrete implementation of the transaction method on the server side.\n confirmMethod : the method name for confirm，The method parameter list and return type should be consistent with the identification method.\n cancelMethod : the method for cancel，The method parameter list and return type should be consistent with the identification method.\n The TCC mode should ensure the idempotence of the confirm and cancel methods,Users need to develop these two methods by themselves,The confirmation and rollback behavior of all transactions are completely up tp users.The Hmily framework is just responsible for making calls.\n  public class HelloServiceImpl implements HelloService { @HmilyTCC(confirmMethod = \u0026amp;quot;sayConfrim\u0026amp;quot;, cancelMethod = \u0026amp;quot;sayCancel\u0026amp;quot;) …","date":-62135596800,"description":"Grpc User Guide","dir":"projects/hmily/user-grpc/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"175826163ccd507408bea8b4c9a51017","permalink":"/en/projects/hmily/user-grpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/hmily/user-grpc/","summary":"Grpc User Guide  Unary synchronous calls to GRPC are supported only at present.\n Introduce the jar packages\n Introduce the Hmily configuration\n Add @HmilyTCC or @HmilyTAC annotation on the concrete implementation method(Service provider).\n  Introduce The Maven dependency Spring-Namespace\n Introduce the hmily-grpc dependency   \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hmily-grpc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;{last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   make the configuration in the XML configuration file as below:\n\u0026lt;!--Configure the base packages that the Hmily framework need to scan --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;org.","tags":null,"title":"Grpc User Guide","type":"projects","url":"/en/projects/hmily/user-grpc/","wordcount":367},{"author":null,"categories":null,"content":" 环境准备  JDK 1.8+ Maven 3.2.x Git Zookeeper  代码拉取  \u0026amp;gt; git clone https://github.com/dromara/hmily.git \u0026amp;gt; cd hmily \u0026amp;gt; mvn -DskipTests clean install -U  执行demo 模块的sql语句。 sql语句\n使用你的工具 idea 打开项目，找到hmily-demo-grpc项目。 修改项目配置（hmily-demo-grpc-account为列子）  修改业务数据库(account项目为列子)  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://改成你的ip+端口/hmily_account?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: #改成你的用户名 password: #改成你的密码   修改 hmily.yml,这里使用mysql来存储  repository: database: driverClassName: com.mysql.jdbc.Driver url : jdbc:mysql://改成你的ip+端口/hmily?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: root #改成你的用户名 password: #改成你的密码   run GrpcHmilyAccountApplication.java  启动hmily-demo-tars-springboot-inventory 参考上述。 启动hmily-demo-tars-springboot-order 参考上述。 访问：http://127.0.0.1:28087/swagger-ui.html。 ","date":-62135596800,"description":"Grpc快速体验","dir":"projects/hmily/quick-start-grpc/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"a7e77647d234ed18a0a917bc12e9b229","permalink":"/projects/hmily/quick-start-grpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/quick-start-grpc/","summary":"环境准备 JDK 1.8+ Maven 3.2.x Git Zookeeper 代码拉取 \u0026gt; git clone https://github.com/dromara/hmily.git \u0026gt; cd hmily \u0026gt; mvn -DskipTests clean install -U 执行demo 模块的sql语句。 sql语句 使用你的工具 idea 打开项目，找到hmily-dem","tags":null,"title":"Grpc快速体验","type":"projects","url":"/projects/hmily/quick-start-grpc/","wordcount":480},{"author":null,"categories":null,"content":" Grpc用户指南  目前只支持grpc的一元同步调用\n 引入jar包\n 引入hmily配置\n 在具体的实现方法上（服务提供端），加上@HmilyTCC or HmilyTAC 注解\n  引入依赖 Spring-Namespace\n 引入依赖\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-grpc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在xml中进行如下配置\n\u0026amp;lt;!--配置扫码hmily框架的包--\u0026amp;gt; \u0026amp;lt;context:component-scan base-package=\u0026amp;quot;org.dromara.hmily.*\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;!--设置开启aspectj-autoproxy--\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;!--配置Hmily启动的bean参数--\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;hmilyApplicationContextAware\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.HmilyApplicationContextAware\u0026amp;quot;/\u0026amp;gt;  Spring-Boot\n 引入依赖\nxml \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-grpc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;    引入Hmily配置  在项目的 resource 新建文件名为: hmily.ym 配置文件。\n 具体的参数配置可以参考配置详解,本地配置模式, zookeeper配置模式, nacos配置模式,apollo配置模式\n  Grpc拦截器配置  在 grpc客户端中添加拦截器 GrpcHmilyTransactionFilter。 在 grpc服务端中添加拦截器 GrpcHmilyServerFilter。  Grpc客户端调用  使用GrpcHmilyClient代替原来的调用方式来进行远程调用。  AccountResponse response = GrpcHmilyClient.syncInvoke(accountServiceBlockingStub, \u0026amp;quot;payment\u0026amp;quot;, request, AccountResponse.class);  入参分别为被调用的AbstratcSub,方法名,具体的参数以及返回值类型\nTCC模式  对服务端事务方法的具体实现,加上@HmilyTCC(confirmMethod = \u0026amp;quot;confirm\u0026amp;quot;, cancelMethod = \u0026amp;quot;cancel\u0026amp;quot;)\n confirmMethod : 确认方法名称，该方法参数列表与返回类型应与标识方法一致。\n cancelMethod : 回滚方法名称，该方法参数列表与返回类型应与标识方法一致。\n TCC模式应该保证 confirm 和 cancel 方法的幂等性，用户需要自行去开发这个2个方法，所有的事务的确认与回滚，完全由用户决定。Hmily框架只是负责来进行调用\n  public class HelloServiceImpl implements HelloService { @HmilyTCC(confirmMethod = \u0026amp;quot;sayConfrim\u0026amp;quot;, cancelMethod = \u0026amp;quot;sayCancel\u0026amp;quot;) public void say(String hello) { System.out.println(\u0026amp;quot;hello world\u0026amp;quot;); } public void sayConfrim(String hello) { System.out.println(\u0026amp;quot; confirm hello world\u0026amp;quot;); } public void sayCancel(String hello) { System.out.println(\u0026amp;quot; cancel hello world\u0026amp;quot;); } }  重要注意事项 异常  try, confirm, cancel 方法的所有异常不要自行catch 任何异常都应该抛出给 Hmily框架处理。  ","date":-62135596800,"description":"Grpc用户指南","dir":"projects/hmily/user-grpc/","fuzzywordcount":800,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"175826163ccd507408bea8b4c9a51017","permalink":"/projects/hmily/user-grpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/user-grpc/","summary":"Grpc用户指南 目前只支持grpc的一元同步调用 引入jar包 引入hmily配置 在具体的实现方法上（服务提供端），加上@HmilyTCC or HmilyTAC 注","tags":null,"title":"Grpc用户指南","type":"projects","url":"/projects/hmily/user-grpc/","wordcount":728},{"author":null,"categories":null,"content":" @Hmily /** * The annotation Hmily. * * @author xiaoyu */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface Hmily { }   This annotation is the interface identification of Hmily Distributed Transaction,it indicated that the interface participates in Hmily Distributed Transaction.  @HmilyTCC @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface HmilyTCC { /** * Confirm method string. * * @return the string */ String confirmMethod() default \u0026amp;quot;\u0026amp;quot;; /** * Cancel method string. * * @return the string */ String cancelMethod() default \u0026amp;quot;\u0026amp;quot;; /** * Pattern pattern enum. * * @return the pattern enum */ TransTypeEnum pattern() default TransTypeEnum.TCC; }   This annotation is the AOP point of TCC Mode of Hmily Distributed Transaction,it can add on your local concrete implementation method.\n confirmMethod : to annotate the identification method,it is the method name for confirm,the method parameter list and return type should be consistent with the identification method.\n cancelMethod : to annotate the identification method,it is the method name for rollback,the method parameter list and return type should be consistent with the identification method.\n  @HmilyTAC /** * The annotation HmilyTAC. * * @author xiaoyu */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface HmilyTAC { }   This annotation is the AOP point of TAC Mode of Hmily Distributed Transaction,it can add on your local concrete implementation method.  ","date":-62135596800,"description":"Hmily Annotation","dir":"projects/hmily/annotation/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"03ef60b752c3f007c96118cfd9cdc1b2","permalink":"/en/projects/hmily/annotation/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/annotation/","summary":"@Hmily /** * The annotation Hmily. * * @author xiaoyu */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface Hmily { }   This annotation is the interface identification of Hmily Distributed Transaction,it indicated that the interface participates in Hmily Distributed Transaction.  @HmilyTCC @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface HmilyTCC { /** * Confirm method string. * * @return the string */ String confirmMethod() default \u0026quot;\u0026quot;; /** * Cancel method string. * * @return the string */ String cancelMethod() default \u0026quot;\u0026quot;; /** * Pattern pattern enum.","tags":null,"title":"Hmily Annotation","type":"projects","url":"/en/projects/hmily/annotation/","wordcount":203},{"author":null,"categories":null,"content":" What\u0026amp;rsquo;s Hmily？ Hmily is a high-performance, zero penetration, financial-level distributed transactions solution. At present, it mainly provides support for flexible transactions, including TCC, TAC (in which, it will automatically generate rollback SQL) schemes, and XA and more schemes will be supported in the future.\nFeatures  High reliability : It supports abnormal transaction rollback and transaction overtime abnormal recovery to prevent transaction suspension in distributed scenarios.\n Ease of use : It provides zero penetration Spring-Boot and Spring-Namespace schemes to integrate with business systems quickly.\n High performance : Decentralized design, fully integrated with business systems, and naturally supports cluster deployment.\n Observability : Performance monitoring of multiple metrics will be collected by Metrics, performance metrics is able to display in admin management system.\n Multiple RPC Framework support : It supports well-known RPC frameworks such as Dubbo, SpringCloud, Motan, brpc, tars, etc.\n Multiple log store medium support : It supports many mediums as log store, such as mysql, oracle, mongodb, redis, zookeeper, etc.\n Complex business scene : It supports transaction around nested RPC calls.\n  Requirements  The JDK version must be JDK8 or later.\n In TCC mode, you must use a RPC framework, such as: Dubbo, SpringCloud, Motan\n In TAC mode, you must use relational databases, such as: mysql, oracle, sqlsever\n  TCC Mode When using the TCC mode, you should provide three methods: try, confirm, and cancel according to your business requirements, and the confirm and cancel methods should be implemented by yourselves, the framework is only responsible for calling them to achieve transaction consistency.\nTAC Mode When using the TAC mode, you must use a relational database for business operations, and the framework will automatically generate a rollback SQL. When the business is abnormal, the rollback SQL will be executed to achieve transaction consistency\nAbout Hmily is a flexible distributed transaction solution that provides TCC and TAC modes.\nIt can be easily integrated by business with zero intrusion and rapid integration.\nIn terms of performance, log storage is asynchronous (optional) and uses asynchronous execution, without sacrificing business methods.\nIt was previously developed by myself personally, and it is currently restarted at JD Digital Technique Group, and it will become JD Digital Technique Group\u0026amp;rsquo;s distributed transaction solution in the future.\nSupport  If you have any questions, please join the QQ group for discussion  WeChat public account   ","date":-62135596800,"description":"Hmily is Finance-level distributed transaction solutions, Supports multiple RPC frameworks, such as Dubbo, SpringCloud, Motan, GRPC, BRPC, Tars.","dir":"projects/hmily/overview/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"640bae80ac20018dd13658f8b7021ab1","permalink":"/en/projects/hmily/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/hmily/overview/","summary":"What\u0026rsquo;s Hmily？ Hmily is a high-performance, zero penetration, financial-level distributed transactions solution. At present, it mainly provides support for flexible transactions, including TCC, TAC (in which, it will automatically generate rollback SQL) schemes, and XA and more schemes will be supported in the future.\nFeatures  High reliability : It supports abnormal transaction rollback and transaction overtime abnormal recovery to prevent transaction suspension in distributed scenarios.\n Ease of use : It provides zero penetration Spring-Boot and Spring-Namespace schemes to integrate with business systems quickly.","tags":null,"title":"Hmily Introduction","type":"projects","url":"/en/projects/hmily/overview/","wordcount":381},{"author":null,"categories":null,"content":" Hmily Metrics At present,Prometheus is used to collect metrics in hmily\u0026amp;rsquo;s metrics module, and the pull mode is used to expose metrics information interface.\nThe metrics collected fall into two fundamental categories:\n JVM information to application: Memory, CPU, Thread Usage, etc.\n Transaction information: including the transactions total, the transaction latency, the transaction status, the transaction role.\n  Hmily Metrics in detail How to show  You can pull the metrics information from the metrics configuration of application via Grafana.  ","date":-62135596800,"description":"Hmily Metrics","dir":"projects/hmily/metrics/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"ac25a8a8d3dbee4303f272ae2fa5eeed","permalink":"/en/projects/hmily/metrics/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/metrics/","summary":"Hmily Metrics At present,Prometheus is used to collect metrics in hmily\u0026rsquo;s metrics module, and the pull mode is used to expose metrics information interface.\nThe metrics collected fall into two fundamental categories:\n JVM information to application: Memory, CPU, Thread Usage, etc.\n Transaction information: including the transactions total, the transaction latency, the transaction status, the transaction role.\n  Hmily Metrics in detail How to show  You can pull the metrics information from the metrics configuration of application via Grafana.","tags":null,"title":"Hmily Metrics","type":"projects","url":"/en/projects/hmily/metrics/","wordcount":77},{"author":null,"categories":null,"content":" Project members (the names not listed in order)    Name github Role Company     Xiao Yu yu199195 VP JD   Zhang Yong Lun tuohai666 committer JD   Zhao Jun cherrylzhao committer China Unicom   Chen Bin prFor committer A startup company   Jiang Xiao Feng SteNicholas committer Alibaba Cloud   Li Lang cysy-lli committer Ctrip   Tang Yi Dong tydhot committer perfma    ","date":-62135596800,"description":"Hmily Team","dir":"projects/hmily/team/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"7d27bab44ea88b422afcda3ff9b66b36","permalink":"/en/projects/hmily/team/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/team/","summary":" Project members (the names not listed in order)    Name github Role Company     Xiao Yu yu199195 VP JD   Zhang Yong Lun tuohai666 committer JD   Zhao Jun cherrylzhao committer China Unicom   Chen Bin prFor committer A startup company   Jiang Xiao Feng SteNicholas committer Alibaba Cloud   Li Lang cysy-lli committer Ctrip   Tang Yi Dong tydhot committer perfma    ","tags":null,"title":"Hmily Team","type":"projects","url":"/en/projects/hmily/team/","wordcount":54},{"author":null,"categories":null,"content":" Term  Initiator: The initiator of a global transaction, the first place where transactions need to be performed on distributed resources in a request link resource method. In the Hmily framework, it can be expressed as: a request first encounters @HmilyTCC or @HmilyTAC annotated method, the method which application belongs to is called the initiator.\n Participants: Distributed services or resources that need to participate in a distributed transaction scenario together with other services. In the Hmily framework, it\u0026amp;rsquo;s showed as an interface that appears as an RPC framework is annotated with @Hmily.\n Coordinator: The role used to coordinate distributed transactions is commit or rollback. It can be remote, local, centralized, or decentralized. The coordinator in the Hmily framework is a local decentralized role.\n TCC ：Abbreviation for the three stages of Try, Confirm, and Cancel.\n TAC ：Short for Try Auto Cancel. Hmily framework will automatically generate the reverse operation resource behavior after the resources are reserved in the Try stage.\n  ","date":-62135596800,"description":"Hmily Term","dir":"projects/hmily/term/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"8a22c263ed5f16b93fa1175383094d9d","permalink":"/en/projects/hmily/term/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/term/","summary":"Term  Initiator: The initiator of a global transaction, the first place where transactions need to be performed on distributed resources in a request link resource method. In the Hmily framework, it can be expressed as: a request first encounters @HmilyTCC or @HmilyTAC annotated method, the method which application belongs to is called the initiator.\n Participants: Distributed services or resources that need to participate in a distributed transaction scenario together with other services.","tags":null,"title":"Hmily Term","type":"projects","url":"/en/projects/hmily/term/","wordcount":158},{"author":null,"categories":null,"content":" Hmily Transaction Context @Data public class HmilyTransactionContext { /** * transId. */ private Long transId; /** * participant id. */ private Long participantId; /** * participant ref id. */ private Long participantRefId; /** * this hmily action. */ private int action; /** * Transaction Participant Role. */ private int role; /** * transType. */ private String transType; }  HmilyTransactionContext is the core class used by the Hmily distributed transaction framework to pass the transaction context when making RPC calls. it was stored in \u0026amp;lsquo;ThreadLocal\u0026amp;rsquo; by default and then do RPC parameter passing. You can also configure it to the scenarios that use thread context switching. the contextTransmittalMode = transmittable should be specified in the configuration at this point, then the Alibaba opensource library will be used.\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;transmittable-thread-local\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.11.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Passing Transaction Context with Dubbo The concrete implementation class was in the org.dromara.hmily.dubbo.filter.DubboHmilyTransactionFilter class.， Please do RPC parameter passing through the RpcContext.getContext().setAttachment(String key, String value).\nPassing Transaction Context with Motan The concrete implementation class was in the org.dromara.hmily.motan.filter.MotanHmilyTransactionFilter class.， Please do RPC parameter passing through the Request.setAttachment(String key, String value).\nPassing Transaction Context with Spring Cloud The concrete implementation class was in the org.dromara.hmily.springcloud.feign.HmilyFeignInterceptor class.， Please do RPC parameter passing through the RequestTemplate.header(String name, String... values).\n","date":-62135596800,"description":"Hmily Transaction Context","dir":"projects/hmily/context/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"29b5b0d8bf36fca4d23e1dadbc22824e","permalink":"/en/projects/hmily/context/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/context/","summary":"Hmily Transaction Context @Data public class HmilyTransactionContext { /** * transId. */ private Long transId; /** * participant id. */ private Long participantId; /** * participant ref id. */ private Long participantRefId; /** * this hmily action. */ private int action; /** * Transaction Participant Role. */ private int role; /** * transType. */ private String transType; }  HmilyTransactionContext is the core class used by the Hmily distributed transaction framework to pass the transaction context when making RPC calls.","tags":null,"title":"Hmily Transaction Context","type":"projects","url":"/en/projects/hmily/context/","wordcount":207},{"author":null,"categories":null,"content":" Hmily是什么？ Hmily是一款高性能，零侵入，金融级分布式事务解决方案，目前主要提供柔性事务的支持，包含 TCC, TAC(自动生成回滚SQL) 方案，未来还会支持 XA 等方案。\n功能  高可靠性 ：支持分布式场景下，事务异常回滚，超时异常恢复，防止事务悬挂。\n 易用性 ：提供零侵入性式的 Spring-Boot, Spring-Namespace 快速与业务系统集成。\n 高性能 ：去中心化设计，与业务系统完全融合，天然支持集群部署。\n 可观测性 ：Metrics多项指标性能监控，以及admin管理后台UI展示。\n 多种RPC ： 支持 Dubbo, SpringCloud,Motan, brpc, tars 等知名RPC框架。\n 日志存储 ： 支持 mysql, oracle, mongodb, redis, zookeeper 等方式。\n 复杂场景 ： 支持RPC嵌套调用事务。\n  必要前提  必须使用 JDK8+\n TCC模式下，用户必须要使用一款 RPC 框架, 比如 : Dubbo, SpringCloud,Motan\n TAC模式下，用户必须使用关系型数据库, 比如：mysql, oracle, sqlsever\n  TCC模式 当使用TCC模式的时候,用户根据自身业务需求提供 try, confirm, cancel 等三个方法， 并且 confirm, cancel 方法由自身完成实现，框架只是负责来调用，来达到事务的一致性。\nTAC模式 当用户使用TAC模式的时候，用户必须使用关系型数据库来进行业务操作，框架会自动生成回滚SQL, 当业务异常的时候，会执行回滚SQL来达到事务的一致性\n关于Hmily Hmily是柔性分布式事务解决方案，提供了TCC 与 TAC 模式。\n它以零侵入以及快速集成方式能够方便的被业务进行整合。\n在性能上，日志存储异步（可选）以及使用异步执行的方式，不损耗业务方法方法。\n之前是由我个人开发，目前在京东数科重启，未来会成为京东数科的分布式事务解决方案。\n技术支持  如有任何问题欢迎加入QQ群进行讨论  微信公众号   ","date":-62135596800,"description":"Hmily是一款高性能，零侵入，柔性分布式事务解决方案，目前主要提供柔性事务的支持，包含 TCC, TAC(自动生成回滚SQL) 方案，未来还会支持 XA 等方案。","dir":"projects/hmily/overview/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"640bae80ac20018dd13658f8b7021ab1","permalink":"/projects/hmily/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/overview/","summary":"Hmily是什么？ Hmily是一款高性能，零侵入，金融级分布式事务解决方案，目前主要提供柔性事务的支持，包含 TCC, TAC(自动生成回滚SQL) 方","tags":null,"title":"Hmily 介绍","type":"projects","url":"/projects/hmily/overview/","wordcount":645},{"author":null,"categories":null,"content":" Hmily-Admin startup tutorial (not completed）:  Admin is the background management system for viewing transaction logs in Hmily. It has many features, Such as viewing abnormal logs, modifying the number of retries and so on.\n First, make sure that your project is using Hmily and is running properly.\n Second, the JDK used by the user must be 1.8+. Git and Maven are installed locally, then execute the following command\n  Step 2：Modify index.html under the static folder of your project \u0026amp;lt;!--href use your ip and port--\u0026amp;gt; \u0026amp;lt;a id=\u0026amp;quot;serverIpAddress\u0026amp;quot; style=\u0026amp;quot;display: none\u0026amp;quot; href=\u0026amp;quot;http://192.168.1.132:8888/admin\u0026amp;quot;\u0026amp;gt;  Step 3: Run the main method in AdminApplication Step 4: Visit http://ip:port/tcc-admin/index.html in the browser, then enter the user name and password to login. If you have any questions, please join the QQ group: 162614487 for discussion ","date":-62135596800,"description":"Hmily-Admin","dir":"projects/hmily/admin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"7f471e3463f5cd785a11145907248bad","permalink":"/en/projects/hmily/admin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/admin/","summary":"Hmily-Admin startup tutorial (not completed）:  Admin is the background management system for viewing transaction logs in Hmily. It has many features, Such as viewing abnormal logs, modifying the number of retries and so on.\n First, make sure that your project is using Hmily and is running properly.\n Second, the JDK used by the user must be 1.8+. Git and Maven are installed locally, then execute the following command","tags":null,"title":"Hmily-Admin","type":"projects","url":"/en/projects/hmily/admin/","wordcount":126},{"author":null,"categories":null,"content":" Hmily-Admin 启动教程（未完成）:  admin 是Hmily中查看事务日志的后台管理系统。 可以查看异常的日志，修改重试次数等功能.\n 首先确保你的项目使用了Hmily并且正常运行.\n 首先用户使用的JDK必须是1.8+ 本地安装了git ,maven ，执行以下命令\n  步骤二：修改本项目static 文件夹下的 index.html \u0026amp;lt;!--href 修改成你的ip 端口--\u0026amp;gt; \u0026amp;lt;a id=\u0026amp;quot;serverIpAddress\u0026amp;quot; style=\u0026amp;quot;display: none\u0026amp;quot; href=\u0026amp;quot;http://192.168.1.132:8888/admin\u0026amp;quot;\u0026amp;gt;  步骤三: 运行 AdminApplication 中的main方法。 步骤四:在浏览器访问 http://ip:port/tcc-admin/index.html ,输入用户名，密码登录。 如有任何问题欢迎加入QQ群：162614487 进行讨论 ","date":-62135596800,"description":"Hmily-Admin","dir":"projects/hmily/admin/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"7f471e3463f5cd785a11145907248bad","permalink":"/projects/hmily/admin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/admin/","summary":"Hmily-Admin 启动教程（未完成）: admin 是Hmily中查看事务日志的后台管理系统。 可以查看异常的日志，修改重试次数等功能. 首先确保你的项目使用了Hmily并","tags":null,"title":"Hmily-Admin","type":"projects","url":"/projects/hmily/admin/","wordcount":217},{"author":null,"categories":null,"content":" Configuration Detail：  File Name: hmily.yml。\n Path： The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n  hmily: server: configMode: local appName: xiaoyu # The following configuration will be read when server.configMode equals local config: appName: xiaoyu serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:  Hmily.server Configuration    Name Type Default Required Description     configMode String local yes Configuration mode supports local,zookeeper,nacos, and apollo now. If configuration is local, it will read the configuration from yml file;If the configuration is other modes, it will get the configuration form configuration centre.   appName String null yes Application name. AppName will be overwritten if also configured in hmilyConfig.    Hmily.config Configuration  This is the core configuration of the whole framework     Name Type Default Required Description     appName String null yes It filled in your Microservices application\u0026amp;rsquo;s name generally, but don\u0026amp;rsquo;t repeat it   serializer String kryo no This is mode of serializing the specified transaction log，and currently supports filling in kryo, hessian, jdk, jdk, protostuff   contextTransmittalMode String threadLocal no This is the mode of transaction context transfer, and currently supports filling in threadLocal, transmittable (Cross-thread mode)   scheduledThreadMax int CPU * 2 no Maximum number of scheduled threads   scheduledRecoveryDelay int(unit:sec) 60 no Scheduling cycle of auto recovering transaction log   scheduledCleanDelay int(unit:sec) 60 no Scheduling cycle of cleaning transaction log   scheduledPhyDeletedDelay int(unit:sec) 60 no Scheduling cycle of deleting transaction log   scheduledInitDelay …","date":-62135596800,"description":"Hmily Configuration Detail","dir":"projects/hmily/config/","fuzzywordcount":1300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"4a00b98dda1404f77a49b1ec28ba179f","permalink":"/en/projects/hmily/config/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/en/projects/hmily/config/","summary":"Configuration Detail：  File Name: hmily.yml。\n Path： The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026gt; user.dir \u0026gt; resource\n  hmily: server: configMode: local appName: xiaoyu # The following configuration will be read when server.configMode equals local config: appName: xiaoyu serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.","tags":null,"title":"Hmily-Config","type":"projects","url":"/en/projects/hmily/config/","wordcount":1250},{"author":null,"categories":null,"content":" 配置详解：  文件名为 : hmily.yml。\n 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n  hmily: server: configMode: local appName: xiaoyu # 如果server.configMode eq local 的时候才会读取到这里的配置信息. config: appName: xiaoyu serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:  hmily.server配置    名称 类型 默认值 是否必填 说明     configMode String local 必填 配置模式，现在支持local,zookeeper,nacos,apollo,配置为local，则会读取yml文件里的配置，其他模式，则会读取配置中心的   appName String 无 必填 应用的名称，如果hmilyConfig中也配置了appName则会覆盖此配置    hmily.config配置  这是整个框架的核心配置     名称 类型 默认值 是否必填 说明     appName String 无 必填 一般填你微服务的应用名称，请不要重复   serializer String kryo 非必填 这是指定事务日志的序列化方式，目前支持填写 kryo, hessian, jdk, jdk, protostuff   contextTransmittalMode String threadLocal 非必填 这是事务上下文传递的模式，目前支持填写 threadLocal, transmittable (跨线程模式)   scheduledThreadMax int CPU * 2 非必填 调度线程数最大线程数量   scheduledRecoveryDelay int(单位:秒) 60 非必填 事务日志自动恢复调度周期   scheduledCleanDelay int(单位:秒) 60 非必填 事务日志清理调度周期   scheduledPhyDeletedDelay int(单位:秒) 60 非必填 事务日志物理删除调度周期   scheduledInitDelay int(单位:秒) 30 非必填 调度任务启动延迟时间   recoverDelayTime int(单位:秒) 60 非必填 事务日志恢复迟延时间   cleanDelayTime int(单位:秒) 60 非必填 事务日志清理迟延时间   limit int 100 非必填 获取事务日志行数大小   retryMax int 10 非必填 最大重试次数   bufferSize int 4096 * 2 * 2 非必填 disruptor的bufferSize大小   consumerThreads int CPU * 2 非必填 disruptor消费者线程数量   asyncRepository boolean true 非必填 是否异步存储事务日志，设置为false则为同步   autoSql boolean true 非必填 是否自动执行框架自动建库建表SQL语句（如果已经创建可以设置为false）   phyDeleted boolean true 非必填 在运行过程中，是否物理删除日志。设置为false，则只会更改日志状态   storeDays int(单位:天) 3 非必填 如果 phyDeleted 设置为false的时候，日志存储天数   repository String mysql 必填 这是指定事务日志的存储方式，目前支持填写 mysql, oracle, postgresql, sqlserver, mongo, redis, file    repository配置 repository是Hmily用来存储事务日志的配置，目前支持:database(mysql, oracle, postgresql, sqlserver), file(本地模式，测试，开发环境用), mongodb, zookeeper, redis。\n database配置(默认使用hikari连接池): …","date":-62135596800,"description":"Hmily配置详解","dir":"projects/hmily/config/","fuzzywordcount":2600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"4a00b98dda1404f77a49b1ec28ba179f","permalink":"/projects/hmily/config/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/projects/hmily/config/","summary":"配置详解： 文件名为 : hmily.yml。 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf","tags":null,"title":"Hmily-Config","type":"projects","url":"/projects/hmily/config/","wordcount":2582},{"author":null,"categories":null,"content":" Local Configuration  File Name : hmily.yml.\n Path： The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n The specific contents are as follows : Notice setting hmily.server.configMode = apollo\n The framework will pull the configuration according to your configured apollo.\n  hmily: server: configMode: apollo appName: # The following configuration will be read when server.configMode equals apollo. remote: apollo: configService: 127.0.0.1:8080 # apollo service address namespace: test # namespace appId: test # group secret: xxxx # the secret key env: dev # environment fileExtension: yml # format of configuration file of apollo (properties or yml）   You can add configurations in apollo, and the format is as follows(yml):  hmily: config: appName: xiaoyu serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:   Notice that the configurations of repository are extensions of SPI, you can select one from those modes, which don\u0026amp;rsquo;t have to be configured all.\n metrics is optional; If it is not configured，it means you don\u0026amp;rsquo;t enable metrics.\n  ","date":-62135596800,"description":"apollo configuration centre mode","dir":"projects/hmily/config-apollo/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"880948a69885ed46516aa4e1bf9ef40b","permalink":"/en/projects/hmily/config-apollo/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/hmily/config-apollo/","summary":"Local Configuration  File Name : hmily.yml.\n Path： The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026gt; user.dir \u0026gt; resource\n The specific contents are as follows : Notice setting hmily.server.configMode = apollo\n The framework will pull the configuration according to your configured apollo.\n  hmily: server: configMode: apollo appName: # The following configuration will be read when server.","tags":null,"title":"Hmily-Config-Apollo","type":"projects","url":"/en/projects/hmily/config-apollo/","wordcount":290},{"author":null,"categories":null,"content":" 本地配置  文件名为 : hmily.yml。\n 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n 具体的全内容如下 : 注意设置 hmily.server.configMode = apollo\n 框架的或首先根据你的 apollo 配置，然后从 apollo 获取配置\n  hmily: server: configMode: apollo appName: # 如果server.configMode eq local 的时候才会读取到这里的配置信息. remote: apollo: configService: 127.0.0.1:8080 # apollo服务地址 namespace: test # namespace appId: test # group secret: xxxx #秘钥 env: dev #环境 fileExtension: yml #apollo上配置文件的格式（properties或者yml）二选一   然后，你可以在apollo上添加配置，配置格式如果下（yml）：  hmily: config: appName: xiaoyu serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:   注意 repository的配置是SPI的扩展方式，几种方式由你去选择一种，并不需要全部配置。\n metrics 配置可有可无，如果不配置，则代表不开启metrics\n  ","date":-62135596800,"description":"apollo配置中心模式","dir":"projects/hmily/config-apollo/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"880948a69885ed46516aa4e1bf9ef40b","permalink":"/projects/hmily/config-apollo/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/config-apollo/","summary":"本地配置 文件名为 : hmily.yml。 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026gt;","tags":null,"title":"Hmily-Config-Apollo","type":"projects","url":"/projects/hmily/config-apollo/","wordcount":454},{"author":null,"categories":null,"content":" Local Configuration  File Name: hmily.yml。\n Path: The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n The specific contents are as follows : Notice setting hmily.server.configMode = consul\n The framework will pull the configuration according to your configured consul.\n  hmily: server: configMode: consul appName: xxxxx remote: consul: hostAndPort: 127.0.0.1:8500 # consul service address hostAndPorts: key: test # the key of consul blacklistTimeInMillis: 6000 fileExtension: yml # the format of the configuration of consul (properties or yml) passive: true # enable automatic update   Pay attention to consul service address configuration, if it is cluster, please configure hostAndPorts Nodes, configure hostAndPort to standalone mode. You have to set one of them, if the two is empty, it will adopt cluster configuration.\n And you need to add hmily configuration in the above configured key, the configuration is as follows:\n  hmily: config: appName: serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:   Notice that the configurations of repository are extensions of SPI, you can select one from those modes, which don\u0026amp;rsquo;t have to be configured all.\n metrics is optional; If it is not configured，it means you don\u0026amp;rsquo;t enable metrics.\n  ","date":-62135596800,"description":"Consul configuration centre mode","dir":"projects/hmily/config-consul/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"8482ea0a85b3bad66bd4e82413bb050f","permalink":"/en/projects/hmily/config-consul/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/hmily/config-consul/","summary":"Local Configuration  File Name: hmily.yml。\n Path: The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026gt; user.dir \u0026gt; resource\n The specific contents are as follows : Notice setting hmily.server.configMode = consul\n The framework will pull the configuration according to your configured consul.\n  hmily: server: configMode: consul appName: xxxxx remote: consul: hostAndPort: 127.","tags":null,"title":"Hmily-Config-Consul","type":"projects","url":"/en/projects/hmily/config-consul/","wordcount":319},{"author":null,"categories":null,"content":" 本地配置  文件名为 : hmily.yml。\n 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n 具体的全内容如下 : 注意设置 hmily.server.configMode = consul\n 框架的或首先根据你的 consul 配置，然后从 consul 获取配置\n  hmily: server: configMode: consul appName: xxxxx remote: consul: hostAndPort: 127.0.0.1:8500 # consul服务地址 hostAndPorts: key: test # consul 上的key blacklistTimeInMillis: 6000 fileExtension: yml # consul上配置文件的格式（properties或者yml）二选一 passive: true # 开启自动更新   注意consul服务地址配置，如果是集群，那么请配置hostAndPorts节点，单击配置hostAndPort，两者必须有一个不为空。两者都不为空，采用的是集群配置\n 然后，你需要在上述配置的key上写入hmily的配置，配置文件如下：\n  hmily: config: appName: serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:   注意 repository的配置是SPI的扩展方式，几种方式由你去选择一种，并不需要全部配置。\n metrics 配置可有可无，如果不配置，则代表不开启metrics\n  ","date":-62135596800,"description":"Consul配置中心模式","dir":"projects/hmily/config-consul/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"8482ea0a85b3bad66bd4e82413bb050f","permalink":"/projects/hmily/config-consul/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/config-consul/","summary":"本地配置 文件名为 : hmily.yml。 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026gt;","tags":null,"title":"Hmily-Config-Consul","type":"projects","url":"/projects/hmily/config-consul/","wordcount":504},{"author":null,"categories":null,"content":" Local Configuration  File Name: hmily.yml.\n Path: The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n The specific contents are as follows : Notice setting hmily.server.configMode = etcd\n The framework will pull the configuration according to your configured etcd.\n  hmily: server: configMode: etcd appName: xxxxx # The following configuration will be read when server.configMode equals etcd. remote: etcd: server: http://127.0.0.1:2379 # etcd service address key: test # key of etcd timeoutMs: 6000 fileExtension: yml # format of configuration of etcd (properties or yml) update : # Default is false，whether need to write local configuration file to zookeeper updateFileName: # when update is true, name of configuration file, which located in the yaml file of resource directory of the project位于项目的 resource文件夹下的yaml格式   And you need to add hmily configuration in the above configured key, the context is as follows:  hmily: config: appName: serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:   Notice that the configurations of repository are extensions of SPI, you can select one from those modes, which don\u0026amp;rsquo;t have to be configured all.\n metrics is optional; If it is not configured，it means you don\u0026amp;rsquo;t enable metrics.\n  ","date":-62135596800,"description":"etcd configuration centre mode","dir":"projects/hmily/config-etcd/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"0c5d688311c683877bb86f99c9caf1b2","permalink":"/en/projects/hmily/config-etcd/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/config-etcd/","summary":"Local Configuration File Name: hmily.yml. Path: The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026gt; user.dir \u0026gt; resource The specific contents are as follows : Notice setting hmily.server.configMode = etcd The framework will pull the configuration according to your configured etcd. hmily: server: configMode: etcd appName: xxxxx # The following","tags":null,"title":"Hmily-Config-Etcd","type":"projects","url":"/en/projects/hmily/config-etcd/","wordcount":373},{"author":null,"categories":null,"content":" 本地配置  文件名为 : hmily.yml。\n 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n 具体的全内容如下 : 注意设置 hmily.server.configMode = etcd\n 框架的或首先根据你的 etcd 配置，然后从 etcd 获取配置\n  hmily: server: configMode: etcd appName: xxxxx # 如果server.configMode eq local 的时候才会读取到这里的配置信息. remote: etcd: server: http://127.0.0.1:2379 # etcd服务地址 key: test # etcd 上的key， timeoutMs: 6000 fileExtension: yml #etcd上配置文件的格式（properties或者yml）二选一 update : #默认是false ，是否需要将本地的配置文件写到zookeeper updateFileName: #update属性为true时候 ，配置文件名称，位于项目的 resource文件夹下的yaml格式   然后，你需要在上述配置的key上写入hmily的配置，配置文件如下：  hmily: config: appName: serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:   注意 repository的配置是SPI的扩展方式，几种方式由你去选择一种，并不需要全部配置。\n metrics 配置可有可无，如果不配置，则代表不开启metrics\n  ","date":-62135596800,"description":"etcd配置中心模式","dir":"projects/hmily/config-etcd/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"0c5d688311c683877bb86f99c9caf1b2","permalink":"/projects/hmily/config-etcd/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/config-etcd/","summary":"本地配置 文件名为 : hmily.yml。 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026gt;","tags":null,"title":"Hmily-Config-Etcd","type":"projects","url":"/projects/hmily/config-etcd/","wordcount":530},{"author":null,"categories":null,"content":" Local Configuration  File Name: hmily.yml。\n Path： The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n The specific contents are as follows : Notice setting hmily.server.configMode = local\n All configurations of the framework base on your local configuration files.\n Notice that the configurations of repository are extensions of SPI, you can select one from those modes, which don\u0026amp;rsquo;t have to be configured all.\n metrics is optional; If it is not configured，it means you don\u0026amp;rsquo;t enable metrics.\n  hmily: server: configMode: local appName: # The following configuration will be read when server.configMode equals local config: appName: xiaoyu serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:  ","date":-62135596800,"description":"Local configuration mode","dir":"projects/hmily/config-local/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"d4ae9d925ca0faf01e01d542657f5ecc","permalink":"/en/projects/hmily/config-local/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/hmily/config-local/","summary":"Local Configuration  File Name: hmily.yml。\n Path： The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026gt; user.dir \u0026gt; resource\n The specific contents are as follows : Notice setting hmily.server.configMode = local\n All configurations of the framework base on your local configuration files.\n Notice that the configurations of repository are extensions of SPI, you can select one from those modes, which don\u0026rsquo;t have to be configured all.","tags":null,"title":"Hmily-Config-Local","type":"projects","url":"/en/projects/hmily/config-local/","wordcount":238},{"author":null,"categories":null,"content":" 本地配置  文件名为 : hmily.yml。\n 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n 具体的全内容如下 : 注意设置 hmily.server.configMode = local\n 框架的所有的配置就是基于你本地文件里面的配置\n 注意 repository的配置是SPI的扩展方式，几种方式由你去选择一种，并不需要全部配置。\n metrics 配置可有可无，如果不配置，则代表不开启metrics\n  hmily: server: configMode: local appName: # 如果server.configMode eq local 的时候才会读取到这里的配置信息. config: appName: xiaoyu serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:  ","date":-62135596800,"description":"本地配置模式","dir":"projects/hmily/config-local/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"d4ae9d925ca0faf01e01d542657f5ecc","permalink":"/projects/hmily/config-local/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/config-local/","summary":"本地配置 文件名为 : hmily.yml。 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026gt;","tags":null,"title":"Hmily-Config-Local","type":"projects","url":"/projects/hmily/config-local/","wordcount":351},{"author":null,"categories":null,"content":" Local Conguration  File Name: hmily.yml。\n Path： The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n The specific contents are as follows : Notice setting hmily.server.configMode = naocs\n The framework will pull the configuration from your configured nacos.\n  hmily: server: configMode: nacos appName: # The following configuration will be read when server.configMode equals nacos remote: nacos: server: 127.0.0.1:2181 # nacos service address dataId: test # dataId group: test # group timeoutMs: 6000 # Timeout(ms) fileExtension: yml # the format of the configuration of nacos (properties or yml)   And you can add configuration in nacos, the format is as follows(yml):  hmily: config: appName: xiaoyu serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:   Notice that the configurations of repository are extensions of SPI, you can select one from those modes, which don\u0026amp;rsquo;t have to be configured all.\n metrics is optional; If it is not configured，it means you don\u0026amp;rsquo;t enable metrics.\n  ","date":-62135596800,"description":"nacos configuration centre mode","dir":"projects/hmily/config-nacos/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"f246c71dfc1be4b6893491257f9c1a98","permalink":"/en/projects/hmily/config-nacos/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/hmily/config-nacos/","summary":"Local Conguration  File Name: hmily.yml。\n Path： The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026gt; user.dir \u0026gt; resource\n The specific contents are as follows : Notice setting hmily.server.configMode = naocs\n The framework will pull the configuration from your configured nacos.\n  hmily: server: configMode: nacos appName: # The following configuration will be read when server.","tags":null,"title":"Hmily-Config-Nacos","type":"projects","url":"/en/projects/hmily/config-nacos/","wordcount":283},{"author":null,"categories":null,"content":" 本地配置  文件名为 : hmily.yml。\n 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n 具体的全内容如下 : 注意设置 hmily.server.configMode = naocs\n 框架的或首先根据你的 nacos 配置，然后从 nacos 获取配置\n  hmily: server: configMode: nacos appName: # 如果server.configMode eq local 的时候才会读取到这里的配置信息. remote: nacos: server: 127.0.0.1:2181 # nacos服务地址 dataId: test # dataId group: test # group timeoutMs: 6000 #超时时间（ms） fileExtension: yml #nacos上配置文件的格式（properties或者yml）二选一   然后，你可以在nacos上添加配置，配置格式如果下（yml）：  hmily: config: appName: xiaoyu serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:   注意 repository的配置是SPI的扩展方式，几种方式由你去选择一种，并不需要全部配置。\n metrics 配置可有可无，如果不配置，则代表不开启metrics\n  ","date":-62135596800,"description":"nacos配置中心模式","dir":"projects/hmily/config-nacos/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"f246c71dfc1be4b6893491257f9c1a98","permalink":"/projects/hmily/config-nacos/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/config-nacos/","summary":"本地配置 文件名为 : hmily.yml。 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026gt;","tags":null,"title":"Hmily-Config-Nacos","type":"projects","url":"/projects/hmily/config-nacos/","wordcount":452},{"author":null,"categories":null,"content":" Local Configuration  File Name: hmily.yml。\n Path： The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n The specific contents are as follows : Notice setting hmily.server.configMode = zookeeper\n The framework will pull the configuration from your configured zookeeper.\n  hmily: server: configMode: zookeeper appName: # The following configuration will be read when server.configMode equals zookeeper remote: zookeeper: serverList: 127.0.0.1:2181 # your zookeeper service address, multiple addresses are separated by \u0026#39;,\u0026#39; fileExtension: yml # the format of the configuration of zookeeper(properties or yml) path: /hmily/xiaoyu # file path to zookeeper configuration update : # the deaflut is false, it means whether write the local configuration to zookeeper updateFileName: # it is the name of configuration when the property of \u0026#39;update\u0026#39; is true, and it is under the resource directory and the format is yaml   And you can add the needed configuration of hmily under the path, the configuration format is as follows(yml):  hmily: config: appName: serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:   Notice that the configurations of repository are extensions of SPI, you can select one from those modes, which don\u0026amp;rsquo;t have to be configured all.\n metrics is optional; If it is not configured，it means you don\u0026amp;rsquo;t enable metrics.\n  ","date":-62135596800,"description":"zookeeper configuration centre mode","dir":"projects/hmily/config-zookeeper/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"63f96bd367e08ba65bd1f8e32679af10","permalink":"/en/projects/hmily/config-zookeeper/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/hmily/config-zookeeper/","summary":"Local Configuration  File Name: hmily.yml。\n Path： The default path is the resource directory of the project, which can be specified by -Dhmily.conf, and you can also put the configuration in user.dir directory. Priority: -Dhmily.conf \u0026gt; user.dir \u0026gt; resource\n The specific contents are as follows : Notice setting hmily.server.configMode = zookeeper\n The framework will pull the configuration from your configured zookeeper.\n  hmily: server: configMode: zookeeper appName: # The following configuration will be read when server.","tags":null,"title":"Hmily-Config-Zookeeper","type":"projects","url":"/en/projects/hmily/config-zookeeper/","wordcount":333},{"author":null,"categories":null,"content":" 本地配置  文件名为 : hmily.yml。\n 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026amp;gt; user.dir \u0026amp;gt; resource\n 具体的全内容如下 : 注意设置 hmily.server.configMode = zookeeper\n 框架的或首先根据你的 zookeeper 配置，然后从 zookeeper 获取配置\n  hmily: server: configMode: zookeeper appName: # 如果server.configMode eq local 的时候才会读取到这里的配置信息. remote: zookeeper: serverList: 127.0.0.1:2181 #你的zookeeper服务地址，多个使用逗号分隔 fileExtension: yml #zookeeper上配置文件的格式（properties或者yml）二选一 path: /hmily/xiaoyu #zookeeper上配置文件的路径 update : #默认是false ，是否需要将本地的配置文件写到zookeeper updateFileName: #update属性为true时候 ，配置文件名称，位于项目的 resource文件夹下的yaml格式   然后，你可以在上述的 path 配置路径下，去写入hmily框架所需要的配置，配置格式如果下（yml）：  hmily: config: appName: serializer: kryo contextTransmittalMode: threadLocal scheduledThreadMax: 16 scheduledRecoveryDelay: 60 scheduledCleanDelay: 60 scheduledPhyDeletedDelay: 600 scheduledInitDelay: 30 recoverDelayTime: 60 cleanDelayTime: 180 limit: 200 retryMax: 10 bufferSize: 8192 consumerThreads: 16 asyncRepository: true autoSql: true phyDeleted: true storeDays: 3 repository: mysql repository: database: driverClassName: com.mysql.jdbc.Driver url : username: password: maxActive: 20 minIdle: 10 connectionTimeout: 30000 idleTimeout: 600000 maxLifetime: 1800000 file: path: prefix: /hmily mongo: databaseName: url: userName: password: zookeeper: host: localhost:2181 sessionTimeOut: 1000 rootPath: /hmily redis: cluster: false sentinel: false clusterUrl: sentinelUrl: masterName: hostName: port: password: maxTotal: 8 maxIdle: 8 minIdle: 2 maxWaitMillis: -1 minEvictableIdleTimeMillis: 1800000 softMinEvictableIdleTimeMillis: 1800000 numTestsPerEvictionRun: 3 testOnCreate: false testOnBorrow: false testOnReturn: false testWhileIdle: false timeBetweenEvictionRunsMillis: -1 blockWhenExhausted: true timeOut: 1000 metrics: metricsName: prometheus host: port: 9091 async: true threadCount : 16 jmxConfig:   注意 repository的配置是SPI的扩展方式，几种方式由你去选择一种，并不需要全部配置。\n metrics 配置可有可无，如果不配置，则代表不开启metrics\n  ","date":-62135596800,"description":"zookeeper配置中心模式","dir":"projects/hmily/config-zookeeper/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"63f96bd367e08ba65bd1f8e32679af10","permalink":"/projects/hmily/config-zookeeper/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/config-zookeeper/","summary":"本地配置 文件名为 : hmily.yml。 路径： 默认路径为项目的 resource目录下，也可以使用 -Dhmily.conf 指定，也可以把配置放在 user.dir 目录下。 优先级别 -Dhmily.conf \u0026gt;","tags":null,"title":"Hmily-Config-Zookeeper","type":"projects","url":"/projects/hmily/config-zookeeper/","wordcount":571},{"author":null,"categories":null,"content":" HmilyTransactionContext事务上下文 @Data public class HmilyTransactionContext { /** * transId. */ private Long transId; /** * participant id. */ private Long participantId; /** * participant ref id. */ private Long participantRefId; /** * this hmily action. */ private int action; /** * 事务参与的角色. */ private int role; /** * transType. */ private String transType; }  HmilyTransactionContext 是Hmily分布式事务框架进行RPC调用时用于传递事务上下文的核心类, 默认会将其存储在ThreadLocal中，然后进行RPC的参数传递，也可以配置使用线程上下文切换的的场景， 这个时候需要在配置中指定 contextTransmittalMode = transmittable,将会使用alibaba开源类库。\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;transmittable-thread-local\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.11.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Dubbo框架传递事务上下文 具体实现类在org.dromara.hmily.dubbo.filter.DubboHmilyTransactionFilter中， 通过 RpcContext.getContext().setAttachment(String key, String value) 进行RPC传参数。\nMotan框架传递事务上下文 具体实现类在org.dromara.hmily.motan.filter.MotanHmilyTransactionFilter中， 通过 Request.setAttachment(String key, String value) 进行RPC传参数。\nSpringCloud框架传递事务上下文 具体实现类在org.dromara.hmily.springcloud.feign.HmilyFeignInterceptor中， 通过 RequestTemplate.header(String name, String... values) 进行RPC传参数。\n","date":-62135596800,"description":"Hmily-Context事务上下文","dir":"projects/hmily/context/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"29b5b0d8bf36fca4d23e1dadbc22824e","permalink":"/projects/hmily/context/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/context/","summary":"HmilyTransactionContext事务上下文 @Data public class HmilyTransactionContext { /** * transId. */ private Long transId; /** * participant id. */ private Long participantId; /** * participant ref id. */ private Long participantRefId; /** * this hmily action. */ private int action; /** * 事务","tags":null,"title":"Hmily-Context","type":"projects","url":"/projects/hmily/context/","wordcount":516},{"author":null,"categories":null,"content":" Metrics 目前hmily的metrics模块，采用 prometheus来进行采集，使用pull模式对外暴露metrics信息接口。\n收集的metrics主要分为二个大类。\n 应用的JVM信息：内存，cpu，线程使用等等\n 事务信息：包括事务的总数，事务的迟延，事务的状态，事务的角色\n  指标详解 如何展示  用户可以使用 Grafana 从应用里面的metrics配置拉取的metrics信息  ","date":-62135596800,"description":"Metrics","dir":"projects/hmily/metrics/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"ac25a8a8d3dbee4303f272ae2fa5eeed","permalink":"/projects/hmily/metrics/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/metrics/","summary":"Metrics 目前hmily的metrics模块，采用 prometheus来进行采集，使用pull模式对外暴露metrics信息接口。 收集的metric","tags":null,"title":"Hmily-Metrics","type":"projects","url":"/projects/hmily/metrics/","wordcount":174},{"author":null,"categories":null,"content":" TAC The TAC mode is actually a variant of the TCC mode. Just as the name implies, the TAC mode is called automatic rollback. As compared with the TCC mode, the user doesn\u0026amp;rsquo;t have to concern about how to write the rollback method at all. and then it can reduces user development volume and is entirely transparent to users.\n TAC Mode is only suitable for Relational Database.\n TAC Mode will intercept the user\u0026amp;rsquo;s SQL statement to generate reverse rollback SQL, and the compatibility of SQL will also be a ordeal.\n  ","date":-62135596800,"description":"Hmily-TAC","dir":"projects/hmily/tac/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"67cddb93648c369d6a4e559fb337022c","permalink":"/en/projects/hmily/tac/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/tac/","summary":"TAC The TAC mode is actually a variant of the TCC mode. Just as the name implies, the TAC mode is called automatic rollback. As compared with the TCC mode, the user doesn\u0026rsquo;t have to concern about how to write the rollback method at all. and then it can reduces user development volume and is entirely transparent to users.\n TAC Mode is only suitable for Relational Database.\n TAC Mode will intercept the user\u0026rsquo;s SQL statement to generate reverse rollback SQL, and the compatibility of SQL will also be a ordeal.","tags":null,"title":"Hmily-TAC","type":"projects","url":"/en/projects/hmily/tac/","wordcount":90},{"author":null,"categories":null,"content":" TCC TCC模式是经典的柔性事务解决方案，需要使用者提供 try, confirm, cancel 三个方法， 真正的情况下会执行 try, confirm, 异常情况下会执行try, cancel。 confirm 方法并不是 必须的，完全依赖于用户的try 方法如何去写。 confirm, cancel 2个方法也需要用户去保证幂等性, 这会附加一定的工作量，由于在try方法完成之后，数据已经提交了，因此它并不保证数据的隔离性。但是这样，它的 性能相对较高，一个好的系统设计，是非常适用适用TCC模式。下面是Hmily 框架的 TCC 流程图  在极端异常情况下，比如服务突然宕机，超时异常等，依赖与自身的调用任务，来进行日志的事务恢复。\n 在confirm, cancel 阶段，如果有任何异常会继续执行相应的阶段，如果超过最大重试次数还未成功，将不再进行重试，需要人工介入。\n 在服务集群的情况下，confirm, cancel 2个方法用户去尽量保证其幂等性。\n  ","date":-62135596800,"description":"Hmily-TCC","dir":"projects/hmily/tcc/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"bc572e24c3dc77e36b27bc24b0ec01fb","permalink":"/projects/hmily/tcc/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/tcc/","summary":"TCC TCC模式是经典的柔性事务解决方案，需要使用者提供 try, confirm, cancel 三个方法， 真正的情况下会执行 try, confirm, 异常情况下会执行try, cancel。 confirm 方法并不是","tags":null,"title":"Hmily-TCC","type":"projects","url":"/projects/hmily/tcc/","wordcount":349},{"author":null,"categories":null,"content":" @Hmily /** * The annotation Hmily. * * @author xiaoyu */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface Hmily { }   该注解为hmily分布式事务接口标识，表示该接口参与hmily分布式事务  @HmilyTCC @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface HmilyTCC { /** * Confirm method string. * * @return the string */ String confirmMethod() default \u0026amp;quot;\u0026amp;quot;; /** * Cancel method string. * * @return the string */ String cancelMethod() default \u0026amp;quot;\u0026amp;quot;; /** * Pattern pattern enum. * * @return the pattern enum */ TransTypeEnum pattern() default TransTypeEnum.TCC; }   该注解为Hmily分布式事务TCC模式的切面（AOP point），可以标识在你本地具体实现方法上。\n confirmMethod : 注解标识方法的，确认方法名称，该方法参数列表与返回类型应与标识方法一致。\n cancelMethod : 注解标识方法的，回滚方法名称，该方法参数列表与返回类型应与标识方法一致。\n  @HmilyTAC /** * The annotation HmilyTAC. * * @author xiaoyu */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface HmilyTAC { }   该注解为Hmily分布式事务TAC模式的切面（AOP point），可以标识在你的本地方法具体实现上。  ","date":-62135596800,"description":"annotation","dir":"projects/hmily/annotation/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"03ef60b752c3f007c96118cfd9cdc1b2","permalink":"/projects/hmily/annotation/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/annotation/","summary":"@Hmily /** * The annotation Hmily. * * @author xiaoyu */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface Hmily { } 该注解为hmily分布式事务接口标识，表示该接口参与hmily分布式事务 @HmilyTCC @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface HmilyTCC { /** * Confirm method string. * * @return the","tags":null,"title":"Hmily-annotation","type":"projects","url":"/projects/hmily/annotation/","wordcount":301},{"author":null,"categories":null,"content":" Development Guidelines  Intentions Write codes with heart. Pursue clean, simplified and extremely elegant codes. Readable The code is unambiguous, and the intention of the code is revealed through reading rather than debugging. Tidy Agree with concepts in and . Consistent Be familiar with codes already had, to keep consistent with the style and use. Simplified Express meaning with the least code. Highly reusable, no duplicated codes or configurations. Delete codes out of use in time. Abstract The levels are clearly divided and the concepts are reasonably refined. Keep methods, classes, packages and modules at the same abstract level.  Contributor Covenant Submitting of Conduct  Make sure all the test cases are passed, Make sure ./mvnw clean install can be compiled and tested successfully. Make sure the test coverage rate is not lower than the master branch. Make sure to check codes with Checkstyle. codes that violate check rules should have special reasons. Find checkstyle template from https://github.com/dromara/hmily/blob/master/script/hmily_checkstyle.xml, please use checkstyle 8.8 to run the rules. Careful consideration for each pull request; Small and frequent pull request with complete unit function is welcomed. Conform to Contributor Covenant Code of Conduct below.  Contributor Covenant Code of Conduct  Use linux line separators. Keep indents (including blank lines) consistent with the previous one. Keep one blank line after class definition. No meaningless blank lines. Please extract private methods to instead of blank lines if too long method body or different logic code fragments. Use meaningful class, method and variable names, avoid to use abbreviate. Return values are named with result; Variables in the loop structure are named with each; Replace each with entry in map. Name property files with Spinal Case(a variant of Snake Case which uses hyphens - to separate words). Split codes that need to add notes with it into small methods, which are explained with method names. Have constants on the left and variable on the right in == and equals conditional expressions; Have variable on the left and constants on the right in greater than and less than conditional expressions. Beside using same names as input parameters and global fields in assign statement, avoid using this modifier. Design class as final class except abstract class for extend. Make nested loop structures a new method. The order of definition of member variables and the order of parameter passing are kept consistent in each class and method. Order of members definition and parameters should be consistent during classes and methods. Use guard clauses in priority. Minimize the access permission for classes and methods. Private method should be just next to the method in which it is used; writing private methods should be in the same as the appearance order of private methods. No null parameters or return values. Replace if else return and assign statement with ternary …","date":-62135596800,"description":"hmily development guidelines","dir":"projects/hmily/code-conduct/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"ff3eeb9c16eee349c0062fed70effaa9","permalink":"/en/projects/hmily/code-conduct/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/projects/hmily/code-conduct/","summary":"Development Guidelines  Intentions Write codes with heart. Pursue clean, simplified and extremely elegant codes. Readable The code is unambiguous, and the intention of the code is revealed through reading rather than debugging. Tidy Agree with concepts in and . Consistent Be familiar with codes already had, to keep consistent with the style and use. Simplified Express meaning with the least code. Highly reusable, no duplicated codes or configurations. Delete codes out of use in time.","tags":null,"title":"Hmily-code-conduct","type":"projects","url":"/en/projects/hmily/code-conduct/","wordcount":530},{"author":null,"categories":null,"content":" 开发理念  用心 保持责任心和敬畏心，以工匠精神持续雕琢。 可读 代码无歧义，通过阅读而非调试手段浮现代码意图。 整洁 认同《重构》和《代码整洁之道》的理念，追求整洁优雅代码。 一致 代码风格、命名以及使用方式保持完全一致。 精简 极简代码，以最少的代码表达最正确的意思。高度复用，无重复代码和配置。及时删除无用代码。 抽象 层次划分清晰，概念提炼合理。保持方法、类、包以及模块处于同一抽象层级。  代码提交行为规范  确保通过全部测试用例，确保执行./mvnw clean install可以编译和测试通过。 确保覆盖率不低于master分支。 确保使用Checkstyle检查代码，违反验证规则的需要有特殊理由。模板位置在https://github.com/dromara/hmily/blob/master/script/hmily_checkstyle.xml，请使用checkstyle 8.8运行规则。 应尽量将设计精细化拆分；做到小幅度修改，多次数提交，但应保证提交的完整性。 确保遵守编码规范。  编码规范  使用linux换行符。 缩进（包含空行）和上一行保持一致。 类声明后与下面的变量或方法之间需要空一行。 不应有无意义的空行。请提炼私有方法，代替方法体过长或代码段逻辑闭环而采用的空行间隔。 类、方法和变量的命名要做到顾名思义，避免使用缩写。 返回值变量使用result命名；循环中使用each命名循环变量；map中使用entry代替each。 配置文件使用Spinal Case命名（一种使用-分割单词的特殊Snake Case）。 需要注释解释的代码尽量提成小方法，用方法名称解释。 equals和==条件表达式中，常量在左，变量在右；大于小于等条件表达式中，变量在左，常量在右。 除了构造器入参与全局变量名称相同的赋值语句外，避免使用this修饰符。 除了用于继承的抽象类之外，尽量将类设计为final。 嵌套循环尽量提成方法。 成员变量定义顺序以及参数传递顺序在各个类和方法中保持一致。 优先使用卫语句。 类和方法的访问权限控制为最小。 方法所用到的私有方法应紧跟该方法，如果有多个私有方法，书写私有方法应与私有方法在原方法的出现顺序相同。 方法入参和返回值不允许为null。 优先使用三目运算符代替if else的返回和赋值语句。 优先考虑使用LinkedList，只有在需要通过下标获取集合中元素值时再使用ArrayList。 ArrayList，HashMap等可能产生扩容的集合类型必须指定集合初始大小，避免扩容。 日志与注释一律使用英文。 注释只能包含javadoc，todo和fixme。 公开的类和方法必须有javadoc，其他类和方法以及覆盖自父类的方法无需javadoc。  ","date":-62135596800,"description":"hmily编码指南","dir":"projects/hmily/code-conduct/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"ff3eeb9c16eee349c0062fed70effaa9","permalink":"/projects/hmily/code-conduct/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/hmily/code-conduct/","summary":"开发理念 用心 保持责任心和敬畏心，以工匠精神持续雕琢。 可读 代码无歧义，通过阅读而非调试手段浮现代码意图。 整洁 认同《重构》和《代码整洁之道》的理","tags":null,"title":"Hmily-code-conduct","type":"projects","url":"/projects/hmily/code-conduct/","wordcount":1105},{"author":null,"categories":null,"content":" Committer Promotion After you have made a lot of contributions, the community will invite you join Committers\nBecome a committer you will have\n Hmily repository write permissions\n Idea free license\n  Committer Responsibilities  Develop new features; Refactor codes; Review pull requests reliably and in time; Consider and accept feature requests; Answer questions; Update documentation and example; Improve processes and tools; Guide new contributors join community.  Committer Routine  Committer needs to check the list of pull requests and issues to be processed in the community on a daily basis and assign them to the appropriate committer, that is, assignee.\n After a committer is assigned with an issue, the following work is required:\n Estimate whether it is a long-term issue. If it is, please label it as pending. Add issue labels, such as bug, enhancement, discussion, etc. Add milestone.   Notice\nRegardless of whether it is a community issue, there must be an assignee until the issue is resolved.\n","date":-62135596800,"description":"Hmily committer guidelines","dir":"projects/hmily/committer/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"587564943f36f7111229c0388d4c5ba0","permalink":"/en/projects/hmily/committer/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/committer/","summary":"Committer Promotion After you have made a lot of contributions, the community will invite you join Committers\nBecome a committer you will have\n Hmily repository write permissions\n Idea free license\n  Committer Responsibilities  Develop new features; Refactor codes; Review pull requests reliably and in time; Consider and accept feature requests; Answer questions; Update documentation and example; Improve processes and tools; Guide new contributors join community.  Committer Routine  Committer needs to check the list of pull requests and issues to be processed in the community on a daily basis and assign them to the appropriate committer, that is, assignee.","tags":null,"title":"Hmily-committer","type":"projects","url":"/en/projects/hmily/committer/","wordcount":155},{"author":null,"categories":null,"content":" 提交者提名 当你做了很多贡献以后，社区会进行提名。 成为committer你会拥有\n hmily仓库写的权限\n idea 正版使用\n  提交者责任  开发新功能； 代码重构； 及时和可靠的评审Pull Request； 思考和接纳新特性请求； 解答问题； 维护文档和代码示例； 改进流程和工具； 引导新的参与者融入社区。  日常工作  committer需要每天查看社区待处理的Pull Request和issue列表，指定给合适的committer，即assignee。\n assignee在被分配issue后，需要进行如下判断：\n 判断是否是长期issue，如是，则标记为pending。 判断issue类型，如：bug，enhancement，discussion等。 判断Milestone，并标记。   注意\n无论是否是社区issue，都必须有assignee，直到issue完成。\n","date":-62135596800,"description":"Hmily-committer提交者指南","dir":"projects/hmily/committer/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"587564943f36f7111229c0388d4c5ba0","permalink":"/projects/hmily/committer/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/committer/","summary":"提交者提名 当你做了很多贡献以后，社区会进行提名。 成为committer你会拥有 hmily仓库写的权限 idea 正版使用 提交者责任 开发新功能； 代码重构","tags":null,"title":"Hmily-committer","type":"projects","url":"/projects/hmily/committer/","wordcount":358},{"author":null,"categories":null,"content":" You can report a bug, submit a new function enhancement suggestion, or submit a pull request directly.\nSubmit an Issue  Before submitting an issue, please go through a comprehensive search to make sure the problem cannot be solved just by searching. Check the Issue List to make sure the problem is not repeated. Create a new issue and choose the type of issue. Define the issue with a clear and descriptive title.. Fill in necessary information according to the template. Choose a label after issue created, for example: bug，enhancement，discussion. Please pay attention for your issue, you may need provide more information during discussion.  Developer Flow Fork Hmily repo  Fork a Hmily repo to your own repo to work, then setting upstream.  git remote add upstream https://github.com/dromara/hmily.git  Choose Issue  Please choose the issue to be edited. If it is a new issue discovered or a new function enhancement to offer, please create an issue and set the right label for it. After choosing the relevant issue, please reply with a deadline to indicate that you are working on it.  Create Branch  Switch to forked master branch, pull codes from upstream, then create a new branch.  git checkout master git pull upstream master git checkout -b issueNo  Notice ：We will merge PR using squash, commit log will be different form upstream if you use old branch\nCoding  Please obey the Code of Conduct during the process of development and finish the check before submitting the pull request. push code to your fork repo.  git add modified-file-names git commit -m \u0026#39;commit log\u0026#39; git push origin issueNo  Submit Pull Request  Send a pull request to the master branch. The mentor will do code review before discussing some details (including the design, the implementation and the performance) with you. The request will be merged into the branch of current development version after the edit is well enough. At last, congratulate to be an official contributor of Hmily  Delete Branch  You can delete the remote branch (origin/issueNo) and the local branch (issueNo) associated with the remote branch (origin/issueNo) after the mentor merged the pull request into the master branch of Hmily.  git checkout master git branch -d issueNo git push origin --delete issueNo  Notice Please note that in order to show your id in the contributor list, don’t forget the configurations below:\ngit config --global user.name \u0026amp;quot;username\u0026amp;quot; git config --global user.email \u0026amp;quot;username@mail.com\u0026amp;quot;  ","date":-62135596800,"description":"Hmily-contributor-guide","dir":"projects/hmily/contributor/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"e87656f289592fdd9b0d791c58640162","permalink":"/en/projects/hmily/contributor/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/hmily/contributor/","summary":"You can report a bug, submit a new function enhancement suggestion, or submit a pull request directly.\nSubmit an Issue  Before submitting an issue, please go through a comprehensive search to make sure the problem cannot be solved just by searching. Check the Issue List to make sure the problem is not repeated. Create a new issue and choose the type of issue. Define the issue with a clear and descriptive title.","tags":null,"title":"Hmily-contributor","type":"projects","url":"/en/projects/hmily/contributor/","wordcount":396},{"author":null,"categories":null,"content":" 您可以报告bug，提交一个新的功能增强建议或者直接对以上内容提交改进补丁。\n提交issue  在提交issue之前，请经过充分的搜索，确定该issue不是通过简单的检索即可以解决的问题。 查看issue列表，确定该issue不是一个重复的问题。 新建一个issue并选择您的issue类型。 使用一个清晰并有描述性的标题来定义issue。 根据模板填写必要信息。 在提交issue之后，对该issue分配合适的标签。如：bug，enhancement，discussion等。 请对自己提交的issue保持关注，在讨论中进一步提供必要信息。  开发流程 Fork分支到本地，设置upstream  从hmily的repo上fork一个分支到您自己的repo来开始工作，并设置upstream为hmily的repo。  git remote add upstream https://github.com/dromara/hmily.git  选择issue  请在选择您要修改的issue。如果是您新发现的问题或想提供issue中没有的功能增强，请先新建一个issue并设置正确的标签。 在选中相关的issue之后，请回复以表明您当前正在这个issue上工作。并在回复的时候为自己设置一个deadline，添加至回复内容中。  创建分支  切换到fork的master分支，拉取最新代码，创建本次的分支。  git checkout master git pull upstream master git checkout -b issueNo  注意 ：PR会按照squash的方式进行merge，如果不创建新分支，本地和远程的提交记录将不能保持同步。\n编码  请您在开发过程中遵循hmily的 开发规范。并在准备提交pull request之前完成相应的检查。 将修改的代码push到fork库的分支上。  git add 修改代码 git commit -m \u0026#39;commit log\u0026#39; git push origin issueNo  提交PR  发送一个pull request到hmily的master分支。 接着导师做CodeReview，然后他会与您讨论一些细节（包括设计，实现，性能等）。当导师对本次修改满意后，会将提交合并到当前开发版本的分支中。 最后，恭喜您已经成为了hmily的贡献者！  删除分支  在导师将pull request合并到hmily的master分支中之后，您就可以将远程的分支（origin/issueNo）及与远程分支（origin/issueNo）关联的本地分支（issueNo）删除。  git checkout master git branch -d issueNo git push origin --delete issueNo  注意 为了让您的id显示在contributor列表中，别忘了以下设置：\ngit config --global user.name \u0026amp;quot;username\u0026amp;quot; git config --global user.email \u0026amp;quot;username@mail.com\u0026amp;quot;  ","date":-62135596800,"description":"Hmily-contributor贡献者指南","dir":"projects/hmily/contributor/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"e87656f289592fdd9b0d791c58640162","permalink":"/projects/hmily/contributor/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/contributor/","summary":"您可以报告bug，提交一个新的功能增强建议或者直接对以上内容提交改进补丁。 提交issue 在提交issue之前，请经过充分的搜索，确定该iss","tags":null,"title":"Hmily-contributor","type":"projects","url":"/projects/hmily/contributor/","wordcount":963},{"author":null,"categories":null,"content":" TAC TAC模式其实是TCC模式的变种,顾名思义 TAC 模式被称为自动回滚,相比于 TCC模式，用户完全不用关心 回滚方法如何去写，减少了用户的开发量，对用户完全透明。\n TAC 模式只适合于关系型数据库。\n TAC 模式会拦截用户的SQL语句生成反向回滚SQL，SQL的兼容度也会是一大考验。\n  ","date":-62135596800,"description":"tac","dir":"projects/hmily/tac/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"67cddb93648c369d6a4e559fb337022c","permalink":"/projects/hmily/tac/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/tac/","summary":"TAC TAC模式其实是TCC模式的变种,顾名思义 TAC 模式被称为自动回滚,相比于 TCC模式，用户完全不用关心 回滚方法如何去写，减少了用户的开发量，对","tags":null,"title":"Hmily-tac","type":"projects","url":"/projects/hmily/tac/","wordcount":130},{"author":null,"categories":null,"content":" TCC The TCC Mode is a classic flexible transaction solution that needs the users to provided try, confirm, cancel methods. The try, confirm methods will be invoked under normal circumstances,and the try, cancel methods will be invoked as an exception occurs. the confirm method is not required,it entirely depends on the users how to implement the try method. the both confirm and cancel method also need the users to guarantee the idempotency, but it will bring addtional workload to the users. Because after the try method finished, the data had been committed. But with this,the performances will be even better. A good system design is very applicable to the TCC Mode. This is the flow diagram of TCC in Hmily framework as below:  In extreme cases, such as sudden service crash, timeout exceptions, and much more, the transaction recovery of the log depends on its own calling task.\n At the both confirm and cancel stage,if there are any exception occur, the corresponding stage will continue to be executed. If the maximum number of retries is exceeded, the transaction has not succeeded, It will not retry any more, then manual intervention is required at this time.\n In the case of a service cluster, the users need to do the best to ensure the idempotence of these two methods confirm, cancel.\n  ","date":-62135596800,"description":"tcc","dir":"projects/hmily/tcc/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"bc572e24c3dc77e36b27bc24b0ec01fb","permalink":"/en/projects/hmily/tcc/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/hmily/tcc/","summary":"TCC The TCC Mode is a classic flexible transaction solution that needs the users to provided try, confirm, cancel methods. The try, confirm methods will be invoked under normal circumstances,and the try, cancel methods will be invoked as an exception occurs. the confirm method is not required,it entirely depends on the users how to implement the try method. the both confirm and cancel method also need the users to guarantee the idempotency, but it will bring addtional workload to the users.","tags":null,"title":"Hmily-tcc","type":"projects","url":"/en/projects/hmily/tcc/","wordcount":219},{"author":null,"categories":null,"content":" Features  This chapter is a guide about integrating Http service with soul gateway.\n soul gateway uses divide plugin handling http request, pls enable it in soul-admin backgroud.\n Pls start soul-admin successfully beofore integrating , and Environement Setup is Ok.\n  Configure soul gateway as Http proxy.  Add these dependencies in gateway\u0026amp;rsquo;s pom.xml： ```xml  org.dromara soul-spring-boot-starter-plugin-divide ${last.version}    org.dromara soul-spring-boot-starter-plugin-httpclient ${last.version} \n * pls restart the gateway. ## Http request via soul gateway（springMVC user） * pls make sure divide plugin has enabled in `soul-admin` background. ##### add Soul-Client methods（available for SpringMVC,SpringBoot user） * SpringBoot user * Add these dependencies in your local maven repository `pom.xml`: ```xml \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add these config values in your yaml file ：\nsoul: http: adminUrl: http://localhost:9095 port: the port exposed by your application server contextPath: /http appName: http full: false # adminUrl: \u0026#39;ip + port\u0026#39; of your soul-admin project, pls note \u0026#39;http://\u0026#39; is necessary. # port: your project port number # contextPath: your project\u0026#39;s route prefix through soul gateway, such as /order ，/product etc，gateway will route based on it. # appName：your project name,the default value is`spring.application.name`. # full: set true means providing proxy for your entire service, or only a few controller.   SpringMVC user Add these dependencies in your local maven repository pom.xml: xml \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \n  Inject these properties into your Spring beans XML file:\n\u0026amp;lt;bean id =\u0026amp;quot;springMvcClientBeanPostProcessor\u0026amp;quot; class =\u0026amp;quot;org.dromara.soul.client.springmvc.init.SpringMvcClientBeanPostProcessor\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;constructor-arg ref=\u0026amp;quot;soulSpringMvcConfig\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;soulSpringMvcConfig\u0026amp;quot; class=\u0026amp;quot;org.dromara.soul.client.springmvc.config.SoulSpringMvcConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;adminUrl\u0026amp;quot; value=\u0026amp;quot;http://localhost:9095\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;port\u0026amp;quot; value=\u0026amp;quot;your port\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;contextPath\u0026amp;quot; value=\u0026amp;quot;/your contextPath\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;appName\u0026amp;quot; value=\u0026amp;quot;your application name\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;full\u0026amp;quot; value=\u0026amp;quot;false\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;   Add this annotation @SoulSpringMvcClient in your controller interface.\n you can apply the annotation to class-level in a controller.the name of the path variable is prefix and \u0026amp;lsquo;/**\u0026amp;rsquo; will apply proxy for entire interfaces.\n example: （1）：both /test/payment and /test/findByUserId will …","date":-62135596800,"description":"Integrate Http with soul gateway","dir":"projects/soul/http-proxy/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"d146a71ca0bc7f135c805b6f867eec06","permalink":"/en/projects/soul/http-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/projects/soul/http-proxy/","summary":"Features  This chapter is a guide about integrating Http service with soul gateway.\n soul gateway uses divide plugin handling http request, pls enable it in soul-admin backgroud.\n Pls start soul-admin successfully beofore integrating , and Environement Setup is Ok.\n  Configure soul gateway as Http proxy.  Add these dependencies in gateway\u0026rsquo;s pom.xml： ```xml  org.dromara soul-spring-boot-starter-plugin-divide ${last.version}    org.dromara soul-spring-boot-starter-plugin-httpclient ${last.version}","tags":null,"title":"Integrate Http with soul gateway","type":"projects","url":"/en/projects/soul/http-proxy/","wordcount":599},{"author":null,"categories":null,"content":" Features  This chapter is a guide about integrating dubbo service with soul gateway.\n Support alibaba dubbo（\u0026amp;lt; 2.7.x）and apache dubbo (\u0026amp;gt;=2.7.x).\n Pls start soul-admin successfully beofore integrating , and Environement Setup is Ok.\n  Configure soul gateway as dubbo proxy  Add these dependencies in gateway\u0026amp;rsquo;s pom.xml：\n alibaba dubbo user, configure the dubbo version and registry center with yours.    \u0026amp;lt;!--soul alibaba dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-alibaba-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul alibaba dubbo plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.6.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   apache dubbo user, configure the dubbo version and registry center with yours.   \u0026amp;lt;!--soul apache dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul apache dubbo plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo Nacos registry dependency start --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo-registry-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.nacos\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;nacos-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.1.4\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo Nacos registry dependency end--\u0026amp;gt; \u0026amp;lt;!-- Dubbo zookeeper registry dependency start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; …","date":-62135596800,"description":"Integrate dubbo with soul gateway","dir":"projects/soul/dubbo-proxy/","fuzzywordcount":1100,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"c3a28f2bf5654b9ce4f342e6319bb18b","permalink":"/en/projects/soul/dubbo-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/en/projects/soul/dubbo-proxy/","summary":"Features  This chapter is a guide about integrating dubbo service with soul gateway.\n Support alibaba dubbo（\u0026lt; 2.7.x）and apache dubbo (\u0026gt;=2.7.x).\n Pls start soul-admin successfully beofore integrating , and Environement Setup is Ok.\n  Configure soul gateway as dubbo proxy  Add these dependencies in gateway\u0026rsquo;s pom.xml：\n alibaba dubbo user, configure the dubbo version and registry center with yours.    \u0026lt;!--soul alibaba dubbo plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"Integrate dubbo with soul gateway","type":"projects","url":"/en/projects/soul/dubbo-proxy/","wordcount":1094},{"author":null,"categories":null,"content":" Description  This article mainly explains the concept,design of metadata and how to connect in the soul gateway.  Technical solutions  Add a new table in the database,and data can synchronize to the JVM memory of gateway according to the data synchronization scheme.\n Table Structure:\nCREATE TABLE IF NOT EXISTS `meta_data` ( `id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;id\u0026#39;, `app_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;application name\u0026#39;, `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;path,not repeatable\u0026#39;, `path_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;path description\u0026#39;, `rpc_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;rpc type `service_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;service name\u0026#39;, `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;method name\u0026#39;, `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;multiple parameter types, split by comma\u0026#39;, `rpc_ext` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;rpc extension information,json format\u0026#39;, `date_created` datetime(0) NOT NULL COMMENT \u0026#39;create date\u0026#39;, `date_updated` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT \u0026#39;update date\u0026#39;, `enabled` tinyint(4) NOT NULL DEFAULT 0 COMMENT \u0026#39;enable status\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;   Metadata design as below,the most important is using it in dubbo\u0026amp;rsquo;s generalization call.\n Pay attention to the field path,we will match specific data according to your field path during requesting gateway,and then carry out the follow-up process.\n Pay attention to the field rpc_ext,if it is a dubbo service interface and service interface has group and version field,this field exists.\n dubbo field structure as below,then we store json format string.\n  public static class RpcExt { private String group; private String version; private String loadbalance; private Integer retries; private Integer timeout; }   MetaData Storage  a dubbo interface corresponds to a meta data.\n spring cloud protocol,only store one record, path: /contextPath/**.\n http service,no data.\n  ","date":-62135596800,"description":"MetaData Concept Design","dir":"projects/soul/meta-data/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"e4bb78fd2e6f8f05d641328371f2cd29","permalink":"/en/projects/soul/meta-data/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/soul/meta-data/","summary":"Description  This article mainly explains the concept,design of metadata and how to connect in the soul gateway.  Technical solutions  Add a new table in the database,and data can synchronize to the JVM memory of gateway according to the data synchronization scheme.\n Table Structure:\nCREATE TABLE IF NOT EXISTS `meta_data` ( `id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'id', `app_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'application name', `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'path,not repeatable', `path_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'path description', `rpc_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'rpc type `service_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'service name', `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'method name', `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'multiple parameter types, split by comma', `rpc_ext` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'rpc extension information,json format', `date_created` datetime(0) NOT NULL COMMENT 'create date', `date_updated` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT 'update date', `enabled` tinyint(4) NOT NULL DEFAULT 0 COMMENT 'enable status', PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;   Metadata design as below,the most important is using it in dubbo\u0026rsquo;s generalization call.","tags":null,"title":"MetaData Concept Design","type":"projects","url":"/en/projects/soul/meta-data/","wordcount":323},{"author":null,"categories":null,"content":" Prerequisites  JDK 1.8+ Maven 3.2.x Git Zookeeper  Cloning the GitHub Repository and Quick Installation  \u0026amp;gt; git clone https://github.com/dromara/hmily.git \u0026amp;gt; cd hmily \u0026amp;gt; mvn -DskipTests clean install -U  Executing SQL(s) in Demo Module sql\nOpen with Your Favourite Editor (IDEA), Locate on hmily-demo-dubbo Module and Run Build with Maven Configuring（hmily-demo-motan-account module for instance）  Configure with your business database in application.yml(account module for instance)  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026amp;lt;db_host_ip\u0026amp;gt;:\u0026amp;lt;db_host_port\u0026amp;gt;/hmily_account?useUnicode=true\u0026amp;amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   Configure with motan registration address(es) in application.yml (can run with local zookeeper instance(s))  hmily: motan: # for registration address registry: address: 127.0.0.1:2181 # replace with registration address   Modify hmily.yml, with mysql persistence backend  repository: database: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026amp;lt;db_host_ip\u0026amp;gt;:\u0026amp;lt;db_host_port\u0026amp;gt;/hmily?useUnicode=true\u0026amp;amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   run MotanHmilyAccountApplication.java  Run hmily-demo-motan-inventory(refer to simillar instructions above). Run hmily-demo-motan-order(refer to simillar instructions above). Access on http://127.0.0.1:8088/swagger-ui.html for more. ","date":-62135596800,"description":"motan Quick Start","dir":"projects/hmily/quick-start-motan/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"9b85af7dc7e27a5b9be975c9649be34b","permalink":"/en/projects/hmily/quick-start-motan/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/quick-start-motan/","summary":"Prerequisites  JDK 1.8+ Maven 3.2.x Git Zookeeper  Cloning the GitHub Repository and Quick Installation  \u0026gt; git clone https://github.com/dromara/hmily.git \u0026gt; cd hmily \u0026gt; mvn -DskipTests clean install -U  Executing SQL(s) in Demo Module sql\nOpen with Your Favourite Editor (IDEA), Locate on hmily-demo-dubbo Module and Run Build with Maven Configuring（hmily-demo-motan-account module for instance）  Configure with your business database in application.yml(account module for instance)  spring: datasource: driver-class-name: com.","tags":null,"title":"Motan Quick Start","type":"projects","url":"/en/projects/hmily/quick-start-motan/","wordcount":174},{"author":null,"categories":null,"content":" Motan Interface Sectioon  Introduce the jar packages into your interface project.  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-annotation\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add the @Hmily annotation on the interface method in which you need to perform Hmily distributed transactions.  public interface HelloService { @Hmily void say(String hello); }  The project with Motan implementation  Step 1 ： Introduce the jar package of the hmily dependency\n Step 2 ： Add Hmily configuration\n Step 3 ： Add the specific annotation to the implementation method. you need to complete the development of confirm and cancel method, if in TCC mode.\n  Introduce The Maven dependency Spring-Namespace  Introduce the hmily-motan dependency  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-motan\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   make the configuration in the XML configuration file as below:  \u0026amp;lt;!-- set up to enable the aspectj-autoproxy --\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id = \u0026amp;quot;hmilyTransactionAspect\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.aop.SpringHmilyTransactionAspect\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id = \u0026amp;quot;hmilyApplicationContextAware\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.HmilyApplicationContextAware\u0026amp;quot;/\u0026amp;gt;  Spring-Boot-starter  Introduce the hmily-spring-boot-starter-motan dependency  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-motan\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Introduce the Hmily configuration  new a configuration file named hmily.yml under the resource directory of the current project\n the specific parameter configuration can refer to configuration detail,Local configuration mode, Zookeeper configuration mode, nacos configuration mode,apollo configuration mode\n  Add annotations on the implementation interface We have completed the integration and configuration described above, and the next let\u0026amp;rsquo;s explain how to use it in detail.\nTCC Mode  Add @HmilyTCC (confirmMethod = \u0026amp;quot;confirm\u0026amp;quot;, cancelMethod = \u0026amp;quot;cancel\u0026amp;quot;) annotation to the concrete implementation of the interface method identified by \u0026amp;lsquo;@Hmily\u0026amp;rsquo;.\n confirmMethod : the method name for confirm，The method parameter list and return type should be consistent with the identification method.\n cancelMethod : the method for cancel，The method parameter list and return type should be consistent with the identification method.\n The TCC mode should ensure the idempotence of the confirm and cancel methods,Users need to develop these two methods by themselves,The confirmation and rollback behavior of all transactions are completely up tp users.The Hmily framework is just responsible for making calls.\n  public class HelloServiceImpl implements …","date":-62135596800,"description":"Hmily-Motan Distributed Transaction User Guide","dir":"projects/hmily/user-motan/","fuzzywordcount":700,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"f3e4806ac6fc849d233a1b110e3e424b","permalink":"/en/projects/hmily/user-motan/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/projects/hmily/user-motan/","summary":"Motan Interface Sectioon  Introduce the jar packages into your interface project.  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hmily-annotation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;{last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Add the @Hmily annotation on the interface method in which you need to perform Hmily distributed transactions.  public interface HelloService { @Hmily void say(String hello); }  The project with Motan implementation  Step 1 ： Introduce the jar package of the hmily dependency\n Step 2 ： Add Hmily configuration","tags":null,"title":"Motan User Guide","type":"projects","url":"/en/projects/hmily/user-motan/","wordcount":620},{"author":null,"categories":null,"content":" 环境准备  JDK 1.8+ Maven 3.2.x Git Zookeeper  代码拉取  \u0026amp;gt; git clone https://github.com/dromara/hmily.git \u0026amp;gt; cd hmily \u0026amp;gt; mvn -DskipTests clean install -U  执行demo 模块的sql语句。 sql语句\n使用你的工具 idea 打开项目，找到hmily-demo-motan项目，进行maven构建 修改项目配置（hmily-demo-motan-account为列子）  application.yml 下修改业务数据库(account项目为列子)  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://改成你的ip+端口/hmily_account?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: #改成你的用户名 password: #改成你的密码   application.yml 下修改motan的注册中心地址(可以在自己电脑本地启动一个zookeeper服务)  hmily : motan : #注册中心配置 registry : address : 127.0.0.1:2181 #注册中心地址   修改 hmily.yml,这里使用mysql来存储  repository: database: driverClassName: com.mysql.jdbc.Driver url : jdbc:mysql://改成你的ip+端口/hmily?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: root #改成你的用户名 password: #改成你的密码   run MotanHmilyAccountApplication.java  启动hmily-demo-motan-inventory 参考上述。 启动hmily-demo-motan-order 参考上述。 访问：http://127.0.0.1:8088/swagger-ui.html。 ","date":-62135596800,"description":"motan快速体验","dir":"projects/hmily/quick-start-motan/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"9b85af7dc7e27a5b9be975c9649be34b","permalink":"/projects/hmily/quick-start-motan/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/quick-start-motan/","summary":"环境准备 JDK 1.8+ Maven 3.2.x Git Zookeeper 代码拉取 \u0026gt; git clone https://github.com/dromara/hmily.git \u0026gt; cd hmily \u0026gt; mvn -DskipTests clean install -U 执行demo 模块的sql语句。 sql语句 使用你的工具 idea 打开项目，找到hmily-dem","tags":null,"title":"Motan快速体验","type":"projects","url":"/projects/hmily/quick-start-motan/","wordcount":537},{"author":null,"categories":null,"content":" Motan接口部分  在你的接口项目中引入jar包。  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-annotation\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在需要进行Hmily分布式事务的接口方法上加上 @Hmily 标识。  public interface HelloService { @Hmily void say(String hello); }  Motan实现项目  步骤一 ： 引入依赖hmily的jar包\n 步骤二 ： 新增Hmily配置\n 步骤三 ： 在实现方法上添加注解。TCC模式，则需要完成 confirm，cancel方法的开发\n  引入依赖 Spring-Namespace  引入依赖  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-motan\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在xml中进行如下配置  \u0026amp;lt;!--设置开启aspectj-autoproxy--\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id = \u0026amp;quot;hmilyTransactionAspect\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.aop.SpringHmilyTransactionAspect\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id = \u0026amp;quot;hmilyApplicationContextAware\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.HmilyApplicationContextAware\u0026amp;quot;/\u0026amp;gt;  Spring-Boot-starter  用户引入  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-motan\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  引入 hmily配置  在项目的 resource 添加文件名为:hmily.yml配置文件\n 具体的参数配置可以参考配置详解,本地配置模式, zookeeper配置模式, nacos配置模式,apollo配置模式\n  实现接口上添加注解 在上述中，我们已经完成了集成与配置，现在我们来详解说一下如何进行使用。\nTCC模式  在添加@Hmily 标识的接口方法的具体实现上 加上@HmilyTCC(confirmMethod = \u0026amp;quot;confirm\u0026amp;quot;, cancelMethod = \u0026amp;quot;cancel\u0026amp;quot;)\n confirmMethod : 确认方法名称，该方法参数列表与返回类型应与标识方法一致。\n cancelMethod : 回滚方法名称，该方法参数列表与返回类型应与标识方法一致。\n TCC模式应该保证 confirm 和 cancel 方法的幂等性，用户需要自行去开发这个2个方法，所有的事务的确认与回滚，完全由用户决定。Hmily框架只是负责来进行调用\n  public class HelloServiceImpl implements HelloService { @HmilyTCC(confirmMethod = \u0026amp;quot;sayConfrim\u0026amp;quot;, cancelMethod = \u0026amp;quot;sayCancel\u0026amp;quot;) public void say(String hello) { System.out.println(\u0026amp;quot;hello world\u0026amp;quot;); } public void sayConfrim(String hello) { System.out.println(\u0026amp;quot; confirm hello world\u0026amp;quot;); } public void sayCancel(String hello) { System.out.println(\u0026amp;quot; cancel hello world\u0026amp;quot;); } }  motan注解用户 对于使用 @MotanReferer 注解来注入motan服务的用户，请注意：你可以需要做如下配置:\nspring-namespace 用户 在你的xml配置中，需要将 org.dromara.hmily.spring.annotation.RefererAnnotationBeanPostProcessor 注入成spring的bean\n\u0026amp;lt;bean id = \u0026amp;quot;refererAnnotationBeanPostProcessor\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.annotation.RefererAnnotationBeanPostProcessor\u0026amp;quot;/\u0026amp;gt;  spring-boot用户 需要在yml文件里面开启注解支持：\nhmily.support.rpc.annotation = true  或者在项目中显示注入：\n@Bean public BeanPostProcessor refererAnnotationBeanPostProcessor() { return new RefererAnnotationBeanPostProcessor(); }  TAC模式 (在开发，未发布)  对@Hmily 标识的接口方法的具体实现加上@HmilyTAC   重要注意事项 在调用任何RPC调用之前，当你需要聚合rpc调用成为一次分布式事务的时候，需要在聚合RPC调用的方法上，先行添加 @HmilyTCC 或者 @HmilyTAC 注解,表示开启全局事务。\n负载均衡  如果服务部署了几个节点， 负载均衡算法最好使用 hmily, 这样 try, confirm, cancel 调用会落在同一个节点 充分利用了缓存，提搞了效率。\n 支持一下几种 hmilyActiveWeight, hmilyConfigurableWeight, hmilyConsistent, hmilyLocalFirst, hmilyRandom, hmilyRoundRobin 几种方式均是继承Motan …","date":-62135596800,"description":"Hmily-Motan分布式事务用户指南","dir":"projects/hmily/user-motan/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"f3e4806ac6fc849d233a1b110e3e424b","permalink":"/projects/hmily/user-motan/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/hmily/user-motan/","summary":"Motan接口部分 在你的接口项目中引入jar包。 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hmily-annotation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;{last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在需要进行Hmily分布式事务的接口方法上加上 @Hmily 标识。 public interface HelloService { @Hmily void say(String hello); } Motan","tags":null,"title":"Motan用户指南","type":"projects","url":"/projects/hmily/user-motan/","wordcount":1045},{"author":null,"categories":null,"content":" myth 采用消息队列解决分布式事务的开源框架, 基于java语言来开发（JDK1.8），支持dubbo，springcloud,motan等rpc框架进行分布式事务。 Features  天然无缝集成 spring-boot-starter 。 RPC框架支持 : dubbo,motan,springcloud。 消息中间件支持 : jms(activimq),amqp(rabbitmq),kafka,roceketmq。 本地事务存储支持 : redis,mogondb,zookeeper,file,mysql。 事务日志序列化支持 ：java，hessian，kryo，protostuff。 采用Aspect AOP 切面思想与Spring无缝集成，天然支持集群,高可用,高并发。 配置简单，集成简单，源码简洁，稳定性高，已在生产环境使用。 内置经典的分布式事务场景demo工程，并有swagger-ui可视化界面可以快速体验。  源码解析  ## https://juejin.im/post/5a5c63986fb9a01cb64ec517   视频详解  ## 环境搭建以及运行 : http://www.iqiyi.com/w_19rw5zuigl.html ## 原理讲解（1）：http://www.iqiyi.com/w_19rw5ztpkh.html ## 原理讲解（2）：http://www.iqiyi.com/w_19rw5zslm1.html   Prerequisite  JDK 1.8+ Maven 3.2.x Git RPC framework dubbo or motan or springcloud。 Message Oriented Middleware  Support  ### 如有任何问题欢迎加入QQ群进行讨论   ### 微信公众号   ","date":-62135596800,"description":"Myth is based on a distributed transaction framework that is ultimately consistent with reliable messaging.","dir":"projects/myth/overview/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"cd23b3131fd6adec40b27a5ee9dc98e3","permalink":"/en/projects/myth/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/myth/overview/","summary":"myth 采用消息队列解决分布式事务的开源框架, 基于java语言来开发（JDK1.8），支持dubbo，springcloud,motan等rpc框","tags":null,"title":"Myth Introduction","type":"projects","url":"/en/projects/myth/overview/","wordcount":535},{"author":null,"categories":null,"content":" myth 采用消息队列解决分布式事务的开源框架, 基于java语言来开发（JDK1.8），支持dubbo，springcloud,motan等rpc框架进行分布式事务。 Features  天然无缝集成 spring-boot-starter 。 RPC框架支持 : dubbo,motan,springcloud。 消息中间件支持 : jms(activimq),amqp(rabbitmq),kafka,roceketmq。 本地事务存储支持 : redis,mogondb,zookeeper,file,mysql。 事务日志序列化支持 ：java，hessian，kryo，protostuff。 采用Aspect AOP 切面思想与Spring无缝集成，天然支持集群,高可用,高并发。 配置简单，集成简单，源码简洁，稳定性高，已在生产环境使用。 内置经典的分布式事务场景demo工程，并有swagger-ui可视化界面可以快速体验。  源码解析  ## https://juejin.im/post/5a5c63986fb9a01cb64ec517   视频详解  ## 环境搭建以及运行 : http://www.iqiyi.com/w_19rw5zuigl.html ## 原理讲解（1）：http://www.iqiyi.com/w_19rw5ztpkh.html ## 原理讲解（2）：http://www.iqiyi.com/w_19rw5zslm1.html   Prerequisite  JDK 1.8+ Maven 3.2.x Git RPC framework dubbo or motan or springcloud。 Message Oriented Middleware  Support  ### 如有任何问题欢迎加入QQ群进行讨论   ### 微信公众号   ","date":-62135596800,"description":"Myth是基于可靠消息最终一致性分布式事务框架，无缝支持dubbo，springcloud,motan等rpc框架的微服务","dir":"projects/myth/overview/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"cd23b3131fd6adec40b27a5ee9dc98e3","permalink":"/projects/myth/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/myth/overview/","summary":"myth 采用消息队列解决分布式事务的开源框架, 基于java语言来开发（JDK1.8），支持dubbo，springcloud,motan等rpc框","tags":null,"title":"Myth 介绍","type":"projects","url":"/projects/myth/overview/","wordcount":535},{"author":null,"categories":null,"content":" To run this demo, you should sign up an Ant Financial technology account. Please see Ant Finanical Official Site to see more details.\nDemo content Service Mesh applies the communication capabilities between services to the infrastructure, thus decoupling and lightweighting applications.\nHowever, Service Mesh itself is still complex. CloudMesh can easily implement Service Mesh technology by hosting Service Mesh on the cloud.\nWith our workshop, you can easily deploy applications developed in multiple programming languages ​​to CloudMesh, thereby experiencing the capabilities of Service Mesh. The capabilities include accessing services, monitoring traffic, experiencing service goverance, managing Sidecar, and gray release of new versions of services.\nThis demo focuses on the powerful traffic control capability of CloudMesh. In the process of gray release, you can precisely control the gray traffic ratio, and monitor the actual traffic trend in CloudMesh:\nThe general gray release function occupies twice capacity in the gray process.\nThe gray release function of CloudMesh does not need to occupy extra capacity in gray release process, and also allows pausing the release process to modify gray ratio multiple times.\nOperation guide For convenience, we have prepared a detailed operation guide for this demo.\nClick here to visit online version.\n","date":-62135596800,"description":"This guide introduces how to quickly deploy applications to CloudMesh, access services, monitor traffic, experience service governance, manage Sidecar, and perform gray release of new versions of services.","dir":"guides/kc-cloud-mesh-demo/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"e389a65e6736e909718275cd76505525","permalink":"/en/guides/kc-cloud-mesh-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/guides/kc-cloud-mesh-demo/","summary":"To run this demo, you should sign up an Ant Financial technology account. Please see Ant Finanical Official Site to see more details.\nDemo content Service Mesh applies the communication capabilities between services to the infrastructure, thus decoupling and lightweighting applications.\nHowever, Service Mesh itself is still complex. CloudMesh can easily implement Service Mesh technology by hosting Service Mesh on the cloud.\nWith our workshop, you can easily deploy applications developed in multiple programming languages ​​to CloudMesh, thereby experiencing the capabilities of Service Mesh.","tags":null,"title":"Put Service Mesh into practice with CloudMesh","type":"guides","url":"/en/guides/kc-cloud-mesh-demo/","wordcount":199},{"author":null,"categories":null,"content":" I have imported the jar package to my project, but found that my project cannot be started, what should I do if any error reported?  Answer : When you meet this kind of error, it requires you to locate the problem yourself, you can check the items as bellow:  check whether the framework configuration is carried out according to the document whether your project runtime environment is correct whether there is any dependency conflict problem   If your problem is still present after above check items, you can provide an issue on github of this project, our team will provide technique support as soon as possible.\nWhat if the microservice act as abnormal, but the transaction was not rolled back?  Answer : First of all, you can check the transaction log records. If the transaction log records exist, the rollback will be performed after the scheduled time you configured.  What should I do if I compile the source code and found that the get and set methods are missing?  Answer : The source code uses lombok, you may need to install the corresponding plug-in in your development tool. (No set get method does not affect the operation).  ","date":-62135596800,"description":"Frequently asked questions","dir":"projects/hmily/faq/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"291ff6f051e39fe15edb0c08d62aef12","permalink":"/en/projects/hmily/faq/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/faq/","summary":"I have imported the jar package to my project, but found that my project cannot be started, what should I do if any error reported?  Answer : When you meet this kind of error, it requires you to locate the problem yourself, you can check the items as bellow:  check whether the framework configuration is carried out according to the document whether your project runtime environment is correct whether there is any dependency conflict problem   If your problem is still present after above check items, you can provide an issue on github of this project, our team will provide technique support as soon as possible.","tags":null,"title":"Questions","type":"projects","url":"/en/projects/hmily/faq/","wordcount":196},{"author":null,"categories":null,"content":" Raincat 强一致性分布式事务，是基于二阶段提交+本地事务补偿机制来实现。原理介绍\n基于java语言来开发（JDK1.8），支持dubbo,motan,springcloud进行分布式事务。\n因为文件名太长，大家在拉取代码的时候执git命令：git config \u0026amp;ndash;global core.longpaths true # Features\n 框架特性\n 无缝集成spring 或 spring boot。\n 支持dubbo,motan,springcloud,等rpc框架进行分布式事务。\n 事务发起者，参与者与协调者底层基于netty长连接通信,稳定高效。\n 协调者采用eureka做注册中心，支持集群模式。\n 采用Aspect AOP 切面思想与Spring无缝集成。\n 配置简单，集成简单，源码简洁，稳定性高，已在生产环境使用。\n 内置经典的分布式事务场景demo工程，并有swagger-ui可视化界面可以快速体验。\n  事务角色\n 事务发起者（可理解为消费者 如：dubbo的消费者,springcloud的调用方）,发起分布式事务\n 事务参与者（可理解为提供者 如：dubbo的提供者,springcloud的rest服务提供者),参与事务发起者的事务\n 事务协调者（tx-manager），协调分布式事务的提交，回滚等。\n  技术方案\n 协调者（tx-manager）采用eureka作为注册中心，集群配置，达到服务的高可用，采用redis集群来分布式存储事务数据, springboot 提供rest服务，采用netty与参与者，发起者进行长连接通信。\n 发起者与协调者，采用Aspect AOP 切面思想，SPI，多线程，异步回调，线程池，netty通信等技术。\n  SPI扩展\n 本地事务恢复，支持redis，mogondb，zookeeper，file，mysql等关系型数据库 本地事务序列化保存，支持java，hessian，kryo，protostuff netty通信序列化方式，支持 hessian，kryo，protostuff   Prerequisite  JDK 1.8+ Maven 3.2.x Git RPC framework dubbo or motan or springcloud。  架构设计  架构设计图 ：  流程图 ：\n  视频源码分析 ### 环境搭建\n### 启动过程\n### 事务提交\n### 回滚恢复\n### 管理后台\nSupport  如有任何问题欢迎加入QQ群进行讨论  微信公众号   # Contribution\n","date":-62135596800,"description":"Raincat is a strongly consistent distributed transaction framework based on a two-phase commit + local transaction compensation mechanism.","dir":"projects/raincat/overview/","fuzzywordcount":900,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"8581aebda8993d467b1930e09efa7aea","permalink":"/en/projects/raincat/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/raincat/overview/","summary":"Raincat 强一致性分布式事务，是基于二阶段提交+本地事务补偿机制来实现。原理介绍 基于java语言来开发（JDK1.8），支持dubbo,motan,","tags":null,"title":"Raincat Introduction","type":"projects","url":"/en/projects/raincat/overview/","wordcount":860},{"author":null,"categories":null,"content":" Raincat 强一致性分布式事务，是基于二阶段提交+本地事务补偿机制来实现。原理介绍\n基于java语言来开发（JDK1.8），支持dubbo,motan,springcloud进行分布式事务。\n因为文件名太长，大家在拉取代码的时候执git命令：git config \u0026amp;ndash;global core.longpaths true Features  框架特性\n 无缝集成spring 或 spring boot。\n 支持dubbo,motan,springcloud,等rpc框架进行分布式事务。\n 事务发起者，参与者与协调者底层基于netty长连接通信,稳定高效。\n 协调者采用eureka做注册中心，支持集群模式。\n 采用Aspect AOP 切面思想与Spring无缝集成。\n 配置简单，集成简单，源码简洁，稳定性高，已在生产环境使用。\n 内置经典的分布式事务场景demo工程，并有swagger-ui可视化界面可以快速体验。\n  事务角色\n 事务发起者（可理解为消费者 如：dubbo的消费者,springcloud的调用方）,发起分布式事务\n 事务参与者（可理解为提供者 如：dubbo的提供者,springcloud的rest服务提供者),参与事务发起者的事务\n 事务协调者（tx-manager），协调分布式事务的提交，回滚等。\n  技术方案\n 协调者（tx-manager）采用eureka作为注册中心，集群配置，达到服务的高可用，采用redis集群来分布式存储事务数据, springboot 提供rest服务，采用netty与参与者，发起者进行长连接通信。\n 发起者与协调者，采用Aspect AOP 切面思想，SPI，多线程，异步回调，线程池，netty通信等技术。\n  SPI扩展\n 本地事务恢复，支持redis，mogondb，zookeeper，file，mysql等关系型数据库 本地事务序列化保存，支持java，hessian，kryo，protostuff netty通信序列化方式，支持 hessian，kryo，protostuff   Prerequisite  JDK 1.8+ Maven 3.2.x Git RPC framework dubbo or motan or springcloud。  架构设计  架构设计图 ：  流程图 ：\n  视频源码分析 环境搭建 启动过程 事务提交 回滚恢复 管理后台 Support  如有任何问题欢迎加入QQ群进行讨论  微信公众号   # Contribution\n","date":-62135596800,"description":"Raincat是基于二阶段提交+本地事务补偿机制来实现的强一致性分布式事务框架。无缝支持dubbo,motan,springcloud等Rpc框架的微服务。","dir":"projects/raincat/overview/","fuzzywordcount":900,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"8581aebda8993d467b1930e09efa7aea","permalink":"/projects/raincat/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/raincat/overview/","summary":"Raincat 强一致性分布式事务，是基于二阶段提交+本地事务补偿机制来实现。原理介绍 基于java语言来开发（JDK1.8），支持dubbo,motan,","tags":null,"title":"Raincat 介绍","type":"projects","url":"/projects/raincat/overview/","wordcount":854},{"author":null,"categories":null,"content":" SOFA-RPC Interface Sectioon  Introduce the jar packages into your interface project.  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-annotation\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add the @Hmily annotation on the interface method in which you need to perform Hmily distributed transactions.\npublic interface HelloService { @Hmily void say(String hello); }  The project with SOFA-RPC implementation  Step 1 ： Introduce the jar package of the hmily dependency\n Step 2 ： Add Hmily configuration\n Step 3 ： Add the specific annotation to the implementation method. you need to complete the development of confirm and cancel method, if in TCC mode.\n  Introduce The Maven dependency Spring-Namespace  Introduce the hmily-sofa-rpc dependency  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-sofa-rpc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  make the configuration in the XML configuration file as below:\n  \u0026amp;lt;!-- set up to enable the aspectj-autoproxy --\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id = \u0026amp;quot;hmilyTransactionAspect\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.aop.SpringHmilyTransactionAspect\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id = \u0026amp;quot;hmilyApplicationContextAware\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.HmilyApplicationContextAware\u0026amp;quot;/\u0026amp;gt;  Spring-Boot  Introduce the hmily-spring-boot-starter-sofa-rpc dependency  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-sofa-rpc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Introduce the Hmily configuration  new a configuration file named hmily.yml under the resource directory of the current project\n the specific parameter configuration can refer to configuration detail,Local configuration mode, Zookeeper configuration mode, nacos configuration mode,apollo configuration mode\n  Add annotations on the implementation interface We have completed the integration described above,and the next we will talk about the specific implementation.\nTCC Mode  Add @HmilyTCC (confirmMethod = \u0026amp;quot;confirm\u0026amp;quot;, cancelMethod = \u0026amp;quot;cancel\u0026amp;quot;) annotation to the concrete implementation of the interface method identified by \u0026amp;lsquo;@Hmily\u0026amp;rsquo;.\n confirmMethod : the method name for confirm，The method parameter list and return type should be consistent with the identification method.\n cancelMethod : the method for cancel，The method parameter list and return type should be consistent with the identification method.\n The TCC mode should ensure the idempotence of the confirm and cancel methods,Users need to develop these two methods by themselves,The confirmation and rollback behavior of all transactions are completely up tp users.The Hmily framework is just responsible for making calls.\n  public class HelloServiceImpl implements HelloService { …","date":-62135596800,"description":"SOFA-RPC User Guide","dir":"projects/hmily/user-rpc/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"b0291d256039472c980741163fd918a8","permalink":"/en/projects/hmily/user-rpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/projects/hmily/user-rpc/","summary":"SOFA-RPC Interface Sectioon  Introduce the jar packages into your interface project.  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hmily-annotation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;{last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Add the @Hmily annotation on the interface method in which you need to perform Hmily distributed transactions.\npublic interface HelloService { @Hmily void say(String hello); }  The project with SOFA-RPC implementation  Step 1 ： Introduce the jar package of the hmily dependency\n Step 2 ： Add Hmily configuration","tags":null,"title":"SOFA-RPC User Guide","type":"projects","url":"/en/projects/hmily/user-rpc/","wordcount":515},{"author":null,"categories":null,"content":" Background kc-sofastack-demo has introduced how to quickly build an e-commerce microservice application and has implemented the service calling link tracking and application status monitoring.\nIn e-commerce system, the platforms often are not satisfied with the default product listing order, and always want to arrange some products in the conspicuous places. Also, there are some cases where the platforms would like to show different products to different users based on the collected user behaviors.\nBased on the background of kc-sofastack-demo, this guide will implement sorting the products dynamically based on the total amount of products of each onsite attendee.\nDemo content Implement the dynamic change of product sorting via the dynamic module capability provided by SOFABoot and the dynamic module control capability of SOFADashboard.\nImplement the change of application behavior without restarting the host and without changing the application configuration.\nThe project architecture is as follows:\nTasks 1. Preparation Clone the demo from GitHub to local\ngit clone https://github.com/sofastack-guides/kc-sofastack-dynamic-demo.git  Then, import the project into IDEA or Eclipse.\n2. Package SOFABoot project as Ark JAR As shown in the following screenshot, add the Ark package plugin in the POM file and configure it:\nStep 1: Copy the Ark plugin and configuration to the specified positions in the above screenshot \u0026amp;lt;plugin\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-ark-maven-plugin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;0.6.0\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;executions\u0026amp;gt; \u0026amp;lt;execution\u0026amp;gt; \u0026amp;lt;!--goal executed to generate executable-ark-jar --\u0026amp;gt; \u0026amp;lt;goals\u0026amp;gt; \u0026amp;lt;goal\u0026amp;gt;repackage\u0026amp;lt;/goal\u0026amp;gt; \u0026amp;lt;/goals\u0026amp;gt; \u0026amp;lt;!-- package configuration of ark-biz JAR --\u0026amp;gt; \u0026amp;lt;configuration\u0026amp;gt; \u0026amp;lt;!-- Whether to package, install and publish ark biz. The default value is false. For details, see Ark Biz documentation.--\u0026amp;gt; \u0026amp;lt;attach\u0026amp;gt;true\u0026amp;lt;/attach\u0026amp;gt; \u0026amp;lt;!-- The directory for ark package and ark biz package, defaulting to the build directory of project--\u0026amp;gt; \u0026amp;lt;outputDirectory\u0026amp;gt;target\u0026amp;lt;/outputDirectory\u0026amp;gt; \u0026amp;lt;!--default none--\u0026amp;gt; \u0026amp;lt;arkClassifier\u0026amp;gt;executable-ark\u0026amp;lt;/arkClassifier\u0026amp;gt; \u0026amp;lt;!-- The priority of starting ark-biz package. The smaller the value, the higher the priority.--\u0026amp;gt; \u0026amp;lt;priority\u0026amp;gt;200\u0026amp;lt;/priority\u0026amp;gt; \u0026amp;lt;!--Set the root directory of application, used to read ${base.dir}/conf/ark/bootstrap.application configuration file and defaulting to ${project.basedir}--\u0026amp;gt; \u0026amp;lt;baseDir\u0026amp;gt;../\u0026amp;lt;/baseDir\u0026amp;gt; \u0026amp;lt;/configuration\u0026amp;gt; \u0026amp;lt;/execution\u0026amp;gt; \u0026amp;lt;/executions\u0026amp;gt; \u0026amp;lt;/plugin\u0026amp;gt;  Step 2: Run mvn clean package to package the project. The successfully packaged JAR file is as shown in the following screenshot:\n3. Build host application In the downloaded project, dynamic-stock-mng is the host application model. In this task, we will build dynamic-stock-mng as the host application of dynamic module.\nStep 1: Introduce Ark …","date":-62135596800,"description":"This guide introduce how to implement the merged deployment and dynmaic module push provided by SOFAArck based on the Ark control function of SOFADashboard.","dir":"guides/kc-sofastack-dynamic-demo/","fuzzywordcount":700,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"8bfd4a50e21ce9fc867b1cf18a8c9af3","permalink":"/en/guides/kc-sofastack-dynamic-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/guides/kc-sofastack-dynamic-demo/","summary":"Background kc-sofastack-demo has introduced how to quickly build an e-commerce microservice application and has implemented the service calling link tracking and application status monitoring.\nIn e-commerce system, the platforms often are not satisfied with the default product listing order, and always want to arrange some products in the conspicuous places. Also, there are some cases where the platforms would like to show different products to different users based on the collected user behaviors.","tags":null,"title":"SOFABoot dynamic module practice","type":"guides","url":"/en/guides/kc-sofastack-dynamic-demo/","wordcount":630},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"本指南将基于 SOFADashboard 的 ARK 管控能力来实现 SOFAArk 提供的合并部署和动态模块推送的功能。","dir":"guides/kc-sofastack-dynamic-demo/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"8bfd4a50e21ce9fc867b1cf18a8c9af3","permalink":"/guides/kc-sofastack-dynamic-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/guides/kc-sofastack-dynamic-demo/","summary":"","tags":null,"title":"SOFABoot 动态模块实践","type":"guides","url":"/guides/kc-sofastack-dynamic-demo/","wordcount":0},{"author":null,"categories":null,"content":" SEATA Demo for SOFAStack Cloud Native Workshop on KubeCon China 2019\nAT mode 1.Introduce maven dependencies Introduce the following dependencies into the POM file of the parent project (seata-demo-at/pom.xml):\n... \u0026amp;lt;properties\u0026amp;gt; ... \u0026amp;lt;seata.version\u0026amp;gt;0.6.1\u0026amp;lt;/seata.version\u0026amp;gt; \u0026amp;lt;netty4.version\u0026amp;gt;4.1.24.Final\u0026amp;lt;/netty4.version\u0026amp;gt; \u0026amp;lt;/properties\u0026amp;gt; ... \u0026amp;lt;dependencyManagement\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt; ... \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;io.seata\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;seata-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${seata.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;io.seata\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;seata-server\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${seata.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;exclusions\u0026amp;gt; \u0026amp;lt;exclusion\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;javax.servlet\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;servlet-api\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/exclusion\u0026amp;gt; \u0026amp;lt;/exclusions\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;io.netty\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;netty-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${netty4.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;/dependencies\u0026amp;gt; \u0026amp;lt;/dependencyManagement\u0026amp;gt;  Introduce the following dependencies into the POM file of the stock-mng project (seata-demo-at/stock-mng/pom.xml):\n\u0026amp;lt;dependencies\u0026amp;gt; .... \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;io.seata\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;seata-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;io.netty\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;netty-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt;  Introduce the following dependencies into the POM file of the balance-mng-impl project (seata-demo-at/balance-mng/balance-mng-impl/pom.xml):\n\u0026amp;lt;dependencies\u0026amp;gt; .... \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;io.seata\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;seata-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;io.seata\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;seata-server\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;io.netty\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;netty-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependencies\u0026amp;gt;  2. Use Seata\u0026amp;rsquo;s DataSourceProxy to proxy actual data source and configure GlobalTransactionScanner to scan @GlobalTransaction annotation Add the following java snippet to the main methods in BalanceMngApplication and StockMngApplication classes:\n... import io.seata.rm.datasource.DataSourceProxy; import io.seata.spring.annotation.GlobalTransactionScanner; ... @Configuration public static class DataSourceConfig { @Bean @Primary @ConfigurationProperties(prefix = \u0026amp;quot;spring.datasource.hikari\u0026amp;quot;) public DataSource dataSource(DataSourceProperties properties) { HikariDataSource dataSource = createDataSource(properties, HikariDataSource.class); if (StringUtils.hasText(properties.getName())) { dataSource.setPoolName(properties.getName()); } return new DataSourceProxy(dataSource); } @SuppressWarnings(\u0026amp;quot;unchecked\u0026amp;quot;) …","date":-62135596800,"description":"This guide introduces how to use the AT mode and TCC mode of the open-source distributed transaction framework Seata to solve the final consistency of service data.","dir":"guides/kc-seata-demo/","fuzzywordcount":1500,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"60071a0eb44bf0901fb187eefd63ccdb","permalink":"/en/guides/kc-seata-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":7,"relpermalink":"/en/guides/kc-seata-demo/","summary":"SEATA Demo for SOFAStack Cloud Native Workshop on KubeCon China 2019\nAT mode 1.Introduce maven dependencies Introduce the following dependencies into the POM file of the parent project (seata-demo-at/pom.xml):\n... \u0026lt;properties\u0026gt; ... \u0026lt;seata.version\u0026gt;0.6.1\u0026lt;/seata.version\u0026gt; \u0026lt;netty4.version\u0026gt;4.1.24.Final\u0026lt;/netty4.version\u0026gt; \u0026lt;/properties\u0026gt; ... \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.seata\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;seata-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${seata.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.seata\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;seata-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${seata.version}\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.netty\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;netty-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${netty4.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt;  Introduce the following dependencies into the POM file of the stock-mng project (seata-demo-at/stock-mng/pom.","tags":null,"title":"Seata distributed transaction practice","type":"guides","url":"/en/guides/kc-seata-demo/","wordcount":1464},{"author":null,"categories":null,"content":" What is the Soul？ This is an asynchronous, high-performance, cross-language, responsive API gateway.I hope that something can protect your micro service like a soul.After referring to excellent gateways such as Kong, Spring-Cloud-Gateway, soul was born standing on the shoulders of giants!\nFeatures  Support various languages (http protocol), support dubbo, spring cloud protocol.\n Plugin design idea, plugin hot swap, easy to expand.\n Flexible flow filtering to meet various flow control.\n Built-in rich plugin support, authentication, limiting, fuse, firewall, etc.\n Dynamic flow configuration, high performance, gateway consumption is 1~2ms.\n Support cluster deployment, A/B Test, blue-green release.\n  Architecture diagram Prerequisite  JDK 1.8+ Maven 3.2.x Git mysql  ","date":-62135596800,"description":"This is an asynchronous, high-performance, cross-language, responsive API gateway.I hope that something can protect your micro service like a soul.After referring to excellent gateways such as Kong, Spring-Cloud-Gateway, soul was born standing on the shoulders of giants!","dir":"projects/soul/overview/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"5d30d134c5a14a47c55803eebfb34cd1","permalink":"/en/projects/soul/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/overview/","summary":"What is the Soul？ This is an asynchronous, high-performance, cross-language, responsive API gateway.I hope that something can protect your micro service like a soul.After referring to excellent gateways such as Kong, Spring-Cloud-Gateway, soul was born standing on the shoulders of giants!\nFeatures  Support various languages (http protocol), support dubbo, spring cloud protocol.\n Plugin design idea, plugin hot swap, easy to expand.\n Flexible flow filtering to meet various flow control.","tags":null,"title":"Soul Introduction","type":"projects","url":"/en/projects/soul/overview/","wordcount":103},{"author":null,"categories":null,"content":" Spring-Cloud User Guide  Step 1: Introduce the jar packages\n Step 2: Introduce the Hmily configuration\n Step 3: Add @HmilyTCC or @HmilyTAC annotation on the concrete implementation method(Service provider).\n Step 4: Add @Hmily annotation on the feignClient call method(Consumer side).\n  1.Introduce The Maven dependency Spring-Namespace  Introduce the hmily-springcloud dependency  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   make the configuration in the XML configuration file as below:  \u0026amp;lt;!--Configure the base packages that the Hmily framework need to scan --\u0026amp;gt; \u0026amp;lt;context:component-scan base-package=\u0026amp;quot;org.dromara.hmily.*\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;!-- set up to enable the aspectj-autoproxy --\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;!-- Configure the bean parameters for Hmily startup --\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;hmilyApplicationContextAware\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.HmilyApplicationContextAware\u0026amp;quot;/\u0026amp;gt;  Spring-Boot-Starter  Introduce the hmily-spring-boot-starter-springcloud dependency  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  2.Introduce the Hmily configuration  new a configuration file named hmily.yml under the resource directory of the current project\n the specific parameter configuration can refer to configuration detail,Local configuration mode, Zookeeper configuration mode, nacos configuration mode,apollo configuration mode\n  3. Add annotations on the service implementation method TCC Mode  Add @HmilyTCC (confirmMethod = \u0026amp;quot;confirm\u0026amp;quot;, cancelMethod = \u0026amp;quot;cancel\u0026amp;quot;) annotation to the concrete implementation of the interface method identified by \u0026amp;lsquo;@Hmily\u0026amp;rsquo;.\n confirmMethod : the method name for confirm，The method parameter list and return type should be consistent with the identification method.\n cancelMethod : the method for cancel，The method parameter list and return type should be consistent with the identification method.\n The TCC mode should ensure the idempotence of the confirm and cancel methods,Users need to develop these two methods by themselves,The confirmation and rollback behavior of all transactions are completely up tp users.The Hmily framework is just responsible for making calls.\n  public class HelloServiceImpl implements HelloService { @HmilyTCC(confirmMethod = \u0026amp;quot;sayConfrim\u0026amp;quot;, cancelMethod = \u0026amp;quot;sayCancel\u0026amp;quot;) public void say(String hello) { System.out.println(\u0026amp;quot;hello world\u0026amp;quot;); } public void sayConfrim(String hello) { System.out.println(\u0026amp;quot; confirm hello world\u0026amp;quot;); } public void sayCancel(String hello) { System.out.println(\u0026amp;quot; cancel hello world\u0026amp;quot;); } }  TAC Mode(Under development, not released)  Add @HmilyTAC annotation to the …","date":-62135596800,"description":"Hmily-Spring Cloud Distributed Transaction User Guide","dir":"projects/hmily/user-springcloud/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"752ffdae4261d81c1ae7318b180838bb","permalink":"/en/projects/hmily/user-springcloud/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/projects/hmily/user-springcloud/","summary":"Spring-Cloud User Guide  Step 1: Introduce the jar packages\n Step 2: Introduce the Hmily configuration\n Step 3: Add @HmilyTCC or @HmilyTAC annotation on the concrete implementation method(Service provider).\n Step 4: Add @Hmily annotation on the feignClient call method(Consumer side).\n  1.Introduce The Maven dependency Spring-Namespace  Introduce the hmily-springcloud dependency  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hmily-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;{last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   make the configuration in the XML configuration file as below:  \u0026lt;!","tags":null,"title":"Spring Cloud User Guide","type":"projects","url":"/en/projects/hmily/user-springcloud/","wordcount":541},{"author":null,"categories":null,"content":" Prerequisites  JDK 1.8+ Maven 3.2.x Git  Cloning the GitHub Repository and Quick Installation  \u0026amp;gt; git clone https://github.com/dromara/hmily.git \u0026amp;gt; cd hmily \u0026amp;gt; mvn -DskipTests clean install -U  Executing SQL(s) in Demo Module sql\nOpen with Your Favourite Editor (IDEA), Locate on hmily-demo-dubbo Module and Run Build with Maven Run with EurekaServerApplication.java in hmily-demo-springcloud-eureka project. Configuring（hmily-demo-springcloud-account module for instance）  Configure with your business database (account module for instance)  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026amp;lt;db_host_ip\u0026amp;gt;:\u0026amp;lt;db_host_port\u0026amp;gt;/hmily_account?useUnicode=true\u0026amp;amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   Modify hmily.yml, with mysql persistence backend  repository: database: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026amp;lt;db_host_ip\u0026amp;gt;:\u0026amp;lt;db_host_port\u0026amp;gt;/hmily?useUnicode=true\u0026amp;amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   run SpringCloudHmilyAccountApplication.java  Run hmily-demo-springcloud-inventory(refer to simillar instructions above). Run hmily-demo-springcloud-order(refer to simillar instructions above). Access on http://127.0.0.1:8884/swagger-ui.html for more. ","date":-62135596800,"description":"Hmily-SpringCloud Quick Start for Distributed Transactions","dir":"projects/hmily/quick-start-springcloud/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"f8a46f1745f2b3558183e9457b3e8385","permalink":"/en/projects/hmily/quick-start-springcloud/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/quick-start-springcloud/","summary":"Prerequisites  JDK 1.8+ Maven 3.2.x Git  Cloning the GitHub Repository and Quick Installation  \u0026gt; git clone https://github.com/dromara/hmily.git \u0026gt; cd hmily \u0026gt; mvn -DskipTests clean install -U  Executing SQL(s) in Demo Module sql\nOpen with Your Favourite Editor (IDEA), Locate on hmily-demo-dubbo Module and Run Build with Maven Run with EurekaServerApplication.java in hmily-demo-springcloud-eureka project. Configuring（hmily-demo-springcloud-account module for instance）  Configure with your business database (account module for instance)  spring: datasource: driver-class-name: com.","tags":null,"title":"SpringCloud Quick Start","type":"projects","url":"/en/projects/hmily/quick-start-springcloud/","wordcount":151},{"author":null,"categories":null,"content":" 环境准备  JDK 1.8+ Maven 3.2.x Git  代码拉取  \u0026amp;gt; git clone https://github.com/dromara/hmily.git \u0026amp;gt; cd hmily \u0026amp;gt; mvn -DskipTests clean install -U  执行demo 模块的sql语句。 sql语句\n使用你的工具 idea 打开项目，找到hmily-demo-springcloud项目, 进行maven构建。 启动 hmily-demo-springcloud-eureka项目中的 EurekaServerApplication.java。 修改项目配置（hmily-demo-springcloud-account为列子）  修改业务数据库(account项目为列子)  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://改成你的ip+端口/hmily_account?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: 你的用户名 password: 你的密码   修改 hmily.yml,这里使用mysql来存储  repository: database: driverClassName: com.mysql.jdbc.Driver url : jdbc:mysql://改成你的ip+端口/hmily?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: root #改成你的用户名 password: #改成你的密码   run SpringCloudHmilyAccountApplication.java  启动hmily-demo-springcloud-inventory 参考上述。 启动hmily-demo-springcloud-order 参考上述。 访问：http://127.0.0.1:8884/swagger-ui.html。 ","date":-62135596800,"description":"Hmily-SpringCloud分布式事务体验","dir":"projects/hmily/quick-start-springcloud/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"f8a46f1745f2b3558183e9457b3e8385","permalink":"/projects/hmily/quick-start-springcloud/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/quick-start-springcloud/","summary":"环境准备 JDK 1.8+ Maven 3.2.x Git 代码拉取 \u0026gt; git clone https://github.com/dromara/hmily.git \u0026gt; cd hmily \u0026gt; mvn -DskipTests clean install -U 执行demo 模块的sql语句。 sql语句 使用你的工具 idea 打开项目，找到hmily-demo","tags":null,"title":"SpringCloud快速体验","type":"projects","url":"/projects/hmily/quick-start-springcloud/","wordcount":552},{"author":null,"categories":null,"content":" Spring-Cloud 用户指南  步骤一: 引入依赖jar包\n 步骤二：引入hmily配置\n 步骤三：在具体的实现方法上（服务提供端），加上HmilyTCC or HmilyTAC 注解\n 步骤四：在feignClient调用方法上（消费方），加上Hmily\n  1.引入依赖 Spring-Namespace  引入依赖  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在xml中进行如下配置  \u0026amp;lt;!--配置扫码hmily框架的包--\u0026amp;gt; \u0026amp;lt;context:component-scan base-package=\u0026amp;quot;org.dromara.hmily.*\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;!--设置开启aspectj-autoproxy--\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;!--配置Hmily启动的bean参数--\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;hmilyApplicationContextAware\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.HmilyApplicationContextAware\u0026amp;quot;/\u0026amp;gt;  Spring-Boot-Starter  引入依赖  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  2.新增hmily配置  在项目的 resource 添加文件名为:hmily.yml 的配置文件\n 具体的参数配置可以参考配置详解,本地配置模式, zookeeper配置模式, nacos配置模式,apollo配置模式\n  3. 服务实现方添加注解 TCC模式  只需要在参与hmily分布式事务调用的具体实现方法上加@HmilyTCC(confirmMethod = \u0026amp;quot;confirm\u0026amp;quot;, cancelMethod = \u0026amp;quot;cancel\u0026amp;quot;)\n confirmMethod : 确认方法名称，该方法参数列表与返回类型应与标识方法一致。\n cancelMethod : 回滚方法名称，该方法参数列表与返回类型应与标识方法一致。\n TCC模式应该保证 confirm 和 cancel 方法的幂等性，用户需要自行去开发这个2个方法，所有的事务的确认与回滚，完全由用户决定。Hmily框架只是负责来进行调用\n  public class HelloServiceImpl implements HelloService { @HmilyTCC(confirmMethod = \u0026amp;quot;sayConfrim\u0026amp;quot;, cancelMethod = \u0026amp;quot;sayCancel\u0026amp;quot;) public void say(String hello) { System.out.println(\u0026amp;quot;hello world\u0026amp;quot;); } public void sayConfrim(String hello) { System.out.println(\u0026amp;quot; confirm hello world\u0026amp;quot;); } public void sayCancel(String hello) { System.out.println(\u0026amp;quot; cancel hello world\u0026amp;quot;); } }  TAC模式（在开发，未发布）  只需要在参与分布式事务调用的具体实现方法上加@HmilyTAC  服务消费端（FeignClient）  在服务被调用方的@FeignClient 接口方法上加上 @Hmily注解。  @FeignClient(value = \u0026amp;quot;helle-service\u0026amp;quot;) public interface HelloService { @Hmily @RequestMapping(\u0026amp;quot;/helle-service/sayHello\u0026amp;quot;) void say(String hello); }  重要注意事项 在调用任何RPC调用之前，当你需要聚合rpc调用成为一次分布式事务的时候，需要在聚合RPC调用的方法上，先行添加 @HmilyTCC 或者 @HmilyTAC 注解,表示开启全局事务。\n负载均衡  如果服务部署了几个节点， 负载均衡算法最好使用 hmily自带, 这样 try, confirm, cancel 调用会落在同一个节点 充分利用了缓存，提搞了效率。在你的yaml配置如下：   hmily.ribbon.rule.enabled = true  开启hystrix  如果用户配置了feign.hystrix.enabled = true, 默认使用线程池模式， 将会开启 HmilyHystrixConcurrencyStrategy 它在hystrix使用线程池模式的时候，能够照样通过threadLoacl 进行RPC传参数。   设置永不重试  需要进行分布式事务的SpringCloud微服务的调用方需要设置不重试，如下是参考：  ribbon: MaxAutoRetriesNextServer : 0 MaxAutoRetries: 0  异常  try, confirm, cancel 方法的所有异常不要自行catch 任何异常都应该抛出给 Hmily框架处理。   ","date":-62135596800,"description":"Hmily-SpringCloud分布式事务用户指南","dir":"projects/hmily/user-springcloud/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"752ffdae4261d81c1ae7318b180838bb","permalink":"/projects/hmily/user-springcloud/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/hmily/user-springcloud/","summary":"Spring-Cloud 用户指南 步骤一: 引入依赖jar包 步骤二：引入hmily配置 步骤三：在具体的实现方法上（服务提供端），加上HmilyTCC or HmilyTAC 注解 步骤四：在","tags":null,"title":"SpringCloud用户指南","type":"projects","url":"/projects/hmily/user-springcloud/","wordcount":1031},{"author":null,"categories":null,"content":" Prerequisites  JDK 1.8+ Maven 3.2.x Git Zookeeper  Cloning the GitHub Repository and Quick Installation  \u0026amp;gt; git clone https://github.com/dromara/hmily.git \u0026amp;gt; cd hmily \u0026amp;gt; mvn -DskipTests clean install -U  Executing SQL(s) in Demo Module sql\nSetting tars nodes Build tars nodes with following information refering to here:\n APP: TestInventory, Server Name: InventoryApp, OBJ: InventoryObj, Port: 29740 APP: HmilyAccount, Server Name: AccountApp, OBJ: AccountObj, Port: 10386  With nodes built, run mvn clean package packaging command respectively under hmily-demo-tars-springboot-account and hmily-demo-tars-springboot-inventory directories, and publish with outputs on previous nodes set. Refer to here for details.\nOpen with Your Favourite Editor (IDEA) and Locate on hmily-demo-tars Module Configuring（hmily-demo-tars-account module for instance）  Configure with your business database(account module for instance)  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026amp;lt;db_host_ip\u0026amp;gt;:\u0026amp;lt;db_host_port\u0026amp;gt;/hmily_account?useUnicode=true\u0026amp;amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   Modify hmily.yml, with mysql persistence backend  repository: database: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026amp;lt;db_host_ip\u0026amp;gt;:\u0026amp;lt;db_host_port\u0026amp;gt;/hmily?useUnicode=true\u0026amp;amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   Replace 192.168.41.102 globally with tars platform IP address within file(s) suffixed with config.conf under rescouces directory, and append an -Dconfig=\u0026amp;lt;file\u0026amp;gt; parameter to bootstrap parameters with previous file location(s)\n run TarsHmilyAccountApplication.java\n  Run hmily-demo-tars-springboot-inventory(refer to simillar instructions above). Run hmily-demo-tars-springboot-order(refer to simillar instructions above). Access on http://127.0.0.1:18087/swagger-ui.html for more. ","date":-62135596800,"description":"Tars Quick Start","dir":"projects/hmily/quick-start-tars/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"76bbac5c6c6575e871bc59f8373e9890","permalink":"/en/projects/hmily/quick-start-tars/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/hmily/quick-start-tars/","summary":"Prerequisites  JDK 1.8+ Maven 3.2.x Git Zookeeper  Cloning the GitHub Repository and Quick Installation  \u0026gt; git clone https://github.com/dromara/hmily.git \u0026gt; cd hmily \u0026gt; mvn -DskipTests clean install -U  Executing SQL(s) in Demo Module sql\nSetting tars nodes Build tars nodes with following information refering to here:\n APP: TestInventory, Server Name: InventoryApp, OBJ: InventoryObj, Port: 29740 APP: HmilyAccount, Server Name: AccountApp, OBJ: AccountObj, Port: 10386  With nodes built, run mvn clean package packaging command respectively under hmily-demo-tars-springboot-account and hmily-demo-tars-springboot-inventory directories, and publish with outputs on previous nodes set.","tags":null,"title":"Tars Quick Start","type":"projects","url":"/en/projects/hmily/quick-start-tars/","wordcount":227},{"author":null,"categories":null,"content":" Tars User Guide  Step 1: Introduce the jar packages\n Step 2: Introduce the Hmily configuration\n Step 3: Add @Hmily annotation on the auto-generated Servant interface method which required the Hmily Distributed Transaction.\n Step 4: Add @HmilyTCC or @HmilyTAC annotation on the concrete implementation method(Service provider).\n  Introduce The Maven dependency Spring-Namespace\n Introduce the hmily-tars dependency   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-tars\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   make the configuration in the XML configuration file as below:\n\u0026amp;lt;!--Configure the base packages that the Hmily framework need to scan --\u0026amp;gt; \u0026amp;lt;context:component-scan base-package=\u0026amp;quot;org.dromara.hmily.*\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;!-- set up to enable the aspectj-autoproxy --\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;!-- Configure the bean parameters for Hmily startup --\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;hmilyApplicationContextAware\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.HmilyApplicationContextAware\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;hmilyCommunicatorBeanPostProcessor\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.tars.spring.TarsHmilyCommunicatorBeanPostProcessor\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;tarsHmilyStartupBean\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.tars.spring.TarsHmilyFilterStartupBean\u0026amp;quot;/\u0026amp;gt;  Spring-Boot\n Introduce the hmily-spring-boot-starter-tars dependency\nxml \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-tars\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;    Introduce the Hmily configuration  new a configuration file named hmily.yml under the resource directory of the current project\n the specific parameter configuration can refer to configuration detail,Local configuration mode, Zookeeper configuration mode, nacos configuration mode,apollo configuration mode\n  Add annotations on the service implementation interface We have completed the integration described above,and the next we will talk about the specific implementation.\nTCC Mode  Add @HmilyTCC (confirmMethod = \u0026amp;quot;confirm\u0026amp;quot;, cancelMethod = \u0026amp;quot;cancel\u0026amp;quot;) annotation to the concrete implementation of the interface method identified by \u0026amp;lsquo;@Hmily\u0026amp;rsquo;.\n confirmMethod : the method name for confirm，The method parameter list and return type should be consistent with the identification method.\n cancelMethod : the method for cancel，The method parameter list and return type should be consistent with the identification method.\n The TCC mode should ensure the idempotence of the confirm and cancel methods,Users need to develop these two methods by themselves,The confirmation and rollback behavior of all transactions are completely up tp users.The Hmily framework is just responsible for making calls.\n  public class HelloServiceImpl implements HelloService { @HmilyTCC(confirmMethod = …","date":-62135596800,"description":"Tars User Guide","dir":"projects/hmily/user-tars/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"6ab504fb449aa59762cf68f052d17f16","permalink":"/en/projects/hmily/user-tars/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/hmily/user-tars/","summary":"Tars User Guide  Step 1: Introduce the jar packages\n Step 2: Introduce the Hmily configuration\n Step 3: Add @Hmily annotation on the auto-generated Servant interface method which required the Hmily Distributed Transaction.\n Step 4: Add @HmilyTCC or @HmilyTAC annotation on the concrete implementation method(Service provider).\n  Introduce The Maven dependency Spring-Namespace\n Introduce the hmily-tars dependency   \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hmily-tars\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;{last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   make the configuration in the XML configuration file as below:","tags":null,"title":"Tars User Guide","type":"projects","url":"/en/projects/hmily/user-tars/","wordcount":352},{"author":null,"categories":null,"content":" Team Member（In no particular order） |Name | Github | Role | Company | |:\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash; |:\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;- |:\u0026amp;mdash;\u0026amp;mdash;-: |:\u0026amp;mdash;\u0026amp;mdash;-:| |Xiao Yu |yu199195 | VP | jd.com | |Zhang Yonglun |tuohai666 | PMC | jd.com | |Deng Liming |dengliming | PMC | a start-up company | |Tang Yudong |tydhot | PMC | perfma | |Zhang lei |SaberSola | PMC | helloglobal | |Chen Bing |prFor | PMC | a start-up company | |Huang Xiaofeng |huangxfchn | committer | shein | |Liang Ziqiang |241600489 | committer | didi | |zhuang hao chao |dmsolr | committer | YY |\n|Jiang Xiaofeng |SteNicholas | committer | aliyun | |Ding jianming |nuo-promise | committer | a start-up company |\n","date":-62135596800,"description":"Team Introduction","dir":"projects/soul/team/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"42ecc8eaa96819548d640c00c6bae90b","permalink":"/en/projects/soul/team/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/team/","summary":"Team Member（In no particular order） |Name | Github | Role | Company | |:\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; |:\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- |:\u0026mdash;\u0026mdash;-: |:\u0026mdash;\u0026mdash;-:| |Xiao Yu |yu199195 | VP | jd.com | |Zhang Yonglun |tuohai666 | PMC | jd.com | |Deng Liming |dengliming | PMC | a start-up company | |Tang Yudong |tydhot | PMC | perfma | |Zhang lei |SaberSola | PMC | helloglobal | |Chen Bing |prFor | PMC | a start-up company | |Huang Xiaofeng |huangxfchn | committer | shein | |Liang Ziqiang |241600489 | committer | didi | |zhuang hao chao |dmsolr | committer | YY |","tags":null,"title":"Team Introduction","type":"projects","url":"/en/projects/soul/team/","wordcount":112},{"author":null,"categories":null,"content":" @TxTransaction annotation详解  该注解为分布式事务的切面（AOP point），如果业务方的service服务需要参与分布式事务，则需要加上此注解。  TxTransactionBootstrap 详解： \u0026amp;lt;context:component-scan base-package=\u0026amp;quot;org.dromara.raincat.*\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;txTransactionBootstrap\u0026amp;quot; class=\u0026amp;quot;org.dromara.raincat.core.bootstrap.TxTransactionBootstrap\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;txManagerUrl\u0026amp;quot; value=\u0026amp;quot;http://localhost:8761\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serializer\u0026amp;quot; value=\u0026amp;quot;kryo\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;nettySerializer\u0026amp;quot; value=\u0026amp;quot;kryo\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;bufferSize\u0026amp;quot; value=\u0026amp;quot;4096\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;nettyThreadMax\u0026amp;quot; value=\u0026amp;quot;16\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;refreshInterval\u0026amp;quot; value=\u0026amp;quot;30\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;delayTime\u0026amp;quot; value=\u0026amp;quot;30\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;heartTime\u0026amp;quot; value=\u0026amp;quot;10\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;compensation\u0026amp;quot; value=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;recoverDelayTime\u0026amp;quot; value=\u0026amp;quot;60\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;retryMax\u0026amp;quot; value=\u0026amp;quot;3\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;compensationRecoverTime\u0026amp;quot; value=\u0026amp;quot;60\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;compensationCacheType\u0026amp;quot; value=\u0026amp;quot;db\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;txDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;bean class=\u0026amp;quot;org.dromara.raincat.common.config.TxDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;url\u0026amp;quot; value=\u0026amp;quot;jdbc:mysql://192.168.1.98:3306/tx?useUnicode=true\u0026amp;amp;amp;characterEncoding=utf8\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;driverClassName\u0026amp;quot; value=\u0026amp;quot;com.mysql.jdbc.Driver\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;username\u0026amp;quot; value=\u0026amp;quot;root\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;password\u0026amp;quot; value=\u0026amp;quot;123456\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;   txManagerUrl：填写你启动的txManager的ip端口，注意添加http://前缀。\n serializer :事务日志序列化方式，这里我推荐使用是kroy。当然也支持hessian,protostuff,jdk。在我们测试中表现为: kroy\u0026amp;gt;hessian\u0026amp;gt;protostuff\u0026amp;gt;jdk。\n nettySerializer： 与txManager通信对象的序列化方法，注意与txManager中的序列化方式配置一样。\n bufferSize: disruptor的bufferSize,当高并发的时候，可以调大。注意是 2n次方。\n nettyThreadMax ： netty客户端工作线程数量。\n refreshInterval: 拉取txmanager配置信息间隔时间，单位秒。\n delayTime ： 客户端与txmanager通信最大延迟时间。\n heartTime ： 与txmanager保持心跳时间间隔，单位秒。\n compensation： 是否需要补偿，一般情况下不需要，极端情况下设置为true。\n recoverDelayTime：事务恢复延迟时间，只有当 compensation：为ture才有用。\n compensationRecoverTime： 补偿间隔时间 只有当 compensation：为ture才有用。\n retryMax ： 事务补偿最大重试次数。\n  compensationCacheType：使用何种方式存储日志，支持的有db，redis，mongo，zookeeper等。\n 接下来是最重要的事务日志的存储 在我们的压测中，推荐使用mongo。表现为 mongodb\u0026amp;gt;redis集群\u0026amp;gt;mysql\u0026amp;gt;zookeeper\n 如果你采用mongodb存储日志,配置如下(url可以配置成mongdb集群的url)\n\u0026amp;lt;property name=\u0026amp;quot;compensationCacheType\u0026amp;quot; value=\u0026amp;quot;mongodb\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;txMongoConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;bean class=\u0026amp;quot;org.dromara.raincat.common.config.TxMongoConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;mongoDbUrl\u0026amp;quot; value=\u0026amp;quot;192.168.1.68:27017\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;mongoDbName\u0026amp;quot; …","date":-62135596800,"description":"TxTransactionBootstrap配置详解","dir":"projects/raincat/config/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"cc6554b136c58c9f98f1e9c1fdd06647","permalink":"/projects/raincat/config/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/raincat/config/","summary":"@TxTransaction annotation详解 该注解为分布式事务的切面（AOP point），如果业务方的service服务需要参与分布式事务，则需要加上此注解。","tags":null,"title":"TxTransactionBootstrap配置详解","type":"projects","url":"/projects/raincat/config/","wordcount":1000},{"author":null,"categories":null,"content":" 说明  soul网关在对目标服务调用的时候，还容许用户使用 context_path 插件来重写请求路径的contextPath  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; context_path 设置为开启。\n 在网关的 pom.xml 文件中添加 context_path 的支持。\n 如果用户不需要，可以把插件禁用。\n  \u0026amp;lt;!-- soul context_path plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-context-path\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul context_path plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。\n 只有匹配的请求，并且配置规则才会进行重写contextPath。   场景  顾名思义，context_path插件就是对uri的contextPath重新定义。\n 当匹配到请求后，设置自定义的contextPath，那么就会根据请求的Url截取自定义的contextPath获取真正的Url，例如请求路径为/soul/http/order， 配置的contextPath为\u0026amp;rsquo;/soul/http\u0026amp;rsquo;，那么真正请求的url为\u0026amp;rsquo;/order\u0026amp;rsquo;。\n  ","date":-62135596800,"description":"context_path插件","dir":"projects/soul/context-path-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"2767e8857680920fcae77cbe4c3bdf3b","permalink":"/projects/soul/context-path-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/context-path-plugin/","summary":"说明 soul网关在对目标服务调用的时候，还容许用户使用 context_path 插件来重写请求路径的contextPath 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; context_path 设置为开启。 在网","tags":null,"title":"context-path-mapping插件","type":"projects","url":"/projects/soul/context-path-plugin/","wordcount":368},{"author":null,"categories":null,"content":" description  This doc offers examples for customising response structure.\n The response body structure in gateways should be unified, it is recommended for specify yours.\n  default implementation  The default implementation class is org.dromara.soul.plugin.api.result.DefaultSoulResult\n Following is the response structure:\n  public class SoulDefaultEntity implements Serializable { private static final long serialVersionUID = -2792556188993845048L; private Integer code; private String message; private Object data; }   The returned json as follows:\n{ \u0026amp;quot;code\u0026amp;quot;: -100, //response code, \u0026amp;quot;message\u0026amp;quot;: \u0026amp;quot;您的参数错误,请检查相关文档!\u0026amp;quot;, //hint messages \u0026amp;quot;data\u0026amp;quot;: null // business data }  extensions  Declare a new class named \u0026amp;ldquo;A\u0026amp;rdquo; and implements org.dromara.soul.plugin.api.result.SoulResult  public interface SoulResult\u0026amp;lt;T\u0026amp;gt; { /** * Success t. * * @param code the code * @param message the message * @param object the object * @return the t */ T success(int code, String message, Object object); /** * Error t. * * @param code the code * @param message the message * @param object the object * @return the t */ T error(int code, String message, Object object); }  T is a generic parameter for your response data.\n Register defined class as a Spring Bean.\n  @Bean public SoulResult a() { return new A(); }  ","date":-62135596800,"description":"customising response structure","dir":"projects/soul/custom-result/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"a8aa2a84984dc4749833c69cfab55ba0","permalink":"/en/projects/soul/custom-result/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/custom-result/","summary":"description This doc offers examples for customising response structure. The response body structure in gateways should be unified, it is recommended for specify yours. default implementation The default implementation class is org.dromara.soul.plugin.api.result.DefaultSoulResult Following is the response structure: public class SoulDefaultEntity implements Serializable { private static final long serialVersionUID = -2792556188993845048L; private Integer code; private String message; private Object data; } The returned json as follows: { \u0026quot;code\u0026quot;: -100, //response code,","tags":null,"title":"customising response structure","type":"projects","url":"/en/projects/soul/custom-result/","wordcount":211},{"author":null,"categories":null,"content":" Explanation  Dictionary management is primarily used to maintain and manage common data dictionaries.  Table design  sql sql CREATE TABLE IF NOT EXISTS `soul_dict` ( `id` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;primary key id\u0026#39;, `type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;type\u0026#39;, `dict_code` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;dictionary encoding\u0026#39;, `dict_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;dictionary name\u0026#39;, `dict_value` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;dictionary value\u0026#39;, `desc` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;dictionary description or remarks\u0026#39;, `sort` int(4) NOT NULL COMMENT \u0026#39;sort\u0026#39;, `enabled` tinyint(4) DEFAULT NULL COMMENT \u0026#39;whether it is enabled\u0026#39;, `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;create time\u0026#39;, `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;update time\u0026#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;  * The current usage scenario is when the plugin handle configuring the data_type=3 (select box) eg. degradeRuleGrade is one of fields of sentinel\u0026amp;rsquo;s handle json When it adds rules, it automatically looks up all the general dictionaries of type=\u0026#39;degradeRuleGrade\u0026#39; in the soul_dict table as a select-box when you edit the General rules field  ","date":-62135596800,"description":"dict management explanation","dir":"projects/soul/dictionary-management/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"e863725978b7cf19ab005f1950deae5d","permalink":"/en/projects/soul/dictionary-management/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/dictionary-management/","summary":"Explanation  Dictionary management is primarily used to maintain and manage common data dictionaries.  Table design  sql sql CREATE TABLE IF NOT EXISTS `soul_dict` ( `id` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'primary key id', `type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'type', `dict_code` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'dictionary encoding', `dict_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'dictionary name', `dict_value` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'dictionary value', `desc` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'dictionary description or remarks', `sort` int(4) NOT NULL COMMENT 'sort', `enabled` tinyint(4) DEFAULT NULL COMMENT 'whether it is enabled', `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'create time', `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'update time', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;  * The current usage scenario is when the plugin handle configuring the data_type=3 (select box) eg.","tags":null,"title":"dict management","type":"projects","url":"/en/projects/soul/dictionary-management/","wordcount":177},{"author":null,"categories":null,"content":" 说明  divide插件是网关处理 http协议请求的核心处理插件。  插件设置  开启插件，soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理\u0026amp;ndash;\u0026amp;gt; divide 设置为启用。\n divide插件，配合如下 starter一起才能生效，具体请看：http用户。\n  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  插件讲解  divide插件是进行http正向代理的插件，所有http类型的请求，都是由该插件进行负载均衡的调用。\n 选择器和规则，请详细看：选择器规则。\n http配置，是网关匹配到流量以后，真实调用的http配置，可以配置多个，设置负载均衡权重，具体的负载均衡策略，在规则中指定。\n 配置详解：\n 第一个框：hostName，一般填写 localhost，该字段暂时没使用。\n 第二个框：http协议，一般填写 http:// 或者 https:// ，不填写默认为:http://\n 第三个框：ip与端口，这里填写你真实服务的 ip + 端口。\n 第四个框：负载均衡权重。\n  ip + port 检测\n 在soul-admin 会有一个定时任务来扫描 配置的ip端口，如果发现下线，则会除该 ip + port\n 可以进行如下配置 ：\n    soul.upstream.check:true 默认为 ture，设置为false，不检测 soul.upstream.scheduledTime:10 定时检测时间间隔，默认10秒  ","date":-62135596800,"description":"divide插件","dir":"projects/soul/divide-plugin/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"8465c00775647d58b1a1a484e58e20fd","permalink":"/projects/soul/divide-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/divide-plugin/","summary":"说明 divide插件是网关处理 http协议请求的核心处理插件。 插件设置 开启插件，soul-admin \u0026ndash;\u0026gt; 插件管理\u0026ndash;\u0026gt; divide 设置为","tags":null,"title":"divide插件","type":"projects","url":"/projects/soul/divide-plugin/","wordcount":474},{"author":null,"categories":null,"content":" 环境准备  JDK 1.8+ Maven 3.2.x Git redis mysql  代码拉取  \u0026amp;gt; git clone https://github.com/yu199195/Raincat.git \u0026amp;gt; cd Raincat \u0026amp;gt; mvn -DskipTests clean install -U  执行demo 模块的sql语句。 sql语句\n使用你的工具 idea 或者eclipse 打开项目。 修改raincat-manager项目下，application.yml中的redis配置 tx: manager: netty : port: 9998 serialize: kryo maxConnection: 100 maxThreads : 16 delayTime : 5 heartTime : 20 redis : cluster : false hostName : 192.168.1.91 port: 6379 password : foobaredbbexONE123  启动raincat-manager （执行TxManagerApplication中的main方法） 修改order项目的application.yml中的数据库配置 spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://192.168.1.98:3306/order?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: root password: 123456 application: name: order-service org: dromara: raincat: txManagerUrl: http://localhost:8761 serializer: kroy nettySerializer: kroy compensation: true compensationCacheType : db txDbConfig : driverClassName : com.mysql.jdbc.Driver url : jdbc:mysql://192.168.1.98:3306/tx?useUnicode=true\u0026amp;amp;amp;characterEncoding=utf8 username : root password : 123456   修改 spring-dubbo.xml中的zookeeper配置  \u0026amp;lt;dubbo:registry protocol=\u0026amp;quot;zookeeper\u0026amp;quot; address=\u0026amp;quot;localhost:2181\u0026amp;quot;/\u0026amp;gt;   在spring-dubbo中修改你的zookeeper地址  \u0026amp;lt;dubbo:registry protocol=\u0026amp;quot;zookeeper\u0026amp;quot; address=\u0026amp;quot;192.168.1.148:2181\u0026amp;quot;/\u0026amp;gt;   启动order项目。（执行OrderApplication中的main方法）  其他项目类似，启动stock项目，启动consume项目。 访问 http://127.0.0.1:8087/swagger-ui.html ","date":-62135596800,"description":"dubbo快速体验","dir":"projects/raincat/quick-start-dubbo/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"f7cbd7713b45cbabec790f30d709d87a","permalink":"/projects/raincat/quick-start-dubbo/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/raincat/quick-start-dubbo/","summary":"环境准备 JDK 1.8+ Maven 3.2.x Git redis mysql 代码拉取 \u0026gt; git clone https://github.com/yu199195/Raincat.git \u0026gt; cd Raincat \u0026gt; mvn -DskipTests clean install -U 执行demo 模块的sql语句。 sql语句 使用你的工具 idea 或者eclipse 打开项目。 修","tags":null,"title":"dubbo 快速体验","type":"projects","url":"/projects/raincat/quick-start-dubbo/","wordcount":404},{"author":null,"categories":null,"content":" 说明  此篇文章是dubbo用户使用dubbo插件支持，以及自己的dubbo服务接入soul网关的教程。\n 支持 alibaba dubbo（\u0026amp;lt; 2.7.x） 以及 apache dubbo (\u0026amp;gt;=2.7.x)。\n 接入前，请正确的启动 soul-admin , 以及搭建环境 Ok。\n  引入网关对dubbo支持的插件  在网关的 pom.xml 文件中增加如下依赖：\n alibaba dubbo 用户, dubbo版本换成你的，注册中心的jar包换成你的，以下是参考。   \u0026amp;lt;!--soul alibaba dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-alibaba-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul alibaba dubbo plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.6.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   apache dubbo 用户，dubbo版本换成你的，使用什么注册中心换成你的,以下是参考,使用什么注册中心，就引入啥。  \u0026amp;lt;!--soul apache dubbo plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul apache dubbo plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo Nacos registry dependency start --\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.dubbo\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;dubbo-registry-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.7.5\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.nacos\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;nacos-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;1.1.4\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo Nacos registry dependency end--\u0026amp;gt; \u0026amp;lt;!-- Dubbo zookeeper registry dependency start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- Dubbo zookeeper registry dependency end --\u0026amp;gt;   重启网关服务。  dubbo服务接入网关，可以参考：soul-test-dubbo  alibaba dubbo 用户\n springboot\n 引入以下依赖\n\u0026amp;lt;dependency\u0026amp;gt; …","date":-62135596800,"description":"dubbo接入soul网关","dir":"projects/soul/dubbo-proxy/","fuzzywordcount":2500,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"c3a28f2bf5654b9ce4f342e6319bb18b","permalink":"/projects/soul/dubbo-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/projects/soul/dubbo-proxy/","summary":"说明 此篇文章是dubbo用户使用dubbo插件支持，以及自己的dubbo服务接入soul网关的教程。 支持 alibaba dubbo（\u0026lt; 2.7.x） 以","tags":null,"title":"dubbo接入soul网关","type":"projects","url":"/projects/soul/dubbo-proxy/","wordcount":2473},{"author":null,"categories":null,"content":" 说明  dubbo插件是将http协议 转换成dubbo协议 的插件，也是网关实现dubbo泛化调用的关键。\n dubbo插件需要配合元数据才能实现dubbo的调用，具体请看: 元数据。\n apache dubbo 和 alibaba dubbo用户，都是使用该同一插件。\n  \u0026amp;lt;!--if you use dubbo start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-alibab-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; dubbo 设置为开启。\n 在dubbo插件的配置中，配置如下：配置dubbo的注册中心。\n{\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;zookeeper://localhost:2181\u0026amp;quot;} or {\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;nacos://localhost:8848\u0026amp;quot;}   插件需要配合依赖 starter 进行使用,具体请看：dubbo用户。\n 选择器和规则，请详细看：选择器规则。\n  元数据  每一个dubbo接口方法，都会对应一条元数据，可以在 soul-admin \u0026amp;ndash;\u0026amp;gt;元数据管理，进行查看。\n 路径：就是你http请求的路径。\n rpc扩展参数，对应为dubbo接口的一些配置，调整的化，请在这里修改，支持json格式，以下字段：\n  {\u0026amp;quot;timeout\u0026amp;quot;:10000,\u0026amp;quot;group\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,version\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;loadbalance\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;retries\u0026amp;quot;:1}   ","date":-62135596800,"description":"dubbo插件","dir":"projects/soul/dubbo-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"3d2239e5808ce4944a60f1e751374797","permalink":"/projects/soul/dubbo-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/dubbo-plugin/","summary":"说明 dubbo插件是将http协议 转换成dubbo协议 的插件，也是网关实现dubbo泛化调用的关键。 dubbo插件需要配合元数据才能实现du","tags":null,"title":"dubbo插件","type":"projects","url":"/projects/soul/dubbo-plugin/","wordcount":345},{"author":null,"categories":null,"content":" Dubbo接口部分  在你的接口项目中引入jar包。  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-annotation\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在需要进行Hmily分布式事务的接口方法上加上 @Hmily 标识。\npublic interface HelloService { @Hmily void say(String hello); }  Dubbo实现项目  步骤一 ： 引入依赖hmily的jar包\n 步骤二 ： 新增Hmily配置\n 步骤三 ： 在实现方法上添加注解。TCC模式，则需要完成 confirm，cancel方法的开发\n  引入依赖 Spring-Namespace  Alibaba-Dubbo 用户引入  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Aapche-Dubbo 用户引入\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在xml中进行如下配置  \u0026amp;lt;!--设置开启aspectj-autoproxy--\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id = \u0026amp;quot;hmilyTransactionAspect\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.aop.SpringHmilyTransactionAspect\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id = \u0026amp;quot;hmilyApplicationContextAware\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.HmilyApplicationContextAware\u0026amp;quot;/\u0026amp;gt;  Spring-Boot  Alibaba-Dubbo 用户引入  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Aapche-Dubbo 用户引入  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  引入 hmily配置  在项目的 resource 新建文件名为:hmily.yml配置文件\n 具体的参数配置可以参考配置详解,本地配置模式, zookeeper配置模式, nacos配置模式,apollo配置模式\n  实现接口上添加注解 上述我们已经完成了集成，下面将讲述具体的实现。\nTCC模式  对@Hmily 标识的接口方法的具体实现上，加上@HmilyTCC(confirmMethod = \u0026amp;quot;confirm\u0026amp;quot;, cancelMethod = \u0026amp;quot;cancel\u0026amp;quot;)\n confirmMethod : 确认方法名称，该方法参数列表与返回类型应与标识方法一致。\n cancelMethod : 回滚方法名称，该方法参数列表与返回类型应与标识方法一致。\n TCC模式应该保证 confirm 和 cancel 方法的幂等性，用户需要自行去开发这个2个方法，所有的事务的确认与回滚，完全由用户决定。Hmily框架只是负责来进行调用\n  public class HelloServiceImpl implements HelloService { @HmilyTCC(confirmMethod = \u0026amp;quot;sayConfrim\u0026amp;quot;, cancelMethod = \u0026amp;quot;sayCancel\u0026amp;quot;) public void say(String hello) { System.out.println(\u0026amp;quot;hello world\u0026amp;quot;); } public void sayConfrim(String hello) { System.out.println(\u0026amp;quot; confirm hello world\u0026amp;quot;); } public void sayCancel(String hello) { System.out.println(\u0026amp;quot; cancel hello world\u0026amp;quot;); } }  dubbo注解用户 对于使用 @Reference 注解来注入dubbo服务的用户，请注意：你可以需要做如下配置:\nspring-namespace 用户 在你的xml配置中，需要将 org.dromara.hmily.spring.annotation.RefererAnnotationBeanPostProcessor 注入成spring的bean\n\u0026amp;lt;bean id = \u0026amp;quot;refererAnnotationBeanPostProcessor\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.annotation.RefererAnnotationBeanPostProcessor\u0026amp;quot;/\u0026amp;gt;  spring-boot用户 需要在yml文件里面开启注解支持：\nhmily.support.rpc.annotation = true  或者在项目中显示注入：\n@Bean public BeanPostProcessor …","date":-62135596800,"description":"dubbo用户指南","dir":"projects/hmily/user-dubbo/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"c28d182a0aec22568b1dbf4e64014041","permalink":"/projects/hmily/user-dubbo/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/hmily/user-dubbo/","summary":"Dubbo接口部分 在你的接口项目中引入jar包。 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hmily-annotation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;{last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在需要进行Hmily分布式事务的接口方法上加上 @Hmily 标识。 public interface HelloService { @Hmily void say(String hello); } Dubbo","tags":null,"title":"dubbo用户指南","type":"projects","url":"/projects/hmily/user-dubbo/","wordcount":1053},{"author":null,"categories":null,"content":" 首先启动raincat-manager，具体怎么启动参考 启动manager jar包依赖，在你的dubbo服务端添加jar包，并在需要参与分布式事务的方法上添加 @TxTransaction注解 \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;raincat-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.0.0-RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Spring XML方式配置 TxTransactionBootstrap \u0026amp;lt;context:component-scan base-package=\u0026amp;quot;org.dromara.*\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;txTransactionBootstrap\u0026amp;quot; class=\u0026amp;quot;org.dromara.raincat.core.bootstrap.TxTransactionBootstrap\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;txManagerUrl\u0026amp;quot; value=\u0026amp;quot;http://localhost:8761\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serializer\u0026amp;quot; value=\u0026amp;quot;kryo\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;nettySerializer\u0026amp;quot; value=\u0026amp;quot;kryo\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;compensation\u0026amp;quot; value=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;compensationCacheType\u0026amp;quot; value=\u0026amp;quot;db\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;txDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;bean class=\u0026amp;quot;org.dromara.raincat.common.config.TxDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;url\u0026amp;quot; value=\u0026amp;quot;jdbc:mysql://192.168.1.98:3306/tx?useUnicode=true\u0026amp;amp;amp;characterEncoding=utf8\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;driverClassName\u0026amp;quot; value=\u0026amp;quot;com.mysql.jdbc.Driver\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;username\u0026amp;quot; value=\u0026amp;quot;root\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;password\u0026amp;quot; value=\u0026amp;quot;123456\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;  Spring boot start方式配置 TxTransactionBootstrap  首先依赖raincat 提供的spring-boot-starter-dubbo\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;raincat-spring-boot-starter-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.0.0-RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   配置 application.yml  org: dromara: raincat: txManagerUrl: http://localhost:8761 serializer: kroy nettySerializer: kroy compensation: true compensationCacheType : db txDbConfig : driverClassName : com.mysql.jdbc.Driver url : jdbc:mysql://192.168.1.98:3306/tx?useUnicode=true\u0026amp;amp;amp;characterEncoding=utf8 username : root password : 123456  txManagerUrl：填写你启动的txManager的ip端口，注意添加http://\n serializer： 是指事务日志的序列化方式\n nettySerializer： 与txManager通信对象的序列化方法，注意与txManager中的序列化方式配置一样。\n compensation ：是否需要补偿，极端情况下，服务自身会进行补偿。\n compensationCacheType： 存储日志类型，当然还有支持redis，mongo，zookeeper等等，具体可以参考 配置详解。\n  配置扫描raincat包，与开启AOP代理（XML方式配置的时候必须加上，starter方式不需要）。 如果有任何问题可以参考dubbo-sample ","date":-62135596800,"description":"dubbo用户指南","dir":"projects/raincat/dubbo-user/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"a0a83765c3479d6917cf98d3c7b0403b","permalink":"/projects/raincat/dubbo-user/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/raincat/dubbo-user/","summary":"首先启动raincat-manager，具体怎么启动参考 启动manager jar包依赖，在你的dubbo服务端添加jar包，并在需要参与分布","tags":null,"title":"dubbo用户指南","type":"projects","url":"/projects/raincat/dubbo-user/","wordcount":535},{"author":null,"categories":null,"content":" description  This doc gives a brief description for uploading and downloading files using soul.  file uploading  The default file size limit is 10M.\n For custom limitation, use--file.size with an integer variable. e.g.--file.size = 30\n Upload your files just as way you did before\n  file downloading  Soul supports downloading files in streams. There is no need to change anything.  ","date":-62135596800,"description":"file uploading and downloading","dir":"projects/soul/file-and-image/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"7a88c55afa64c43801dafd3964bdbf01","permalink":"/en/projects/soul/file-and-image/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/file-and-image/","summary":" description  This doc gives a brief description for uploading and downloading files using soul.  file uploading  The default file size limit is 10M.\n For custom limitation, use--file.size with an integer variable. e.g.--file.size = 30\n Upload your files just as way you did before\n  file downloading  Soul supports downloading files in streams. There is no need to change anything.  ","tags":null,"title":"file uploading and downloading","type":"projects","url":"/en/projects/soul/file-and-image/","wordcount":58},{"author":null,"categories":null,"content":" description  This doc shows a demo for how to extend org.springframework.web.server.WebFliter.  CORS support  org.dromara.soul.bootstrap.cors.CrossFilter is designed for WebFilter implementation.  public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026amp;quot;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026amp;quot;; private static final String ALLOWED_METHODS = \u0026amp;quot;*\u0026amp;quot;; private static final String ALLOWED_ORIGIN = \u0026amp;quot;*\u0026amp;quot;; private static final String ALLOWED_EXPOSE = \u0026amp;quot;*\u0026amp;quot;; private static final String MAX_AGE = \u0026amp;quot;18000\u0026amp;quot;; @Override @SuppressWarnings(\u0026amp;quot;all\u0026amp;quot;) public Mono\u0026amp;lt;Void\u0026amp;gt; filter(final ServerWebExchange exchange, final WebFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); if (CorsUtils.isCorsRequest(request)) { ServerHttpResponse response = exchange.getResponse(); HttpHeaders headers = response.getHeaders(); headers.add(\u0026amp;quot;Access-Control-Allow-Origin\u0026amp;quot;, ALLOWED_ORIGIN); headers.add(\u0026amp;quot;Access-Control-Allow-Methods\u0026amp;quot;, ALLOWED_METHODS); headers.add(\u0026amp;quot;Access-Control-Max-Age\u0026amp;quot;, MAX_AGE); headers.add(\u0026amp;quot;Access-Control-Allow-Headers\u0026amp;quot;, ALLOWED_HEADERS); headers.add(\u0026amp;quot;Access-Control-Expose-Headers\u0026amp;quot;, ALLOWED_EXPOSE); headers.add(\u0026amp;quot;Access-Control-Allow-Credentials\u0026amp;quot;, \u0026amp;quot;true\u0026amp;quot;); if (request.getMethod() == HttpMethod.OPTIONS) { response.setStatusCode(HttpStatus.OK); return Mono.empty(); } } return chain.filter(exchange); } }   Registering CrossFilter as a Spring Bean and you are ready to go.  Filtering Spring Boot health check  You can control the order by applying @Order to the implementation class .  @Component @Order(-99) public final class HealthFilter implements WebFilter { private static final String[] FILTER_TAG = {\u0026amp;quot;/actuator/health\u0026amp;quot;, \u0026amp;quot;/health_check\u0026amp;quot;}; @Override public Mono\u0026amp;lt;Void\u0026amp;gt; filter(@Nullable final ServerWebExchange exchange, @Nullable final WebFilterChain chain) { ServerHttpRequest request = Objects.requireNonNull(exchange).getRequest(); String urlPath = request.getURI().getPath(); for (String check : FILTER_TAG) { if (check.equals(urlPath)) { String result = JsonUtils.toJson(new Health.Builder().up().build()); DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(result.getBytes()); return exchange.getResponse().writeWith(Mono.just(dataBuffer)); } } return Objects.requireNonNull(chain).filter(exchange); } }  Extending org.dromara.soul.web.filter.AbstractWebFilter  Add a new class and inherit from org.dromara.soul.web.filter.AbstractWebFilter.\n Implement abstract methods of parent class.\n  /** * this is Template Method ,children Implement your own filtering logic. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Boolean\u0026amp;gt;} result：TRUE (is pass)，and flow next filter；FALSE (is not pass) execute …","date":-62135596800,"description":"filter extension","dir":"projects/soul/custom-filter/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"3b04fce8c15fcd4f27afcc519ae4c63a","permalink":"/en/projects/soul/custom-filter/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/soul/custom-filter/","summary":"description  This doc shows a demo for how to extend org.springframework.web.server.WebFliter.  CORS support  org.dromara.soul.bootstrap.cors.CrossFilter is designed for WebFilter implementation.  public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026quot;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026quot;; private static final String ALLOWED_METHODS = \u0026quot;*\u0026quot;; private static final String ALLOWED_ORIGIN = \u0026quot;*\u0026quot;; private static final String ALLOWED_EXPOSE = \u0026quot;*\u0026quot;; private static final String MAX_AGE = \u0026quot;18000\u0026quot;; @Override @SuppressWarnings(\u0026quot;all\u0026quot;) public Mono\u0026lt;Void\u0026gt; filter(final ServerWebExchange exchange, final WebFilterChain chain) { ServerHttpRequest request = exchange.","tags":null,"title":"filter extension","type":"projects","url":"/en/projects/soul/custom-filter/","wordcount":343},{"author":null,"categories":null,"content":" 说明  本文是说明如何进行 org.springframework.web.server.WebFliter 的扩展。  跨域支持  新增 org.dromara.soul.bootstrap.cors.CrossFilter 实现 WebFilter。  public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026amp;quot;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026amp;quot;; private static final String ALLOWED_METHODS = \u0026amp;quot;*\u0026amp;quot;; private static final String ALLOWED_ORIGIN = \u0026amp;quot;*\u0026amp;quot;; private static final String ALLOWED_EXPOSE = \u0026amp;quot;*\u0026amp;quot;; private static final String MAX_AGE = \u0026amp;quot;18000\u0026amp;quot;; @Override @SuppressWarnings(\u0026amp;quot;all\u0026amp;quot;) public Mono\u0026amp;lt;Void\u0026amp;gt; filter(final ServerWebExchange exchange, final WebFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); if (CorsUtils.isCorsRequest(request)) { ServerHttpResponse response = exchange.getResponse(); HttpHeaders headers = response.getHeaders(); headers.add(\u0026amp;quot;Access-Control-Allow-Origin\u0026amp;quot;, ALLOWED_ORIGIN); headers.add(\u0026amp;quot;Access-Control-Allow-Methods\u0026amp;quot;, ALLOWED_METHODS); headers.add(\u0026amp;quot;Access-Control-Max-Age\u0026amp;quot;, MAX_AGE); headers.add(\u0026amp;quot;Access-Control-Allow-Headers\u0026amp;quot;, ALLOWED_HEADERS); headers.add(\u0026amp;quot;Access-Control-Expose-Headers\u0026amp;quot;, ALLOWED_EXPOSE); headers.add(\u0026amp;quot;Access-Control-Allow-Credentials\u0026amp;quot;, \u0026amp;quot;true\u0026amp;quot;); if (request.getMethod() == HttpMethod.OPTIONS) { response.setStatusCode(HttpStatus.OK); return Mono.empty(); } } return chain.filter(exchange); } }   将 CrossFilter 注册成为 spring的bean，完事。  网关过滤 springboot健康检查  注意顺序，使用 @Order 注解  @Component @Order(-99) public final class HealthFilter implements WebFilter { private static final String[] FILTER_TAG = {\u0026amp;quot;/actuator/health\u0026amp;quot;, \u0026amp;quot;/health_check\u0026amp;quot;}; @Override public Mono\u0026amp;lt;Void\u0026amp;gt; filter(@Nullable final ServerWebExchange exchange, @Nullable final WebFilterChain chain) { ServerHttpRequest request = Objects.requireNonNull(exchange).getRequest(); String urlPath = request.getURI().getPath(); for (String check : FILTER_TAG) { if (check.equals(urlPath)) { String result = JsonUtils.toJson(new Health.Builder().up().build()); DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(result.getBytes()); return exchange.getResponse().writeWith(Mono.just(dataBuffer)); } } return Objects.requireNonNull(chain).filter(exchange); } }  继承 org.dromara.soul.web.filter.AbstractWebFilter  新增一个类，继承它。\n 实现它的2个方法。\n  /** * this is Template Method ,children Implement your own filtering logic. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Boolean\u0026amp;gt;} result：TRUE (is pass)，and flow next filter；FALSE (is not pass) execute doDenyResponse(ServerWebExchange exchange) */ protected abstract Mono\u0026amp;lt;Boolean\u0026amp;gt; doFilter(ServerWebExchange exchange, WebFilterChain chain); /** * this is Template Method ,children Implement your own And response client. * * @param exchange the current server exchange. * @return {@code …","date":-62135596800,"description":"filter扩展","dir":"projects/soul/custom-filter/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"3b04fce8c15fcd4f27afcc519ae4c63a","permalink":"/projects/soul/custom-filter/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/custom-filter/","summary":"说明 本文是说明如何进行 org.springframework.web.server.WebFliter 的扩展。 跨域支持 新增 org.dromara.soul.bootstrap.cors.CrossFilter 实现 WebFilter。 public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026quot;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026quot;; private static final String ALLOWED_METHODS = \u0026quot;*\u0026quot;; private static final String ALLOWED_ORIGIN = \u0026quot;*\u0026quot;; private static final","tags":null,"title":"filter扩展","type":"projects","url":"/projects/soul/custom-filter/","wordcount":437},{"author":null,"categories":null,"content":" 说明  本文旨在帮助http用户。\n soul网关使用 divide 插件来处理http请求。请求在soul-admin后台开启它。\n 接入前，请正确的启动 soul-admin，以及 搭建环境 OK。\n  引入网关对http的代理插件  在网关的 pom.xml 文件中增加如下依赖： ```xml  org.dromara soul-spring-boot-starter-plugin-divide ${last.version}    org.dromara soul-spring-boot-starter-plugin-httpclient ${last.version} \n * 当然是要重新启动网关。 ## Http请求接入网关（springMvc体系用户） * 首先要确保在 `soul-admin` 后台 divide插件是否开启。 ##### Soul-Client接入方式。 （此方式针对SpringMvc,SpringBoot用户） * SpringBoot用户 * 在你的真实服务的 `pom.xml` 新增如下依赖: ```xml \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在yml中新增如下配置：\nsoul: http: adminUrl: http://localhost:9095 port: 你本项目的启动端口 contextPath: /http appName: http full: false # adminUrl: 为你启动的soul-admin 项目的ip + 端口，注意要加http:// # port: 你本项目的启动端口 # contextPath: 为你的这个mvc项目在soul网关的路由前缀，这个你应该懂意思把？ 比如/order ，/product 等等，网关会根据你的这个前缀来进行路由. # appName：你的应用名称，不配置的话，会默认取 `spring.application.name` 的值 # full: 设置true 代表代理你的整个服务，false表示代理你其中某几个controller   SpringMvc用户 在你的真实服务的 pom.xml 新增如下依赖： xml \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-client-springmvc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \n  在你的 bean定义的xml文件中新增如下：\n\u0026amp;lt;bean id =\u0026amp;quot;springMvcClientBeanPostProcessor\u0026amp;quot; class =\u0026amp;quot;org.dromara.soul.client.springmvc.init.SpringMvcClientBeanPostProcessor\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;constructor-arg ref=\u0026amp;quot;soulSpringMvcConfig\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;soulSpringMvcConfig\u0026amp;quot; class=\u0026amp;quot;org.dromara.soul.client.springmvc.config.SoulSpringMvcConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;adminUrl\u0026amp;quot; value=\u0026amp;quot;http://localhost:9095\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;port\u0026amp;quot; value=\u0026amp;quot;你的端口\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;contextPath\u0026amp;quot; value=\u0026amp;quot;/你的contextPath\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;appName\u0026amp;quot; value=\u0026amp;quot;你的名字\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;full\u0026amp;quot; value=\u0026amp;quot;false\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;   在你的 controller 的接口上加上 @SoulSpringMvcClient 注解。\n 你可以把注解加到 Controller 类上面，里面的path属性则为前缀，如果含有 /** 代表你的整个接口需要被网关代理。\n 举列子 （1）： 代表 /test/payment，/test/findByUserId 都会被网关代理。\n  @RestController @RequestMapping(\u0026amp;quot;/test\u0026amp;quot;) @SoulSpringMvcClient(path = \u0026amp;quot;/test/**\u0026amp;quot;) public class HttpTestController { @PostMapping(\u0026amp;quot;/payment\u0026amp;quot;) public UserDTO post(@RequestBody final UserDTO userDTO) { return userDTO; } @GetMapping(\u0026amp;quot;/findByUserId\u0026amp;quot;) public UserDTO findByUserId(@RequestParam(\u0026amp;quot;userId\u0026amp;quot;) final String userId) { UserDTO userDTO = new UserDTO(); userDTO.setUserId(userId); userDTO.setUserName(\u0026amp;quot;hello world\u0026amp;quot;); return userDTO; } }   举列子 （2）：代表 /order/save，会被网关代理，而/order/findById 则不会。    @RestController @RequestMapping(\u0026amp;quot;/order\u0026amp;quot;) @SoulSpringMvcClient(path = \u0026amp;quot;/order\u0026amp;quot;) public class OrderController { @PostMapping(\u0026amp;quot;/save\u0026amp;quot;) @SoulSpringMvcClient(path = \u0026amp;quot;/save\u0026amp;quot;) public …","date":-62135596800,"description":"http用户","dir":"projects/soul/http-proxy/","fuzzywordcount":1400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"d146a71ca0bc7f135c805b6f867eec06","permalink":"/projects/soul/http-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/soul/http-proxy/","summary":"说明 本文旨在帮助http用户。 soul网关使用 divide 插件来处理http请求。请求在soul-admin后台开启它。 接入前，请正确的启动 soul-","tags":null,"title":"http用户","type":"projects","url":"/projects/soul/http-proxy/","wordcount":1371},{"author":null,"categories":null,"content":" 说明  hystrix插件是网关用来对流量进行熔断的核心实现。\n 使用信号量的方式来处理请求。\n  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; hystrix，设置为开启。\n 如果用户不使用，则在 soul-admin 后台把此插件停用。\n  插件使用  在网关的 pom.xml 文件中添加 hystrix的支持。 xml \u0026amp;lt;!-- soul hystrix plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-hystrix\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul hystrix plugin end--\u0026amp;gt;  * 选择器和规则，请详细看：选择器规则 * Hystrix处理详解： * 跳闸最小请求数量 ：最小的请求量，至少要达到这个量才会触发熔断 * 错误半分比阀值 ： 这段时间内，发生异常的百分比。 * 最大并发量 ： 最大的并发量 * 跳闸休眠时间(ms) ：熔断以后恢复的时间。 * 分组Key： 一般设置为:contextPath * 命令Key: 一般设置为具体的 路径接口。  ","date":-62135596800,"description":"hystrix插件","dir":"projects/soul/hystrix-plugin/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"dd21ea21247d525c19e330da4718670f","permalink":"/projects/soul/hystrix-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/hystrix-plugin/","summary":"说明 hystrix插件是网关用来对流量进行熔断的核心实现。 使用信号量的方式来处理请求。 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; hystrix，设置为开启。 如","tags":null,"title":"hystrix插件","type":"projects","url":"/projects/soul/hystrix-plugin/","wordcount":295},{"author":null,"categories":null,"content":" 说明  monitor插件是网关用来监控自身运行状态（JVM相关），请求的响应迟延，QPS、TPS等相关metrics。  技术方案  流程图  异步或者同步的方式，在soul网关里面进行 metrics 埋点。\n prometheus 服务端通过 http 请求 来 拉取 metrics，再使用 Grafana 展示。\n  插件设置  在 soul-admin\u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; monitor ,设置为开启。\n 在 monitor 插件中新增以下配置 ```yaml {\u0026amp;ldquo;metricsName\u0026amp;rdquo;:\u0026amp;ldquo;prometheus\u0026amp;rdquo;,\u0026amp;ldquo;host\u0026amp;rdquo;:\u0026amp;ldquo;localhost\u0026amp;rdquo;,\u0026amp;ldquo;port\u0026amp;rdquo;:\u0026amp;ldquo;9191\u0026amp;rdquo;,\u0026amp;ldquo;async\u0026amp;rdquo;:\u0026amp;ldquo;true\u0026amp;rdquo;}\n  port : 为暴露给 prometheus服务来拉取的端口 host : 不填写则为soul网关的host. async :\u0026amp;ldquo;true\u0026amp;rdquo; 为异步埋点， false 为同步埋点  * 如果用户不使用，则在 `soul-admin` 后台把此插件停用。 ## 插件使用 * 在网关的 pom.xml 文件中添加 `monitor` 的支持。 ```xml \u0026amp;lt;!-- soul monitor plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-monitor\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul monitor plugin end--\u0026amp;gt;   选择器和规则，请详细看 : 选择器规则。\n 只有当匹配的url，才会进行url请求埋点。   metrics信息  所有的JVM，线程，内存，等相关信息都会埋点，可以在 Granfana 面板中，新增一个 JVM 模块，则会完全展示 具体请看：https://github.com/prometheus/jmx_exporter\n 另外还有如下自定义的 metrics\n  | 名称 | 类型 |标签名称 | 说明 | |:\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash; |:\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash; |:\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;-|:\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;ndash; | |request_total |Counter | 无 |收集Soul网关所有的请求 | |http_request_total |Counter | path,type |收集monitor插件匹配的请求|\n收集 metrics  用户自己搭建Prometheus 服务，在 prometheus.yml 文件中新增如下配置：  scrape_configs: # The job name is added as a label `job=\u0026amp;lt;job_name\u0026amp;gt;` to any timeseries scraped from this config. - job_name: \u0026#39;shardingSphere-proxy\u0026#39; # metrics_path defaults to \u0026#39;/metrics\u0026#39; # scheme defaults to \u0026#39;http\u0026#39;. static_configs: - targets: [\u0026#39;localhost:9191\u0026#39;]  ## 面板展示\n推荐使用 Grafana，用户可以自定义查询来个性化显示面板盘，后续我会提供默认的面板盘配置。\n","date":-62135596800,"description":"monitor插件","dir":"projects/soul/monitor-plugin/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"b604477fb057cdcecd69bdd9b378a535","permalink":"/projects/soul/monitor-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/soul/monitor-plugin/","summary":"说明 monitor插件是网关用来监控自身运行状态（JVM相关），请求的响应迟延，QPS、TPS等相关metrics。 技术方案 流程图 异步或者同","tags":null,"title":"monitor插件","type":"projects","url":"/projects/soul/monitor-plugin/","wordcount":600},{"author":null,"categories":null,"content":" 首先启动raincat-manager，具体怎么启动参考 启动manager jar包依赖，在你的服务端添加jar包，并在需要参与分布式事务的方法上添加 @TxTransaction注解 \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;raincat-motan\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.0.0-RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Spring XML方式配置 TxTransactionBootstrap \u0026amp;lt;context:component-scan base-package=\u0026amp;quot;org.dromara.*\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;txTransactionBootstrap\u0026amp;quot; class=\u0026amp;quot;org.dromara.raincat.core.bootstrap.TxTransactionBootstrap\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;txManagerUrl\u0026amp;quot; value=\u0026amp;quot;http://localhost:8761\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serializer\u0026amp;quot; value=\u0026amp;quot;kryo\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;nettySerializer\u0026amp;quot; value=\u0026amp;quot;kryo\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;compensation\u0026amp;quot; value=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;compensationCacheType\u0026amp;quot; value=\u0026amp;quot;db\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;txDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;bean class=\u0026amp;quot;org.dromara.raincat.common.config.TxDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;url\u0026amp;quot; value=\u0026amp;quot;jdbc:mysql://192.168.1.98:3306/tx?useUnicode=true\u0026amp;amp;amp;characterEncoding=utf8\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;driverClassName\u0026amp;quot; value=\u0026amp;quot;com.mysql.jdbc.Driver\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;username\u0026amp;quot; value=\u0026amp;quot;root\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;password\u0026amp;quot; value=\u0026amp;quot;123456\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;  Spring boot start方式配置 TxTransactionBootstrap  首先依赖raincat 提供的spring-boot-starter-springcloud\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;raincat-spring-boot-starter-motan\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.0.0-RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   配置 application.yml  org: dromara: raincat: txManagerUrl: http://localhost:8761 serializer: kroy nettySerializer: kroy compensation: true compensationCacheType : db txDbConfig : driverClassName : com.mysql.jdbc.Driver url : jdbc:mysql://192.168.1.98:3306/tx?useUnicode=true\u0026amp;amp;amp;characterEncoding=utf8 username : root password : 123456  txManagerUrl：填写你启动的txManager的ip端口，注意添加http://\n serializer： 是指事务日志的序列化方式\n nettySerializer： 与txManager通信对象的序列化方法，注意与txManager中的序列化方式配置一样。\n compensation ：是否需要补偿，极端情况下，服务自身会进行补偿。\n compensationCacheType： 存储日志类型，当然还有支持redis，mongo，zookeeper等等，具体可以参考 配置详解。\n  配置扫描raincat包，与开启AOP代理（XML方式配置的时候必须加上，starter方式不需要）。 ","date":-62135596800,"description":"motan用户指南","dir":"projects/raincat/motan-user/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"a57a65ee88a164a5d16d1b406ff3d928","permalink":"/projects/raincat/motan-user/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/raincat/motan-user/","summary":"首先启动raincat-manager，具体怎么启动参考 启动manager jar包依赖，在你的服务端添加jar包，并在需要参与分布式事务的方","tags":null,"title":"motan用户指南","type":"projects","url":"/projects/raincat/motan-user/","wordcount":513},{"author":null,"categories":null,"content":" description  This doc shows how to do performance optimization for soul.  time consumption  Soul is JVM driven and processing time for a single request is nearly between 1 - 3 ms.  netty optimization  spring-webflux is one of dependencies of soul, and it uses Netty in lower layer.\n The demo down below demonstrates tuning soul by customizing params in Netty.\n  @Bean public NettyReactiveWebServerFactory nettyReactiveWebServerFactory() { NettyReactiveWebServerFactory webServerFactory = new NettyReactiveWebServerFactory(); webServerFactory.addServerCustomizers(new EventLoopNettyCustomizer()); return webServerFactory; } private static class EventLoopNettyCustomizer implements NettyServerCustomizer { @Override public HttpServer apply(final HttpServer httpServer) { return httpServer .tcpConfiguration(tcpServer -\u0026amp;gt; tcpServer .runOn(LoopResources.create(\u0026amp;quot;soul-netty\u0026amp;quot;, 1, DEFAULT_IO_WORKER_COUNT, true), false) .selectorOption(ChannelOption.SO_REUSEADDR, true) .selectorOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .option(ChannelOption.TCP_NODELAY, true) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)); } }   Soul-bootstrap offers this class, you may modify it when benchmarking your app if necessary.\n You can get references of business thread model from thread model\n  ","date":-62135596800,"description":"performance optimization for soul","dir":"projects/soul/soul-optimize/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"ff4a6aecd7f5d6781cfe3d90159825f7","permalink":"/en/projects/soul/soul-optimize/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/soul-optimize/","summary":"description  This doc shows how to do performance optimization for soul.  time consumption  Soul is JVM driven and processing time for a single request is nearly between 1 - 3 ms.  netty optimization  spring-webflux is one of dependencies of soul, and it uses Netty in lower layer.\n The demo down below demonstrates tuning soul by customizing params in Netty.\n  @Bean public NettyReactiveWebServerFactory nettyReactiveWebServerFactory() { NettyReactiveWebServerFactory webServerFactory = new NettyReactiveWebServerFactory(); webServerFactory.","tags":null,"title":"performance optimization for soul","type":"projects","url":"/en/projects/soul/soul-optimize/","wordcount":133},{"author":null,"categories":null,"content":" Explanation  In our Soul-Admin background, each plugin uses the Handle field to represent a different processing, and plugin processing is used to manage and edit custom processing fields in JSON. This feature is mainly used to support the plug-in handling template configuration  Table design  sql\nCREATE TABLE IF NOT EXISTS `plugin_handle` ( `id` varchar(128) NOT NULL, `plugin_id` varchar(128) NOT NULL COMMENT \u0026#39;plugin id\u0026#39;, `field` varchar(100) NOT NULL COMMENT \u0026#39;field\u0026#39;, `label` varchar(100) DEFAULT NULL COMMENT \u0026#39;label\u0026#39;, `data_type` smallint(6) NOT NULL DEFAULT \u0026#39;1\u0026#39; COMMENT \u0026#39;data type 1 number 2 string 3 select box\u0026#39;, `type` smallint(6) NULL COMMENT \u0026#39;type, 1 means selector, 2 means rule\u0026#39;, `sort` int(4) NULL COMMENT \u0026#39;sort\u0026#39;, `ext_obj` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;extra configuration (json format data)\u0026#39;, `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;create time\u0026#39;, `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;update time\u0026#39;, PRIMARY KEY (`id`), UNIQUE KEY `plugin_id_field_type` (`plugin_id`,`field`,`type`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;  Tutorial eg. When we developed the springCloud plugin, the rule table needed to store some configuration into the handle field, Configure the corresponding entity class as follows:\npublic class SpringCloudRuleHandle implements RuleHandle { /** * this remote uri path. */ private String path; /** * timeout is required. */ private long timeout = Constants.TIME_OUT; } }   step1. We can go directly to the plug-in management link http://localhost:9095/#/system/plugin Click Edit Plugin for processing step2. Add a string type field path and a numeric type TIMEOUT\nstep3. Finally, you can enter path, TIMEOUT and commit to the handle field when you add a rule in the plugin rule configuration page\n_Note: If data_type is configured to be 3 selection box, the input field drop-down selection on the new rule page is displayed by going to the soul_dict） table to find all the options available_\n The Sentinel plug-in, for example, is shown below:  ","date":-62135596800,"description":"plugin handle explanation","dir":"projects/soul/plugin-handle-explanation/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"7dfecb0b1e78397da38ffb4a5d4efd4d","permalink":"/en/projects/soul/plugin-handle-explanation/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/soul/plugin-handle-explanation/","summary":"Explanation  In our Soul-Admin background, each plugin uses the Handle field to represent a different processing, and plugin processing is used to manage and edit custom processing fields in JSON. This feature is mainly used to support the plug-in handling template configuration  Table design  sql\nCREATE TABLE IF NOT EXISTS `plugin_handle` ( `id` varchar(128) NOT NULL, `plugin_id` varchar(128) NOT NULL COMMENT 'plugin id', `field` varchar(100) NOT NULL COMMENT 'field', `label` varchar(100) DEFAULT NULL COMMENT 'label', `data_type` smallint(6) NOT NULL DEFAULT '1' COMMENT 'data type 1 number 2 string 3 select box', `type` smallint(6) NULL COMMENT 'type, 1 means selector, 2 means rule', `sort` int(4) NULL COMMENT 'sort', `ext_obj` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'extra configuration (json format data)', `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'create time', `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'update time', PRIMARY KEY (`id`), UNIQUE KEY `plugin_id_field_type` (`plugin_id`,`field`,`type`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;  Tutorial eg.","tags":null,"title":"plugin handle explanation","type":"projects","url":"/en/projects/soul/plugin-handle-explanation/","wordcount":307},{"author":null,"categories":null,"content":" Explanation  When making invokes to the target service, soul Gateway also allows users to customize the context using the context_path plugin.  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; context_path ,set to enable。\n Introduce context_path support in the pox.xml file of the gateway.\n If the user don\u0026amp;rsquo;t use, please disable the plugin in the background.\n  \u0026amp;lt;!-- soul context_path plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-context-path\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul context_path plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector。  Situation  As the name suggests,the context_path plugin redefines the contextPath of URI.\n When the request is matched, the custom contextPath is set, then the custom contextPath will be intercepted according to the requested Url to obtain the real Url, for example, the request path is \u0026amp;lsquo;/soul/http/order\u0026amp;rsquo;, The configured contextPath is\u0026amp;rsquo;/soul/http\u0026amp;rsquo;, then the requested url is\u0026amp;rsquo;/order\u0026amp;rsquo;.\n  ","date":-62135596800,"description":"context_path plugin","dir":"projects/soul/context-path-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"2767e8857680920fcae77cbe4c3bdf3b","permalink":"/en/projects/soul/context-path-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/context-path-plugin/","summary":"Explanation  When making invokes to the target service, soul Gateway also allows users to customize the context using the context_path plugin.  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; context_path ,set to enable。\n Introduce context_path support in the pox.xml file of the gateway.\n If the user don\u0026rsquo;t use, please disable the plugin in the background.\n  \u0026lt;!-- soul context_path plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-context-path\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.","tags":null,"title":"plugin-context-path-mapping","type":"projects","url":"/en/projects/soul/context-path-plugin/","wordcount":132},{"author":null,"categories":null,"content":" Explanation  Divdid is the core processing plugin for gateway to process http requests.  Plugin Setting  Enable plugin, soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management\u0026amp;ndash;\u0026amp;gt; divide set to enable.\n Divide plugin，cooperate with starter to take effect，please refer to：user-http。\n  \u0026amp;lt;!--if you use http proxy start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-divide\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Plugin Detail  Divide is a plugin for http forward proxy, and all http requests are called by this plugin in load balancing.\n Selectors and rules, please refer to: selector.\n Http configuration is the real invoked configuration after the gateway matches the traffic; You can set multiple configurations and concrete load balancing weights in the rules.\n Configuration Detail ：\n The first box: hostName, generally fill in localhost, which is temporarily unused.\n The second box: http protocol, usually fill in http:// or https://, if not, the default is: http://.\n The third box: ip and port, where you fill in the ip+port of your real service.\n The fourth box: load balancing weight.\n  Ip + Port Detection\n In soul-admin, there is a scheduled task to scan the configured ip and port. If it is found that the ip and port is offline, it will be removed.\n It can be configured as follows:\n    soul.upstream.check:true Default is ture，if setting false，program will not detect soul.upstream.scheduledTime:10 Timing detection interval, default 10 seconds  ","date":-62135596800,"description":"divide plugin","dir":"projects/soul/divide-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"8465c00775647d58b1a1a484e58e20fd","permalink":"/en/projects/soul/divide-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/soul/divide-plugin/","summary":"Explanation  Divdid is the core processing plugin for gateway to process http requests.  Plugin Setting  Enable plugin, soul-admin \u0026ndash;\u0026gt; plugin management\u0026ndash;\u0026gt; divide set to enable.\n Divide plugin，cooperate with starter to take effect，please refer to：user-http。\n  \u0026lt;!--if you use http proxy start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-divide\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin Detail  Divide is a plugin for http forward proxy, and all http requests are called by this plugin in load balancing.","tags":null,"title":"plugin-divide","type":"projects","url":"/en/projects/soul/divide-plugin/","wordcount":215},{"author":null,"categories":null,"content":" Explanation  Dubbo is a plugin that converts http protocol into Dubbo protocol, and it is also the key for gateway to realize dubbo generic service.\n Dubbo plugin needs to cooperate with metadata to realize dubbo calls, please refer to: metaData。\n Apache dubbo and alibaba dubbo users both use the same plugin.\n  \u0026amp;lt;!--if you use dubbo start this--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-alibab-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; dubbo setting enable.\n In the configuration of dubbo plugin, the configuration is as follows: Configure the registration center of dubbo.\n  {\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;zookeeper://localhost:2181\u0026amp;quot;} or {\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;nacos://localhost:8848\u0026amp;quot;}   Plugin needs to cooperate with starter to take effect, please refer to: user-dubbo。\n Selectors and rules, please refer to: selector。\n  Metadata  Every dubbo interface method corresponds to a piece of metadata, which can be found in soul-admin \u0026amp;ndash;\u0026amp;gt;metadata management.\n Path: your http request.\n RPC extension parameters, corresponding to some configurations of dubbo interface; If you want to adjust, please modify here, which support json format like the following fields:\n  {\u0026amp;quot;timeout\u0026amp;quot;:10000,\u0026amp;quot;group\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,version\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;loadbalance\u0026amp;quot;:\u0026amp;quot;\u0026amp;quot;,\u0026amp;quot;retries\u0026amp;quot;:1}  ","date":-62135596800,"description":"dubbo plugin","dir":"projects/soul/dubbo-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"3d2239e5808ce4944a60f1e751374797","permalink":"/en/projects/soul/dubbo-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/dubbo-plugin/","summary":"Explanation  Dubbo is a plugin that converts http protocol into Dubbo protocol, and it is also the key for gateway to realize dubbo generic service.\n Dubbo plugin needs to cooperate with metadata to realize dubbo calls, please refer to: metaData。\n Apache dubbo and alibaba dubbo users both use the same plugin.\n  \u0026lt;!--if you use dubbo start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-alibab-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.","tags":null,"title":"plugin-dubbo","type":"projects","url":"/en/projects/soul/dubbo-plugin/","wordcount":167},{"author":null,"categories":null,"content":" Explanation  Hystrix plugin is the core implementation used by gateway to fuse traffic.\n Use semaphores to process requests.\n  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; hystrix, set to enable.\n If the user don\u0026amp;rsquo;t use, please disable the plugin in the backgroud.\n  Plugin Instruction  Introduce hystrix dependency in the pom.xml file of the gateway. xml \u0026amp;lt;!-- soul hystrix plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-hystrix\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul hystrix plugin end--\u0026amp;gt;  * Selectors and rules, please refer to: selector。 * Hystrix processing details: * Trip minimum request quantity: the minimum request quantity, which must be reached at least before the fuse is triggered * Error half-score threshold: the percentage of exceptions in this period of time. * Maximum concurrency: the maximum concurrency * Trip sleep time (ms): the recovery time after fusing. * Grouping Key: generally set as: contextPath * Command Key: generally set to specific path interface.  ","date":-62135596800,"description":"hystrix plugin","dir":"projects/soul/hystrix-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"dd21ea21247d525c19e330da4718670f","permalink":"/en/projects/soul/hystrix-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/hystrix-plugin/","summary":"Explanation  Hystrix plugin is the core implementation used by gateway to fuse traffic.\n Use semaphores to process requests.\n  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; hystrix, set to enable.\n If the user don\u0026rsquo;t use, please disable the plugin in the backgroud.\n  Plugin Instruction  Introduce hystrix dependency in the pom.xml file of the gateway. xml \u0026lt;!-- soul hystrix plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"plugin-hystrix","type":"projects","url":"/en/projects/soul/hystrix-plugin/","wordcount":147},{"author":null,"categories":null,"content":" Explanation  monitor plugin is used to monitor its own running status(JVM-related) by gateway, include request response delay, QPS, TPS, and other related metrics.  Technical Solutions  Flow Diagram  Make even tracking in soul gateway by asynchronous or synchronous mode.\n The prometheus server pulls metrics\u0026amp;rsquo; through http request, and then displays it by Grafana.\n  Plugin Setting  In soul-admin\u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; monitor, set to enable.\n Add the following configuration in the monitor plugin. ```yaml {\u0026amp;ldquo;metricsName\u0026amp;rdquo;:\u0026amp;ldquo;prometheus\u0026amp;rdquo;,\u0026amp;ldquo;host\u0026amp;rdquo;:\u0026amp;ldquo;localhost\u0026amp;rdquo;,\u0026amp;ldquo;port\u0026amp;rdquo;:\u0026amp;ldquo;9191\u0026amp;rdquo;,\u0026amp;ldquo;async\u0026amp;rdquo;:\u0026amp;ldquo;true\u0026amp;rdquo;}\n  port : Pulled ports for exposing to prometheus service. host : If not filled in, it is the host of soul Gateway. async :\u0026amp;ldquo;true\u0026amp;rdquo; is asynchronous event tracking， false is synchronous event tracking.  * If the user don\u0026#39;t use, please disable the plugin in the backgroud. ## Plugin Setting * Introduce `monitor` dependency in the pom.xml file of the gateway. ```xml \u0026amp;lt;!-- soul monitor plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-monitor\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul monitor plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector。\n Only when the url is matched, the url will request event tracking.   metrics Detail  All JVM，thread，memory，and other related infomation will be made event tracking，you can add a JVM module in the Granfana\u0026amp;rsquo; panel, and it will be fully displayed, please refer to： https://github.com/prometheus/jmx_exporter\n There are also the following custom metrics\n  | Name |type |target | description | |:\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash; |:\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash; |:\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;-|:\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;mdash;\u0026amp;ndash; | |request_total |Counter | none |collecting all requests of Soul Gateway | |http_request_total |Counter | path,type |collecting all matched requests of monitor|\nCollect metrics  Users build their own Prometheus service, and add the following configuration in prometheus.yml file:  scrape_configs: # The job name is added as a label `job=\u0026amp;lt;job_name\u0026amp;gt;` to any timeseries scraped from this config. - job_name: \u0026#39;shardingSphere-proxy\u0026#39; # metrics_path defaults to \u0026#39;/metrics\u0026#39; # scheme defaults to \u0026#39;http\u0026#39;. static_configs: - targets: [\u0026#39;localhost:9191\u0026#39;]  ## Panel Presentation\nIt is recommended to use Grafana\u0026amp;rsquo;. Users can customize the query to personalize the display panel, and we will provide the default configuration panel later.\n","date":-62135596800,"description":"monitor plugin","dir":"projects/soul/monitor-plugin/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"b604477fb057cdcecd69bdd9b378a535","permalink":"/en/projects/soul/monitor-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/soul/monitor-plugin/","summary":"Explanation  monitor plugin is used to monitor its own running status(JVM-related) by gateway, include request response delay, QPS, TPS, and other related metrics.  Technical Solutions  Flow Diagram  Make even tracking in soul gateway by asynchronous or synchronous mode.\n The prometheus server pulls metrics\u0026rsquo; through http request, and then displays it by Grafana.\n  Plugin Setting  In soul-admin\u0026ndash;\u0026gt; plugin management-\u0026gt; monitor, set to enable.","tags":null,"title":"plugin-monitor","type":"projects","url":"/en/projects/soul/monitor-plugin/","wordcount":316},{"author":null,"categories":null,"content":" Explanation  rateLimiter is core implementation of gateway restrictions on network traffic.\n You can set to the interface level or the parameter level. How to use it depends on your traffic configuration.\n  Technical Solution  Using redis token bucket algorithm to limit traffic.\n Flow Diagram：   Plugin Setting  In soul-admin\u0026amp;ndash;\u0026amp;gt; plugin management\u0026amp;ndash;\u0026amp;gt; rate_limiter set to enable.\n Configure redis in the plugin.\n Currently, supporting redis patterns of single, sentinel, and cluster.\n If it is a sentinel, cluster and other multi-node configuration in URL, please use ; for each instance; Division. For example, 192.168.1.1:6379; 192.168.1.2:6379。\n If the user don\u0026amp;rsquo;t use, please disable the plugin in the backgroud.\n  Plugin Detail  Introduce rateLimiter dependency in pom.xml file of the gateway.  \u0026amp;lt;!-- soul ratelimiter plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-ratelimiter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul ratelimiter plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector。\n Rate: It is how many requests you allow users to execute per second, while not discarding any requests. This is the filling rate of token bucket.\n Capacity: it is the maximum number of requests that users are allowed to execute in one second. This is token bucket can save the number of token.\n  ","date":-62135596800,"description":"rateLimiter plugin","dir":"projects/soul/rateLimiter-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"2f41ba6c389a33233f78365058ecd5e9","permalink":"/en/projects/soul/ratelimiter-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/ratelimiter-plugin/","summary":"Explanation  rateLimiter is core implementation of gateway restrictions on network traffic.\n You can set to the interface level or the parameter level. How to use it depends on your traffic configuration.\n  Technical Solution  Using redis token bucket algorithm to limit traffic.\n Flow Diagram：   Plugin Setting  In soul-admin\u0026ndash;\u0026gt; plugin management\u0026ndash;\u0026gt; rate_limiter set to enable.\n Configure redis in the plugin.\n Currently, supporting redis patterns of single, sentinel, and cluster.","tags":null,"title":"plugin-rateLimiter","type":"projects","url":"/en/projects/soul/ratelimiter-plugin/","wordcount":188},{"author":null,"categories":null,"content":" Explanation  resilience4j is one of the options that supports flow control and circuit breaking.\n resilience4j supports flow control and circuit breaking functions for gateway.\n  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; resilience4j set to enable.\n If you don\u0026amp;rsquo;t want to use it, please close the plugin in soul-admin.\n  Plugin Usage  Introducing the follow supports to the pom.xml file of soul project. xml \u0026amp;lt;!-- soul resilience4j plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-resilience4j\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul resilience4j plugin end--\u0026amp;gt;  * Selectors and rules, please refer to: selector * Resilience4j Processing Details * timeoutDurationRate ：Configures wait time(ms) a thread waits for a permission,default value:5000。 * limitRefreshPeriod ：Configures the period of a limit refresh. After each period the rate limiter sets its permissions count back to the limitForPeriod value,default value:500。 * limitForPeriod ：Configures the number of permissions available during one limit refresh period,default value:50。 * circuitEnable ：Configures circuitBreaker enable,0:OFF,1:ON ,default value:0。 * timeoutDuration ：Configures request CircuitBreaker timeout(ms),default value:30000。 * fallbackUri ：Configures the fall back uri。 * slidingWindowSize ：Configures the size of the sliding window which is used to record the outcome of calls when the CircuitBreaker is closed,default value:100。 * slidingWindowType ：Configures the type of the sliding window which is used to record the outcome of calls when the CircuitBreaker is closed, Sliding window can either be 0:count-based or 1:time-based.,default value:0。 * minimumNumberOfCalls ：Configures the minimum number of calls which are required (per sliding window period) before the CircuitBreaker can calculate the error rate or slow call rate,default value:100。 * waitIntervalFunctionInOpenState ：Configures the circuitBreaker time(ms) of duration,default value:10。 * permittedNumberOfCallsInHalfOpenState ：Configures the number of permitted calls when the CircuitBreaker is half open,default value:10。 * failureRateThreshold ：Configures the failure rate threshold in percentage,When the failure rate is equal or greater than the threshold the CircuitBreaker transitions to open and starts short-circuiting calls,default value:50。 * automaticTransitionFromOpenToHalfOpenEnabled ：Configures automatically transition from open state to half open state,true:ON,false:OFF,default value:false。  ","date":-62135596800,"description":"resilience4j plugin","dir":"projects/soul/resilience4j-plugin/","fuzzywordcount":400,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"44bd32d78ab30402696835a07372ab46","permalink":"/en/projects/soul/resilience4j-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/soul/resilience4j-plugin/","summary":"Explanation  resilience4j is one of the options that supports flow control and circuit breaking.\n resilience4j supports flow control and circuit breaking functions for gateway.\n  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; resilience4j set to enable.\n If you don\u0026rsquo;t want to use it, please close the plugin in soul-admin.\n  Plugin Usage  Introducing the follow supports to the pom.xml file of soul project.","tags":null,"title":"plugin-resilience4j","type":"projects","url":"/en/projects/soul/resilience4j-plugin/","wordcount":312},{"author":null,"categories":null,"content":" Explanation  When making proxy invokes to the target service, soul Gateway also allows users to rewrite the request path using the rewrite plugin.  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; rewrite ,set to enable。\n Introduce rewrite support in the pox.xml file of the gateway.\n If the user don\u0026amp;rsquo;t use, please disable the plugin in the backgroud.\n  \u0026amp;lt;!-- soul rewrite plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-rewrite\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul rewrite plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector。\n Only those matched request will be rewritten.   Situation  As the name suggests, rewrite is a redefinition of URI.\n When the request is matched, set the user-defined path, and the user-defined path will overwrite the previous real path.\n When invoking, the user-defined path will be used.\n  ","date":-62135596800,"description":"rewrite plugin","dir":"projects/soul/rewrite-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"9130dda84c4eaa66b8bf9cad50035388","permalink":"/en/projects/soul/rewrite-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/rewrite-plugin/","summary":"Explanation  When making proxy invokes to the target service, soul Gateway also allows users to rewrite the request path using the rewrite plugin.  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; rewrite ,set to enable。\n Introduce rewrite support in the pox.xml file of the gateway.\n If the user don\u0026rsquo;t use, please disable the plugin in the backgroud.\n  \u0026lt;!-- soul rewrite plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"plugin-rewrite","type":"projects","url":"/en/projects/soul/rewrite-plugin/","wordcount":124},{"author":null,"categories":null,"content":" Explanation  Sentinel is one of the options that supports flow control and circuit breaking.\n Sentinel supports flow control and circuit breaking functions for gateway.\n  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; sentinel set to enable.\n If you don\u0026amp;rsquo;t want to use it, please close the plugin in soul-admin.\n  Plugin Usage  Introducing the follow supports to the pom.xml file of soul project. xml \u0026amp;lt;!-- soul sentinel plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sentinel\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul sentinel plugin end--\u0026amp;gt;  * Selectors and rules, please refer to: selector * Sentinel Processing Details * Whether open flow control(1 or 0): whether enable sentinel flow control function. * Traffic shaping control behavior: effect(reject directly/ queue/ slow start up), it do not support flow control by invocation relation. * Type of threshold of flow control: type of current limit threshold(QPS or Thread Count)。 * Whether open circuit breaking(1 or 0): whether enable circuit breaking function of sentinel. * Type of circuit breaker: circuit breaker strategy, support RT of seconds level/ Error Ratio of seconds level/ Error Count of minutes level strategy. * Circuit breaking threshold: threshold. * Size of circuit breaking window: time of degrading(unit: second). * URI of circuit breaking: degraded uri after circuit breaking.  ","date":-62135596800,"description":"sentinel plugin","dir":"projects/soul/sentinel-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"6fb3cca6f5e5a8158a0703b25c22fcaa","permalink":"/en/projects/soul/sentinel-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/sentinel-plugin/","summary":"Explanation  Sentinel is one of the options that supports flow control and circuit breaking.\n Sentinel supports flow control and circuit breaking functions for gateway.\n  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; sentinel set to enable.\n If you don\u0026rsquo;t want to use it, please close the plugin in soul-admin.\n  Plugin Usage  Introducing the follow supports to the pom.xml file of soul project.","tags":null,"title":"plugin-sentinel","type":"projects","url":"/en/projects/soul/sentinel-plugin/","wordcount":201},{"author":null,"categories":null,"content":" Explanation  Sign is a native plugin of soul Gateway and is used to process signature authentication of requests.  Plugin Setting  In soul-admin -\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; sign set to enable.  Plugin Usage  Introducing sign dependency in the pom.xml file of the gateway  \u0026amp;lt;!-- soul sign plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sign\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul sign plugin end--\u0026amp;gt;   Selectors and rules, please refer to: selector。\n Only those matched requests can be authenticated by signature.\n   Add AK/SK  In soul-admin \u0026amp;ndash;\u0026amp;gt; In authentication management, click Add to add a new AK/SK。  Implementation of Gateway Technology  Adopt Ak/SK authentication technical scheme. Adopt authentication plug-in and Chain of Responsibility Pattern to realize. Take effect when the authentication plugin is enabled and all interfaces are configured for authentication.  ## Authentication Guide\n Step 1: AK/SK is assigned by the gateway. For example, the AK assigned to you is: 1test123456781 SK is: ` 506eeb535cf740d7a755cb49f4a1536\u0026amp;rsquo;\n Step 2: Decide the gateway path you want to access, such as ` /api/service/abc\u0026amp;rsquo;\n Step 3: Construct parameters (the following are general parameters)\n     Field Value Description     timestamp current timestamp(String) The number of milliseconds of the current time（gateway will filter requests the before 5 minutes）   path /api/service/abc The path that you want to request(Modify by yourself according to your configuration of gateway)   version 1.0.0 1.0.0 is a fixed value ，String    Sort the above two field natually according to the key, then splice fields and fields, finally splice SK. The following is a code example.\nStep 1: First, construct a Map.\nMap\u0026amp;lt;String, String\u0026amp;gt; map = Maps.newHashMapWithExpectedSize(2); //timestamp is string format of millisecond. String.valueOf(LocalDateTime.now().toInstant(ZoneOffset.of(\u0026amp;quot;+8\u0026amp;quot;)).toEpochMilli()) map.put(\u0026amp;quot;timestamp\u0026amp;quot;,\u0026amp;quot;1571711067186\u0026amp;quot;); // Value should be string format of milliseconds map.put(\u0026amp;quot;path\u0026amp;quot;, \u0026amp;quot;/api/service/abc\u0026amp;quot;); map.put(\u0026amp;quot;version\u0026amp;quot;, \u0026amp;quot;1.0.0\u0026amp;quot;);  Step 2: Sort the Keys naturally, then splice the key and values, and finally splice the SK assigned to you.\nList\u0026amp;lt;String\u0026amp;gt; storedKeys = Arrays.stream(map.keySet() .toArray(new String[]{})) .sorted(Comparator.naturalOrder()) .collect(Collectors.toList()); final String sign = storedKeys.stream() .map(key -\u0026amp;gt; String.join(\u0026amp;quot;\u0026amp;quot;, key, params.get(key))) .collect(Collectors.joining()).trim() .concat(\u0026amp;quot;506EEB535CF740D7A755CB4B9F4A1536\u0026amp;quot;);   The returned sign value should be:path/api/service/abctimestamp1571711067186version1.0.0506EEB535CF740D7A755CB4B9F4A1536  Step 3: Md5 encryption and then capitalization.\nDigestUtils.md5DigestAsHex(sign.getBytes()).toUpperCase()   The final returned …","date":-62135596800,"description":"sign plugin","dir":"projects/soul/sign-plugin/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"a9673b8e1db9e7155e89cd972a0324a8","permalink":"/en/projects/soul/sign-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/en/projects/soul/sign-plugin/","summary":"Explanation  Sign is a native plugin of soul Gateway and is used to process signature authentication of requests.  Plugin Setting  In soul-admin -\u0026gt; plugin management \u0026ndash;\u0026gt; sign set to enable.  Plugin Usage  Introducing sign dependency in the pom.xml file of the gateway  \u0026lt;!-- soul sign plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-sign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- soul sign plugin end--\u0026gt;   Selectors and rules, please refer to: selector。","tags":null,"title":"plugin-sign","type":"projects","url":"/en/projects/soul/sign-plugin/","wordcount":414},{"author":null,"categories":null,"content":" Explanation  This plugin is the core of transforming http protocol into springCloud protocol.  Introducing Plugin Support of SpringCould Gateway  Introducing those dependencies in the pom.xml file of the gateway.  \u0026amp;lt;!--soul springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul springCloud plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; springCloud ,set to enable.\n This plugin needs to cooperate with starter dependency, please refer to:user-spring.\n Selectors and rules, please refer to: selector。\n  Detail  Application name: it is your specific application name that needs to be invoked after the conditions are matched.\n Soul will obtain the real IP of the corresponding service and initiate http proxy calls from registration center of springCloud.\n  ","date":-62135596800,"description":"springcloud plugin","dir":"projects/soul/spring-cloud-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"804a8247c5ac2055858fdc625ee12087","permalink":"/en/projects/soul/spring-cloud-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/spring-cloud-plugin/","summary":"Explanation  This plugin is the core of transforming http protocol into springCloud protocol.  Introducing Plugin Support of SpringCould Gateway  Introducing those dependencies in the pom.xml file of the gateway.  \u0026lt;!--soul springCloud plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--soul springCloud plugin end--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-commons\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management-\u0026gt; springCloud ,set to enable.","tags":null,"title":"plugin-springcloud","type":"projects","url":"/en/projects/soul/spring-cloud-plugin/","wordcount":125},{"author":null,"categories":null,"content":" Explanation  Waf is the core implementation of gateway to realize firewall function for network traffic.  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management-\u0026amp;gt; waf set to enable.\n If the user don\u0026amp;rsquo;t use, please disable the plugin in the backgroud.\n Add configuration mode in plugin editing.\n{\u0026amp;quot;model\u0026amp;quot;:\u0026amp;quot;black\u0026amp;quot;} # The default mode is blacklist mode; If setting is mixed, it will be mixed mode. We will explain it specifically below.  Plugin Setting  Introducing waf dependency in the pom.xml of the gateway.  \u0026amp;lt;!-- soul waf plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-waf\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul waf plugin end--\u0026amp;gt;  Selectors and rules, please refer to : selector\n When module is set to black mode, only the matched traffic will execute the rejection policy, and the unmatched traffic will be skipped directly.\n When module\u0026amp;rsquo; is set to mixed\u0026amp;rsquo; mode, all traffic will pass through waf plugin. For different matching traffic, users can set whether to reject or pass.\n   Situation  Waf is also the pre-plugin of soul, which is mainly used to intercept illegal requests or exception requests and give relevant rejection policies.\n When faced with replay attacks, you can intercept illegal ip and host, and set reject strategy according to matched ip or host.\n How to determine ip and host, please refer to:dev-iphost\n  ","date":-62135596800,"description":"waf plugin","dir":"projects/soul/waf-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"d175f0c39ea54f421cd2d98ad556c59a","permalink":"/en/projects/soul/waf-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/waf-plugin/","summary":"Explanation  Waf is the core implementation of gateway to realize firewall function for network traffic.  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management-\u0026gt; waf set to enable.\n If the user don\u0026rsquo;t use, please disable the plugin in the backgroud.\n Add configuration mode in plugin editing.\n{\u0026quot;model\u0026quot;:\u0026quot;black\u0026quot;} # The default mode is blacklist mode; If setting is mixed, it will be mixed mode. We will explain it specifically below.","tags":null,"title":"plugin-waf","type":"projects","url":"/en/projects/soul/waf-plugin/","wordcount":206},{"author":null,"categories":null,"content":" Explanation  Soul gateway also support proxy of websocket.\n In websocket support, divide plugin is used in it.\n  Plugin Setting  In soul-admin \u0026amp;ndash;\u0026amp;gt; plugin management \u0026amp;ndash;\u0026amp;gt; divide, set to enable.\n Introducing dependencies in the pom.xml file of the gateway ```xml  org.dromara soul-spring-boot-starter-plugin-divide ${last.version} \n   org.dromara soul-spring-boot-starter-plugin-httpclient ${last.version} \n## Request Path * When using soul proxy websocket, its request path is (example):`ws://localhost:9195/?module=ws\u0026amp;amp;method=/websocket\u0026amp;amp;rpcType=websocket`. ```yaml Detail: 1.localhost:8080 Is the IP and port started by soul. 2.module（Required）:Value is the key that matching selector. 3.method （Parameter）: Your websocket path is also used as a matching rule. 4.rpcType ：websocket must be filled in，and must be websocket   Add a new configuration to the selector in the divide plugin, as follows   Add a new rule in this selector:   In summary, pay attention to your path at this time ws://localhost:9195/?module=ws\u0026amp;amp;method=/websocket\u0026amp;amp;rpcType=websocket.   It will be matched by your new selector rule, and then the real websocket address of the proxy is:127.0.0.1:8080/websocket,so that soul can proxy websocket.\nYou can communicate with websocket service, it is actually very simple.\n I would like to add just one last word that you can decide the name and value of module and method by yourself as long as the selector and the rule can match, this is just an example,  ","date":-62135596800,"description":"websocket plugin","dir":"projects/soul/websocket-plugin/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"46f34e44018715aa860dfb5871c3b53d","permalink":"/en/projects/soul/websocket-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/websocket-plugin/","summary":"Explanation  Soul gateway also support proxy of websocket.\n In websocket support, divide plugin is used in it.\n  Plugin Setting  In soul-admin \u0026ndash;\u0026gt; plugin management \u0026ndash;\u0026gt; divide, set to enable.\n Introducing dependencies in the pom.xml file of the gateway ```xml  org.dromara soul-spring-boot-starter-plugin-divide ${last.version} \n   org.dromara soul-spring-boot-starter-plugin-httpclient ${last.version} \n## Request Path * When using soul proxy websocket, its request path is (example):`ws://localhost:9195/?","tags":null,"title":"plugin-websocket","type":"projects","url":"/en/projects/soul/websocket-plugin/","wordcount":202},{"author":null,"categories":null,"content":" description  Plugins are core executors of soul gateway. Every plugin handles matched requests when enabled.\n There are two kinds of plugins in the soul gateway:\n The first type is a call chain with a single responsibility, and traffic cannot be customized.\n The other one can do its own chain of responsibility for matched traffic.\n  You could reference from soul-plugin module and develop plugins by yourself. Please fire pull requests of your wonderful plugins without hesitate.\n  single responsibility plugins  Add following dependency:\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-plugin-api\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Declare a new class named \u0026amp;ldquo;A\u0026amp;rdquo; and implements org.dromara.soul.plugin.api.SoulPlugin\n  public interface SoulPlugin { /** * Process the Web request and (optionally) delegate to the next * {@code WebFilter} through the given {@link SoulPluginChain}. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Void\u0026amp;gt;} to indicate when request processing is complete */ Mono\u0026amp;lt;Void\u0026amp;gt; execute(ServerWebExchange exchange, SoulPluginChain chain); /** * return plugin order . * This attribute To determine the plugin execution order in the same type plugin. * * @return int order */ int getOrder(); /** * acquire plugin name. * this is plugin name define you must offer the right name. * if you impl AbstractSoulPlugin this attribute not use. * * @return plugin name. */ default String named() { return \u0026amp;quot;\u0026amp;quot;; } /** * plugin is execute. * if return true this plugin can not execute. * * @param exchange the current server exchange * @return default false. */ default Boolean skip(ServerWebExchange exchange) { return false; } }   Detailed instruction of interface methods:\n execute() core method, you can do any task here freely.\n getOrder() get the order of current plugin.\n named() acquire the name of specific plugin.\n skip() determines whether this plugin should be skipped under certain conditions.\n  Register plugin in Spring as a Bean, or simply apply @Component in implementation class.\n  @Bean public SoulPlugin a() { return new A(); }  Matching traffic processing plugin  Introduce the following dependency:\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-plugin-base\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add a new class A, inherit from org.dromara.soul.plugin.base.AbstractSoulPlugin\n examples down below:\n  /** * This is your custom plugin. * He is running in after before plugin, implement your own functionality. * extends AbstractSoulPlugin so you must user soul-admin And add related plug-in development. * * @author xiaoyu(Myth) */ public class CustomPlugin extends AbstractSoulPlugin { /** * return plugin order . * The same plugin he executes in the same order. * * @return int …","date":-62135596800,"description":"plugins","dir":"projects/soul/custom-plugin/","fuzzywordcount":900,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"ea7d6dfc24653d73e785007935508cf7","permalink":"/en/projects/soul/custom-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":5,"relpermalink":"/en/projects/soul/custom-plugin/","summary":"description  Plugins are core executors of soul gateway. Every plugin handles matched requests when enabled.\n There are two kinds of plugins in the soul gateway:\n The first type is a call chain with a single responsibility, and traffic cannot be customized.\n The other one can do its own chain of responsibility for matched traffic.\n  You could reference from soul-plugin module and develop plugins by yourself.","tags":null,"title":"plugins","type":"projects","url":"/en/projects/soul/custom-plugin/","wordcount":886},{"author":null,"categories":null,"content":" 说明  限流插件，是网关对流量管控限制核心的实现。\n 可以到接口级别，也可以到参数级别，具体怎么用，还得看你对流量配置。\n  技术方案  采用redis令牌桶算法进行限流。\n 流程图：   插件设置  在 soul-admin\u0026amp;ndash;\u0026amp;gt; 插件管理\u0026amp;ndash;\u0026amp;gt; rate_limiter 将其设置为开启。\n 在插件中，对redis进行配置。\n 目前支持redis的单机，哨兵，以及集群模式。\n 如果是哨兵，集群等多节点的，在URL中的配置，请对每个实列使用 ; 分割. 如 192.168.1.1:6379;192.168.1.2:6379。\n 如果用户无需使用，在admin后台把插件禁用。\n  插件使用  在网关的 pom.xml 文件中添加 rateLimiter的支持。  \u0026amp;lt;!-- soul ratelimiter plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-ratelimiter\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul ratelimiter plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。\n 速率：是你允许用户每秒执行多少请求，而丢弃任何请求。这是令牌桶的填充速率。\n 容量：是允许用户在一秒钟内执行的最大请求数。这是令牌桶可以保存的令牌数。\n  ","date":-62135596800,"description":"rateLimiter插件","dir":"projects/soul/rateLimiter-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"2f41ba6c389a33233f78365058ecd5e9","permalink":"/projects/soul/ratelimiter-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/ratelimiter-plugin/","summary":"说明 限流插件，是网关对流量管控限制核心的实现。 可以到接口级别，也可以到参数级别，具体怎么用，还得看你对流量配置。 技术方案 采用redis令牌桶","tags":null,"title":"rateLimiter插件","type":"projects","url":"/projects/soul/ratelimiter-plugin/","wordcount":378},{"author":null,"categories":null,"content":" 说明  resilience4j插件是网关用来对流量进行限流与熔断的可选选择之一。\n resilience4j为网关熔断限流提供能力。\n  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; resilience4j，设置为开启。\n 如果用户不使用，则在 soul-admin 后台把此插件停用。\n  插件使用  在网关的 pom.xml 文件中添加 resilience4j的支持。 xml \u0026amp;lt;!-- soul resilience4j plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-resilience4j\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul resilience4j plugin end--\u0026amp;gt;  * 选择器和规则，请详细看：选择器规则 * Resilience4j处理详解： * timeoutDurationRate：等待获取令牌的超时时间，单位ms，默认值：5000。 * limitRefreshPeriod：刷新令牌的时间间隔，单位ms，默认值：500。 * limitForPeriod：每次刷新令牌的数量，默认值：50。 * circuitEnable：是否开启熔断，0：关闭，1：开启，默认值：0。 * timeoutDuration：熔断超时时间，单位ms，默认值：30000。 * fallbackUri：降级处理的uri。 * slidingWindowSize：滑动窗口大小，默认值：100。 * slidingWindowType：滑动窗口类型，0：基于计数，1：基于时间，默认值：0。 * minimumNumberOfCalls：开启熔断的最小请求数，超过这个请求数才开启熔断统计，默认值：100。 * waitIntervalFunctionInOpenState：熔断器开启持续时间，单位ms，默认值：10。 * permittedNumberOfCallsInHalfOpenState：半开状态下的环形缓冲区大小，必须达到此数量才会计算失败率，默认值：10。 * failureRateThreshold：错误率百分比，达到这个阈值，熔断器才会开启，默认值50。 * automaticTransitionFromOpenToHalfOpenEnabled：是否自动从open状态转换为half-open状态，,true：是，false：否，默认值：false。  ","date":-62135596800,"description":"resilience4j插件","dir":"projects/soul/resilience4j-plugin/","fuzzywordcount":900,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"44bd32d78ab30402696835a07372ab46","permalink":"/projects/soul/resilience4j-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/soul/resilience4j-plugin/","summary":"说明 resilience4j插件是网关用来对流量进行限流与熔断的可选选择之一。 resilience4j为网关熔断限流提供能力。 插件设置 在 soul-admin \u0026ndash;\u0026gt;","tags":null,"title":"resilience4j插件","type":"projects","url":"/projects/soul/resilience4j-plugin/","wordcount":832},{"author":null,"categories":null,"content":" 说明  soul网关在对目标服务进行代理调用的时候，还容许用户使用 rewrite 插件来重写请求路径  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; rewrite，设置为开启。\n 在网关的 pom.xml 文件中添加 rewrite 的支持。\n 如果用户不需要，可以把插件禁用。\n  \u0026amp;lt;!-- soul rewrite plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-rewrite\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul rewrite plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。\n 只有匹配的请求，才会进行重写。   场景  顾名思义，重新插件就是对uri的重新定义。\n 当匹配到请求后，设置自定义的路径，那么自定义的路径就会覆盖之前的真实路径。\n 在调用的时候，就会使用用户自定义的路径。\n  ","date":-62135596800,"description":"rewrite插件","dir":"projects/soul/rewrite-plugin/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"9130dda84c4eaa66b8bf9cad50035388","permalink":"/projects/soul/rewrite-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/rewrite-plugin/","summary":"说明 soul网关在对目标服务进行代理调用的时候，还容许用户使用 rewrite 插件来重写请求路径 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; rewrite，设置为开启。 在网关","tags":null,"title":"rewrite插件","type":"projects","url":"/projects/soul/rewrite-plugin/","wordcount":226},{"author":null,"categories":null,"content":" Features  selector and rule are the key point of soul gateway, you can manage any request with it.\n this chapter is mainly focus on the concepts of selector and rule and how to use it.\n  overview  one plugin has many selector and a selector has many rules, selector is the first filter of request, and the rule is the final filter.\n pls consider this, it would be perfect when the plugin executes the request until it reached the config value.\n selector and rule are designed to execute only when the request meet the specific condition.\n pls refer to the previous data structure database design.\n  selector  selector detailed explanation：\n name：create your selector with a distinguish name. type：custom flow is customized request, full flow is full request. customized request will be handled by the conditions as below, while full request won\u0026amp;rsquo;t. match method: you can combine these conditions with \u0026amp;lsquo;and\u0026amp;rsquo; , \u0026amp;lsquo;or\u0026amp;rsquo; operators. condition：  uri: filter request with uri method and support fuzzy matching (/**). header: filter request with request header. query: filter request with query string. ip: filter request with your real ip. host: filter request with your real host. post: not recommend to use. condition match:  match : fuzzy string matching，recommend to combine with uri，support restful matching.（/test/**). = : if the values are the same, then they match. regEx : regex matching，match characters in regex expression. like : string fuzzy matching.   open option：only work with enabled. print log：it will print the matching log with the open option enabled. execution order：the smaller will have high priorty to execute among multi-selectors.   the above picture means: when the prefix of the request uri is /test and the value of module inheader istest, it will redirect to this service 1.1.1.1:8080.\n selector advice : combine uri conditon and match prefix（/contextPath）as the first request filter.\n  rule  when the request was passed by the seletor, then it will be processed by the rule, the final filter.\n rule is the final confirmation about how to execute request logically.\n rule detailed explanation：\n name：create your rule with a distinguish name. match method: you can combine these conditions with \u0026amp;lsquo;and\u0026amp;rsquo; , \u0026amp;lsquo;or\u0026amp;rsquo; operators. condition：  uri: filter request with uri method and support fuzzy matching (/**). header: filter request with request header. query: filter request with query string. ip: filter request with your real ip. host: filter request with your real host. post: not recommend to use. condition match:  match : fuzzy string matching，recommend to combine with uri，support restful matching.（/test/**） = : if the values are the same, then they match. regEx : regex matching，match characters in regex expression. like : string fuzzy matching.   open option：only work with enabled. print log：it will print the matching log with the open option enabled. execution order：the smaller will have high priorty to execute among …","date":-62135596800,"description":"detailed explanation of selector and rule","dir":"projects/soul/selector-and-rule/","fuzzywordcount":800,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"895f00be71b81b881903c5d1173025f2","permalink":"/en/projects/soul/selector-and-rule/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/en/projects/soul/selector-and-rule/","summary":"Features  selector and rule are the key point of soul gateway, you can manage any request with it.\n this chapter is mainly focus on the concepts of selector and rule and how to use it.\n  overview  one plugin has many selector and a selector has many rules, selector is the first filter of request, and the rule is the final filter.\n pls consider this, it would be perfect when the plugin executes the request until it reached the config value.","tags":null,"title":"selector detailed explanation","type":"projects","url":"/en/projects/soul/selector-and-rule/","wordcount":747},{"author":null,"categories":null,"content":" 说明  sentinel插件是网关用来对流量进行限流与熔断的可选选择之一。\n sentinel为网关熔断限流提供能力。\n  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; sentinel，设置为开启。\n 如果用户不使用，则在 soul-admin 后台把此插件停用。\n  插件使用  在网关的 pom.xml 文件中添加 sentinel的支持。 xml \u0026amp;lt;!-- soul sentinel plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sentinel\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul sentinel plugin end--\u0026amp;gt;  * 选择器和规则，请详细看：选择器规则 * Sentinel处理详解： * 是否开启流控(1或0) ：是否开启sentinel的流控。 * 流控效果 ： 流控效果（直接拒绝 / 排队等待 / 慢启动模式），不支持按调用关系限流。 * 限流阈值类型 ： 限流阈值类型，QPS 或线程数模式。 * 是否开启熔断(1或0) ：是否开启sentinel熔断。 * 熔断类型： 熔断策略，支持秒级 RT/秒级异常比例/分钟级异常数。 * 熔断阈值: 阈值。 * 熔断窗口大小: 降级的时间，单位为 s。 * 熔断URI: 熔断后的降级uri。  ","date":-62135596800,"description":"sentinel插件","dir":"projects/soul/sentinel-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"6fb3cca6f5e5a8158a0703b25c22fcaa","permalink":"/projects/soul/sentinel-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/sentinel-plugin/","summary":"说明 sentinel插件是网关用来对流量进行限流与熔断的可选选择之一。 sentinel为网关熔断限流提供能力。 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; sen","tags":null,"title":"sentinel插件","type":"projects","url":"/projects/soul/sentinel-plugin/","wordcount":374},{"author":null,"categories":null,"content":" 说明  sign插件是 soul网关自带的，用来对请求进行签名认证的插件。  插件设置  在 soul-admin -\u0026amp;gt; 插件管理中 \u0026amp;ndash;\u0026amp;gt; sign插件设置为开启。  插件使用  在网关的 pom.xml 文件中添加 sign 的支持。  \u0026amp;lt;!-- soul sign plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sign\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul sign plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则。\n 只有匹配的请求，才会进行签名认证。   新增 AK/SK  在soul-admin \u0026amp;ndash;\u0026amp;gt; 认证管理中，点击新增，新增一条 AK/SK。  网关技术实现  采用Ak/SK鉴权技术方案。 采用鉴权插件，责任链的模式的模式来完成。 当鉴权插件开启，并配置所有接口鉴权时候生效。  ## 鉴权使用指南\n 第一步：AK/SK由网关来进行分配，比如分配给你的AK为: 1TEST123456781 SK为：506EEB535CF740D7A755CB4B9F4A1536\n 第二步：确定好你要访问的网关路径 比如 /api/service/abc\n 第三步：构造参数（以下是通用参数）\n     字段 值 描述     timestamp 当前时间戳(String类型) 当前时间的毫秒数（网关会过滤掉5分钟之前的请求）   path /api/service/abc 就是你需要访问的接口路径(根据你访问网关接口自己变更)   version 1.0.0 目前定位1.0.0 写死，String类型    对上述2个字段进行key的自然排序，然后进行字段与字段值拼接最后再拼接上SK，代码示例。\n第一步：首先构造一个Map。\nMap\u0026amp;lt;String, String\u0026amp;gt; map = Maps.newHashMapWithExpectedSize(2); //timestamp为毫秒数的字符串形式 String.valueOf(LocalDateTime.now().toInstant(ZoneOffset.of(\u0026amp;quot;+8\u0026amp;quot;)).toEpochMilli()) map.put(\u0026amp;quot;timestamp\u0026amp;quot;,\u0026amp;quot;1571711067186\u0026amp;quot;); //值应该为毫秒数的字符串形式 map.put(\u0026amp;quot;path\u0026amp;quot;, \u0026amp;quot;/api/service/abc\u0026amp;quot;); map.put(\u0026amp;quot;version\u0026amp;quot;, \u0026amp;quot;1.0.0\u0026amp;quot;);  第二步：进行Key的自然排序，然后Key，Value值拼接最后再拼接分配给你的Sk。\nList\u0026amp;lt;String\u0026amp;gt; storedKeys = Arrays.stream(map.keySet() .toArray(new String[]{})) .sorted(Comparator.naturalOrder()) .collect(Collectors.toList()); final String sign = storedKeys.stream() .map(key -\u0026amp;gt; String.join(\u0026amp;quot;\u0026amp;quot;, key, params.get(key))) .collect(Collectors.joining()).trim() .concat(\u0026amp;quot;506EEB535CF740D7A755CB4B9F4A1536\u0026amp;quot;);   你得到的sign值应该为：path/api/service/abctimestamp1571711067186version1.0.0506EEB535CF740D7A755CB4B9F4A1536  第三步：进行Md5加密后转成大写。\nDigestUtils.md5DigestAsHex(sign.getBytes()).toUpperCase()   最后得到的值为：A021BF82BE342668B78CD9ADE593D683  请求网关  假如你访问的路径为：/api/service/abc。\n 访问地址 ：http：网关的域名/api/service/abc。\n 设置header头，header头参数为：\n     字段 值 描述     timestamp 1571711067186 上述你进行签名的时候使用的时间值   appKey 1TEST123456781 分配给你的Ak值   sign A90E66763793BDBC817CF3B52AAAC041 上述得到的签名值   version 1.0.0 写死，就为这个值     签名插件会默认过滤5分钟之后的请求  如果认证不通过会返回 code 为401 message可能会有变动。 \u0026amp;quot;code\u0026amp;quot;:401,\u0026amp;quot;message\u0026amp;quot;:\u0026amp;quot;sign is not pass,Please check you sign algorithm!\u0026amp;quot;,\u0026amp;quot;data\u0026amp;quot;:null}  签名认证算法扩展  请参考开发者文档中的 扩展签名算法。  ","date":-62135596800,"description":"sign插件","dir":"projects/soul/sign-plugin/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"a9673b8e1db9e7155e89cd972a0324a8","permalink":"/projects/soul/sign-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/soul/sign-plugin/","summary":"说明 sign插件是 soul网关自带的，用来对请求进行签名认证的插件。 插件设置 在 soul-admin -\u0026gt; 插件管理中 \u0026ndash;\u0026gt; sign插件设置为开启。 插件使用 在网关的 pom.xml 文件","tags":null,"title":"sign插件","type":"projects","url":"/projects/soul/sign-plugin/","wordcount":971},{"author":null,"categories":null,"content":" Description  The sofa plug-in is a plug-in that converts the HTTP protocol into the sofa protocol, and it is also the key to the gateway to realize the sofa generalization call.\n sThe sofa plug-in needs to cooperate with metadata to realize the call of Dubbo. Please refer to: Metadata。\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Plug-in\u0026amp;rsquo;s Settings  First, go to soul-admin \u0026amp;ndash;\u0026amp;gt; plug-in management-\u0026amp;gt; setting sofa is open 。\n Then, in the configuration of sofa plug-in, config sofa\u0026amp;rsquo;s register center like this:\n{\u0026amp;quot;protocol\u0026amp;quot;:\u0026amp;quot;zookeeper\u0026amp;quot;,\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;127.0.0.1:2181\u0026amp;quot;}   The plug-in needs to be used with a dependent starter. For details, please see: user-sofa。\n Selector\u0026amp;rsquo;s rules，see : selector。\n  Plug-in\u0026amp;rsquo;s Metadata  Each sofa interface method corresponds to a piece of metadata, which can be viewed in the soul-admin \u0026amp;gt; metadata management。\n url：It\u0026amp;rsquo;s your http urls。\n RPC extension parameter, corresponding to some configuration of sofa interface.If you wanna be modify it, please modify it here. Support JSON format. The following fields：\n  {\u0026amp;quot;loadbalance\u0026amp;quot;:\u0026amp;quot;hash\u0026amp;quot;,\u0026amp;quot;retries\u0026amp;quot;:3,\u0026amp;quot;timeout\u0026amp;quot;:-1}   ","date":-62135596800,"description":"sofa access soul gateway","dir":"projects/soul/sofa-plugin/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"ed1301a67391f5f0742e25c54372991f","permalink":"/en/projects/soul/sofa-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/sofa-plugin/","summary":"Description  The sofa plug-in is a plug-in that converts the HTTP protocol into the sofa protocol, and it is also the key to the gateway to realize the sofa generalization call.\n sThe sofa plug-in needs to cooperate with metadata to realize the call of Dubbo. Please refer to: Metadata。\n  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-sofa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Plug-in\u0026rsquo;s Settings  First, go to soul-admin \u0026ndash;\u0026gt; plug-in management-\u0026gt; setting sofa is open 。","tags":null,"title":"sofa access soul gateway","type":"projects","url":"/en/projects/soul/sofa-plugin/","wordcount":153},{"author":null,"categories":null,"content":" Description  This article is about sofa users using sofa plug-in support,and the tutorial of connecting your own sofa service to the soul gateway. Before connecting, please start soul-admin correctly and Setup Environment Ok。  Introduce the plug-in that the gateway supports for sofa  Add the following dependencies in the gateway\u0026amp;rsquo;s pom.xml file：\n Replace the sofa version with yours, and replace the jar package in the registry with yours, The following is a reference。   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-rpc-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;5.7.6\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Restart the gateway service。  sofa service access gateway, you can refer to：(soul-test-sofa)[https://github.com/dromara/soul/tree/master/soul-test/soul-test-sofa]  Springboot\n Introduce the following dependencies :\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${soul.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add the following configuration to your yml file ：  soul: sofa: adminUrl: http://localhost:9095 contextPath: /sofa appName: sofa # adminUrl: The ip + port of the soul-admin project started for you, pay attention to adding http:// # contextPath: Route prefix in soul gateway for your project，Such as /order ，/product etc，The gateway will route according to your prefix. # appName：Your application name, if not configured, it will default to the name in the application in the sofa configuration   Spring\n Introduce the following dependencies ：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-client-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add the following in the xml file of your bean definition ： ```xml    ```\n   sofa Plugin settings  First in the soul-admin plugin management, set the sofa plugin to open。\n Secondly, configure your registered address in the sofa plugin, or the address of other registry.\n  {\u0026amp;quot;protocol\u0026amp;quot;:\u0026amp;quot;zookeeper\u0026amp;quot;,\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;127.0.0.1:2181\u0026amp;quot;}  Interface registered to the gateway  For your sofa service implementation class, add …","date":-62135596800,"description":"sofa access soul gateway","dir":"projects/soul/sofa-rpc-proxy/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"a252b669c4bddb76122734710584756a","permalink":"/en/projects/soul/sofa-rpc-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/projects/soul/sofa-rpc-proxy/","summary":"Description  This article is about sofa users using sofa plug-in support,and the tutorial of connecting your own sofa service to the soul gateway. Before connecting, please start soul-admin correctly and Setup Environment Ok。  Introduce the plug-in that the gateway supports for sofa  Add the following dependencies in the gateway\u0026rsquo;s pom.xml file：\n Replace the sofa version with yours, and replace the jar package in the registry with yours, The following is a reference。   \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.","tags":null,"title":"sofa access soul gateway","type":"projects","url":"/en/projects/soul/sofa-rpc-proxy/","wordcount":560},{"author":null,"categories":null,"content":" Prerequisites  JDK 1.8+ Maven 3.2.x Git Zookeeper  Cloning the GitHub Repository and Quick Installation  \u0026amp;gt; git clone https://github.com/dromara/hmily.git \u0026amp;gt; cd hmily \u0026amp;gt; mvn -DskipTests clean install -U  Executing SQL(s) in Demo Module sql\nOpen with Your Favourite Editor (IDEA), Locate on hmily-demo-sofa Module and Run Build with Maven Configuring（hmily-demo-sofa-account module for instance）  Configure with your business database in application.yml  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026amp;lt;db_host_ip\u0026amp;gt;:\u0026amp;lt;db_host_port\u0026amp;gt;/hmily_account?useUnicode=true\u0026amp;amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   Configure with sofa-rpc registration address(es) in application.yml (can run with local zookeeper instance(s))  com: alipay: sofa: rpc: registry-address: zookeeper://127.0.0.1:2181 bolt-port: 8888   Modify hmily.yml, with mysql persistence backend  repository: database: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026amp;lt;db_host_ip\u0026amp;gt;:\u0026amp;lt;db_host_port\u0026amp;gt;/hmily?useUnicode=true\u0026amp;amp;characterEncoding=utf8 # replace with your db_host_ip and db_host_port username: root # replace with your db username password: your_password # replace with your db user password   run SofaHmilyAccountApplication.java  Run hmily-demo-sofa-inventory(refer to simillar instructions above). Run hmily-demo-sofa-order(refer to simillar instructions above). Access on http://127.0.0.1:8089/swagger-ui.html for more. ","date":-62135596800,"description":"sofa-rpc Quick Start","dir":"projects/hmily/quick-start-rpc/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"3079898dede3a4ceaaf96a0dc0d20328","permalink":"/en/projects/hmily/quick-start-rpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/hmily/quick-start-rpc/","summary":"Prerequisites  JDK 1.8+ Maven 3.2.x Git Zookeeper  Cloning the GitHub Repository and Quick Installation  \u0026gt; git clone https://github.com/dromara/hmily.git \u0026gt; cd hmily \u0026gt; mvn -DskipTests clean install -U  Executing SQL(s) in Demo Module sql\nOpen with Your Favourite Editor (IDEA), Locate on hmily-demo-sofa Module and Run Build with Maven Configuring（hmily-demo-sofa-account module for instance）  Configure with your business database in application.yml  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://\u0026lt;db_host_ip\u0026gt;:\u0026lt;db_host_port\u0026gt;/hmily_account?","tags":null,"title":"sofa-rpc Quick Start","type":"projects","url":"/en/projects/hmily/quick-start-rpc/","wordcount":165},{"author":null,"categories":null,"content":" 环境准备  JDK 1.8+ Maven 3.2.x Git Zookeeper  代码拉取  \u0026amp;gt; git clone https://github.com/dromara/hmily.git \u0026amp;gt; cd hmily \u0026amp;gt; mvn -DskipTests clean install -U  执行demo 模块的sql语句。 sql语句\n使用你的工具 idea 打开项目，找到hmily-demo-sofa项目，进行maven构建。 修改项目配置（hmily-demo-sofa-account为列子）  application.yml 下修改业务数据库  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://改成你的ip+端口/hmily_account?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: #改成你的用户名 password: #改成你的密码   application.yml 下修改sofa-rpc的注册中心地址(可以在自己电脑本地启动一个zookeeper服务)  com: alipay: sofa: rpc: registry-address: zookeeper://127.0.0.1:2181 bolt-port: 8888   修改 hmily.yml,这里使用mysql来存储  repository: database: driverClassName: com.mysql.jdbc.Driver url : jdbc:mysql://改成你的ip+端口/hmily?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: root #改成你的用户名 password: #改成你的密码   run SofaHmilyAccountApplication.java  启动hmily-demo-sofa-inventory 参考上述。 启动hmily-demo-sofa-order 参考上述。 访问：http://127.0.0.1:8089/swagger-ui.html。 ","date":-62135596800,"description":"sofa-rpc快速体验","dir":"projects/hmily/quick-start-rpc/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"3079898dede3a4ceaaf96a0dc0d20328","permalink":"/projects/hmily/quick-start-rpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/quick-start-rpc/","summary":"环境准备 JDK 1.8+ Maven 3.2.x Git Zookeeper 代码拉取 \u0026gt; git clone https://github.com/dromara/hmily.git \u0026gt; cd hmily \u0026gt; mvn -DskipTests clean install -U 执行demo 模块的sql语句。 sql语句 使用你的工具 idea 打开项目，找到hmily-dem","tags":null,"title":"sofa-rpc快速体验","type":"projects","url":"/projects/hmily/quick-start-rpc/","wordcount":508},{"author":null,"categories":null,"content":" sofa-rpc接口项目  在你的接口项目中引入jar包。  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-annotation\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在需要进行Hmily分布式事务的接口方法上加上 @Hmily 标识。\npublic interface HelloService { @Hmily void say(String hello); }  sofa-rpc实现项目  步骤一 ： 引入依赖hmily的jar包\n 步骤二 ： 新增Hmily配置\n 步骤三 ： 在实现方法上添加注解。TCC模式，则需要完成 confirm，cancel方法的开发\n  引入依赖 Spring-Namespace  引入依赖  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-sofa-rpc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  在xml中进行如下配置\n  \u0026amp;lt;!--设置开启aspectj-autoproxy--\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id = \u0026amp;quot;hmilyTransactionAspect\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.aop.SpringHmilyTransactionAspect\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id = \u0026amp;quot;hmilyApplicationContextAware\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.HmilyApplicationContextAware\u0026amp;quot;/\u0026amp;gt;  Spring-Boot  引入依赖  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-sofa-rpc\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  引入 hmily配置  在项目的 resource 新建文件名为:hmily.yml配置文件\n 具体的参数配置可以参考配置详解,本地配置模式, zookeeper配置模式, nacos配置模式,apollo配置模式\n  实现接口上添加注解 上述我们已经完成了集成，下面将讲述具体的实现。\nTCC模式  对@Hmily 标识的接口方法的具体实现上，加上@HmilyTCC(confirmMethod = \u0026amp;quot;confirm\u0026amp;quot;, cancelMethod = \u0026amp;quot;cancel\u0026amp;quot;)\n confirmMethod : 确认方法名称，该方法参数列表与返回类型应与标识方法一致。\n cancelMethod : 回滚方法名称，该方法参数列表与返回类型应与标识方法一致。\n TCC模式应该保证 confirm 和 cancel 方法的幂等性，用户需要自行去开发这个2个方法，所有的事务的确认与回滚，完全由用户决定。Hmily框架只是负责来进行调用\n  public class HelloServiceImpl implements HelloService { @HmilyTCC(confirmMethod = \u0026amp;quot;sayConfrim\u0026amp;quot;, cancelMethod = \u0026amp;quot;sayCancel\u0026amp;quot;) public void say(String hello) { System.out.println(\u0026amp;quot;hello world\u0026amp;quot;); } public void sayConfrim(String hello) { System.out.println(\u0026amp;quot; confirm hello world\u0026amp;quot;); } public void sayCancel(String hello) { System.out.println(\u0026amp;quot; cancel hello world\u0026amp;quot;); } }  TAC模式(在开发，未发布)  对@Hmily 标识的接口方法的具体实现上加上@HmilyTAC   重要注意事项 在调用任何RPC调用之前，当你需要聚合rpc调用成为一次分布式事务的时候，需要在聚合RPC调用的方法上，先行添加 @HmilyTCC 或者 @HmilyTAC 注解,表示开启全局事务。\n负载均衡 \u0026amp;amp;\u0026amp;amp; 设置永不重试  如果服务部署了几个节点， 负载均衡算法最好使用 hmily, 这样 try, confirm, cancel 调用会落在同一个节点 充分利用了缓存，提搞了效率。\n 支持一下几种 hmilyConsistentHash, hmilyRandom, hmilyLocalPref, hmilyRoundRobin, hmilyWeightRoundRobin, hmilyWeightConsistentHash 几种方式均是继承sofa-rpc原生的\n  \u0026amp;lt;sofa:reference jvm-first=\u0026amp;quot;false\u0026amp;quot; id=\u0026amp;quot;accountService\u0026amp;quot; interface=\u0026amp;quot;org.dromara.hmily.demo.common.account.api.AccountService\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;sofa:binding.bolt\u0026amp;gt; \u0026amp;lt;sofa:global-attrs retries=\u0026amp;quot;0\u0026amp;quot; timeout=\u0026amp;quot;5000\u0026amp;quot; loadBalancer =\u0026amp;quot;hmilyRandom\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/sofa:binding.bolt\u0026amp;gt; \u0026amp;lt;/sofa:reference\u0026amp;gt;  异常  try, confirm, cancel 方法的所有异常不要自行catch 任何异常都应该抛出给 Hmily框架处理。  ","date":-62135596800,"description":"sofa-rpc用户指南","dir":"projects/hmily/user-rpc/","fuzzywordcount":900,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"b0291d256039472c980741163fd918a8","permalink":"/projects/hmily/user-rpc/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/user-rpc/","summary":"sofa-rpc接口项目 在你的接口项目中引入jar包。 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hmily-annotation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;{last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在需要进行Hmily分布式事务的接口方法上加上 @Hmily 标识。 public interface HelloService { @Hmily void say(String hello); } so","tags":null,"title":"sofa-rpc用户指南","type":"projects","url":"/projects/hmily/user-rpc/","wordcount":858},{"author":null,"categories":null,"content":" 说明  此篇文章是sofa用户使用sofa插件支持，以及自己的sofa服务接入soul网关的教程。\n 接入前，请正确的启动 soul-admin以及搭建环境 Ok。\n  引入网关对sofa支持的插件  在网关的 pom.xml 文件中增加如下依赖：\n sofa版本换成你的，注册中心的jar包换成你的，以下是参考。   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alipay.sofa\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;sofa-rpc-all\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;5.7.6\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-framework\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.apache.curator\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;curator-recipes\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;4.0.1\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   重启网关服务。  sofa服务接入网关，可以参考：(soul-test-sofa)[https://github.com/dromara/soul/tree/master/soul-test/soul-test-sofa]  springboot\n 引入以下依赖\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${soul.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在你的yml文件中新增如下配置 ：  soul: sofa: adminUrl: http://localhost:9095 contextPath: /sofa appName: sofa # adminUrl: 为你启动的soul-admin 项目的ip + 端口，注意要加 http:// # contextPath: 为你的这个项目在soul网关的路由前缀，这个你应该懂意思把？ 比如/order ，/product 等等，网关会根据你的这个前缀来进行路由. # appName：你的应用名称，不配置的话，会默认取sofa配置中application 中的名称   spring\n 引入以下依赖 ：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-client-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${project.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在你的 bean定义的xml文件中新增如下 ： ```xml    ```\n   sofa 插件设置  首先在 soul-admin 插件管理中，把sofa 插件设置为开启。\n 其次在 sofa 插件中配置你的注册地址或者其他注册中心的地址.\n  {\u0026amp;quot;protocol\u0026amp;quot;:\u0026amp;quot;zookeeper\u0026amp;quot;,\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;127.0.0.1:2181\u0026amp;quot;}  接口注册到网关  你sofa服务实现类的，方法上加上 @SoulSofaClient 注解，表示该接口方法注册到网关。\n 启动你的提供者，输出日志 sofa client register success 大功告成，你的sofa接口已经发布到 soul网关.如果还有不懂的，可以参考 soul-test-sofa项目。\n  sofa用户请求以及参数说明  说白了，就是通过http的方式来请求你的sofa服务\n soul网关需要有一个路由前缀，这个路由前缀就是你接入项目进行配置 contextPath\n  # 比如你有一个 order服务 它有一个接口，它的注册路径 /order/test/save # 现在就是通过 post方式请求网关：http://localhost:9195/order/test/save # 其中 localhost:9195 为网关的ip端口，默认端口是9195 ，/order 是你sofa接入网关配置的 contextPath   参数传递：\n 通过 http post 方式访问网关，通过body，json类型传递。\n 更多参数类型传递，可以参考 soul-test-sofa 中的接口定义，以及参数传递方式。\n  单个java bean参数类型 （默认）\n 自定义实现多参数支持：\n 在你搭建的网关项目中，新增一个类 A，实现 org.dromara.soul.plugin.api.sofa.SofaParamResolveService。   public interface SofaParamResolveService { /** * Build parameter pair. * this is Resolve http body to get sofa param. * * @param body the body * @param parameterTypes the parameter types * @return the pair */ Pair\u0026amp;lt;String[], …","date":-62135596800,"description":"sofa接入soul网关","dir":"projects/soul/sofa-rpc-proxy/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"a252b669c4bddb76122734710584756a","permalink":"/projects/soul/sofa-rpc-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/soul/sofa-rpc-proxy/","summary":"说明 此篇文章是sofa用户使用sofa插件支持，以及自己的sofa服务接入soul网关的教程。 接入前，请正确的启动 soul-admin以及搭","tags":null,"title":"sofa接入soul网关","type":"projects","url":"/projects/soul/sofa-rpc-proxy/","wordcount":1195},{"author":null,"categories":null,"content":" 说明  sofa插件是将http协议 转换成sofa协议 的插件，也是网关实现sofa泛化调用的关键。\n sofa插件需要配合元数据才能实现dubbo的调用，具体请看：元数据。\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-sofa\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; sofa 设置为开启。\n 在sofa插件的配置中，配置如下：配置sofa的注册中心。\n{\u0026amp;quot;protocol\u0026amp;quot;:\u0026amp;quot;zookeeper\u0026amp;quot;,\u0026amp;quot;register\u0026amp;quot;:\u0026amp;quot;127.0.0.1:2181\u0026amp;quot;}   插件需要配合依赖 starter 进行使用，具体请看：sofa用户。\n 选择器和规则，请详细看：选择器规则。\n  元数据  每一个sofa接口方法，都会对应一条元数据，可以在 soul-admin \u0026amp;ndash;\u0026amp;gt;元数据管理，进行查看。\n 路径：就是你http请求的路径。\n rpc扩展参数，对应为sofa接口的一些配置，调整的话，请在这里修改，支持json格式，以下字段：\n  {\u0026amp;quot;loadbalance\u0026amp;quot;:\u0026amp;quot;hash\u0026amp;quot;,\u0026amp;quot;retries\u0026amp;quot;:3,\u0026amp;quot;timeout\u0026amp;quot;:-1}   ","date":-62135596800,"description":"sofa插件","dir":"projects/soul/sofa-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"ed1301a67391f5f0742e25c54372991f","permalink":"/projects/soul/sofa-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/sofa-plugin/","summary":"说明 sofa插件是将http协议 转换成sofa协议 的插件，也是网关实现sofa泛化调用的关键。 sofa插件需要配合元数据才能实现dubbo的","tags":null,"title":"sofa插件","type":"projects","url":"/projects/soul/sofa-plugin/","wordcount":301},{"author":null,"categories":null,"content":" Development Guidelines  Write codes with heart. Pursue clean, simplified and extremely elegant codes. Agree with concepts in \u0026amp;lt;Refactoring: Improving the Design of Existing Code\u0026amp;gt; and \u0026amp;lt;Clean Code: A Handbook of Agile Software Craftsmanship\u0026amp;gt;. Be familiar with codes already had, to keep consistent with the style and use. Highly reusable, no duplicated codes or configurations. Delete codes out of use in time.  Contributor Covenant Submitting of Conduct  Make sure all the test cases are passed, Make sure ./mvnw clean install can be compiled and tested successfully. Make sure the test coverage rate is not lower than the master branch. Make sure to check codes with Checkstyle. codes that violate check rules should have special reasons. Find checkstyle template from https://github.com/dromara/soul/blob/master/script/soul_checkstyle.xml, please use checkstyle 8.8 to run the rules. Careful consideration for each pull request; Small and frequent pull request with complete unit function is welcomed. Conform to Contributor Covenant Code of Conduct below.  Contributor Covenant Code of Conduct  Use linux line separators. Keep indents (including blank lines) consistent with the previous one. Keep one blank line after class definition. No meaningless blank lines. Please extract private methods to instead of blank lines if too long method body or different logic code fragments. Use meaningful class, method and variable names, avoid to use abbreviate. Return values are named with result; Variables in the loop structure are named with each; Replace each with entry in map. Name property files with Spinal Case(a variant of Snake Case which uses hyphens - to separate words). Split codes that need to add notes with it into small methods, which are explained with method names. Have constants on the left and variable on the right in = and equals conditional expressions; Have variable on the left and constants on the right in greater than and less than conditional expressions. Beside using same names as input parameters and global fields in assign statement, avoid using this modifier. Design class as final class except abstract class for extend. Make nested loop structures a new method. Order of members definition and parameters should be consistent during classes and methods. Use guard clauses in priority. Minimize the access permission for classes and methods. Private method should be just next to the method in which it is used; writing private methods should be in the same as the appearance order of private methods. No null parameters or return values. Replace if else return and assign statement with ternary operator in priority. Use LinkedList in priority. Use ArrayList for use index to get element only. Use capacity based Collection such as ArrayList, HashMap must indicate initial capacity to avoid recalculate capacity. Use English in all the logs and javadoc. Include Javadoc, todo and fixme only in the comments. Only public classes and methods need …","date":-62135596800,"description":"Soul Coding Guide","dir":"projects/soul/code-conduct/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"80181e1d88f84783ed1a226cee56d73d","permalink":"/en/projects/soul/code-conduct/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/projects/soul/code-conduct/","summary":"Development Guidelines  Write codes with heart. Pursue clean, simplified and extremely elegant codes. Agree with concepts in \u0026lt;Refactoring: Improving the Design of Existing Code\u0026gt; and \u0026lt;Clean Code: A Handbook of Agile Software Craftsmanship\u0026gt;. Be familiar with codes already had, to keep consistent with the style and use. Highly reusable, no duplicated codes or configurations. Delete codes out of use in time.  Contributor Covenant Submitting of Conduct  Make sure all the test cases are passed, Make sure .","tags":null,"title":"soul-code-conduct","type":"projects","url":"/en/projects/soul/code-conduct/","wordcount":472},{"author":null,"categories":null,"content":" 开发理念  用心 保持责任心和敬畏心，以工匠精神持续雕琢。 可读 代码无歧义，通过阅读而非调试手段浮现代码意图。 整洁 认同《重构》和《代码整洁之道》的理念，追求整洁优雅代码。 一致 代码风格、命名以及使用方式保持完全一致。 精简 极简代码，以最少的代码表达最正确的意思。高度复用，无重复代码和配置。及时删除无用代码。 抽象 层次划分清晰，概念提炼合理。保持方法、类、包以及模块处于同一抽象层级。  代码提交行为规范  确保通过全部测试用例，确保执行./mvnw clean install可以编译和测试通过。 确保覆盖率不低于master分支。 确保使用Checkstyle检查代码，违反验证规则的需要有特殊理由。模板位置在https://github.com/dromara/soul/blob/master/script/soul_checkstyle.xml，请使用checkstyle 8.8运行规则。 应尽量将设计精细化拆分；做到小幅度修改，多次数提交，但应保证提交的完整性。 确保遵守编码规范。  编码规范  使用linux换行符。 缩进（包含空行）和上一行保持一致。 类声明后与下面的变量或方法之间需要空一行。 不应有无意义的空行。请提炼私有方法，代替方法体过长或代码段逻辑闭环而采用的空行间隔。 类、方法和变量的命名要做到顾名思义，避免使用缩写。 返回值变量使用result命名；循环中使用each命名循环变量；map中使用entry代替each。 配置文件使用Spinal Case命名（一种使用-分割单词的特殊Snake Case）。 需要注释解释的代码尽量提成小方法，用方法名称解释。 equals和==条件表达式中，常量在左，变量在右；大于小于等条件表达式中，变量在左，常量在右。 除了构造器入参与全局变量名称相同的赋值语句外，避免使用this修饰符。 除了用于继承的抽象类之外，尽量将类设计为final。 嵌套循环尽量提成方法。 成员变量定义顺序以及参数传递顺序在各个类和方法中保持一致。 优先使用卫语句。 类和方法的访问权限控制为最小。 方法所用到的私有方法应紧跟该方法，如果有多个私有方法，书写私有方法应与私有方法在原方法的出现顺序相同。 方法入参和返回值不允许为null。 优先使用三目运算符代替if else的返回和赋值语句。 优先考虑使用LinkedList，只有在需要通过下标获取集合中元素值时再使用ArrayList。 ArrayList，HashMap等可能产生扩容的集合类型必须指定集合初始大小，避免扩容。 日志与注释一律使用英文。 注释只能包含javadoc，todo和fixme。 公开的类和方法必须有javadoc，其他类和方法以及覆盖自父类的方法无需javadoc。  ","date":-62135596800,"description":"soul编码指南","dir":"projects/soul/code-conduct/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"80181e1d88f84783ed1a226cee56d73d","permalink":"/projects/soul/code-conduct/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/soul/code-conduct/","summary":"开发理念 用心 保持责任心和敬畏心，以工匠精神持续雕琢。 可读 代码无歧义，通过阅读而非调试手段浮现代码意图。 整洁 认同《重构》和《代码整洁之道》的理","tags":null,"title":"soul-code-conduct","type":"projects","url":"/projects/soul/code-conduct/","wordcount":1103},{"author":null,"categories":null,"content":" 提交者提名 当你做了很多贡献以后，社区会进行提名。 成为committer你会拥有\n soul仓库写的权限\n idea 正版使用\n  提交者责任  开发新功能； 代码重构； 及时和可靠的评审Pull Request； 思考和接纳新特性请求； 解答问题； 维护文档和代码示例； 改进流程和工具； 引导新的参与者融入社区。  日常工作  committer需要每天查看社区待处理的Pull Request和issue列表，指定给合适的committer，即assignee。\n assignee在被分配issue后，需要进行如下判断：\n 判断是否是长期issue，如是，则标记为pending。 判断issue类型，如：bug，enhancement，discussion等。 判断Milestone，并标记。   注意\n无论是否是社区issue，都必须有assignee，直到issue完成。\n","date":-62135596800,"description":"soul-committer提交者指南","dir":"projects/soul/committer/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"f2c436ec0696f0dd9de31b8e0505ff3c","permalink":"/projects/soul/committer/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/committer/","summary":"提交者提名 当你做了很多贡献以后，社区会进行提名。 成为committer你会拥有 soul仓库写的权限 idea 正版使用 提交者责任 开发新功能； 代码重构；","tags":null,"title":"soul-committer","type":"projects","url":"/projects/soul/committer/","wordcount":357},{"author":null,"categories":null,"content":" You can report a bug, submit a new function enhancement suggestion, or submit a pull request directly.\nSubmit an Issue  Before submitting an issue, please go through a comprehensive search to make sure the problem cannot be solved just by searching. Check the Issue List to make sure the problem is not repeated. Create a new issue and choose the type of issue. Define the issue with a clear and descriptive title. Fill in necessary information according to the template. Choose a label after issue created, for example: bug，enhancement，discussion. Please pay attention for your issue, you may need provide more information during discussion.  Developer Flow Fork Soul repo\n Fork a Soul repo to your own repo to work, then setting upstream.  git remote add upstream https://github.com/dromara/soul.git  Choose Issue\n Please choose the issue to be edited. If it is a new issue discovered or a new function enhancement to offer, please create an issue and set the right label for it. After choosing the relevant issue, please reply with a deadline to indicate that you are working on it.  Create Branch\n Switch to forked master branch, pull codes from upstream, then create a new branch.  git checkout master git pull upstream master git checkout -b issueNo  Notice ：We will merge PR using squash, commit log will be different form upstream if you use old branch.\nCoding\n Please obey the Code of Conduct during the process of development and finish the check before submitting the pull request. push code to your fork repo.  git add modified-file-names git commit -m \u0026#39;commit log\u0026#39; git push origin issueNo  Submit Pull Request\n Send a pull request to the master branch. The mentor will do code review before discussing some details (including the design, the implementation and the performance) with you. The request will be merged into the branch of current development version after the edit is well enough. At last, congratulate to be an official contributor of Soul.  Delete Branch\n You can delete the remote branch (origin/issueNo) and the local branch (issueNo) associated with the remote branch (origin/issueNo) after the mentor merged the pull request into the master branch of Soul.  git checkout master git branch -d issueNo git push origin --delete issueNo  Notice: Please note that in order to show your id in the contributor list, don\u0026amp;rsquo;t forget the configurations below:\ngit config --global user.name \u0026amp;quot;username\u0026amp;quot; git config --global user.email \u0026amp;quot;username@mail.com\u0026amp;quot;  FAQ\n After each Pull Request (PR), you need to execute the following operations, otherwise, the previous PR commit records will be mixed with this PR commit records. The specific operation process is as follows:  git checkout master git fetch upstream git reset --hard upstream/master git push -f  ","date":-62135596800,"description":"Soul Contributor's Guide","dir":"projects/soul/contributor/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"b5c4bb9c7f314ad3153fd1919af6fe95","permalink":"/en/projects/soul/contributor/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/projects/soul/contributor/","summary":"You can report a bug, submit a new function enhancement suggestion, or submit a pull request directly.\nSubmit an Issue  Before submitting an issue, please go through a comprehensive search to make sure the problem cannot be solved just by searching. Check the Issue List to make sure the problem is not repeated. Create a new issue and choose the type of issue. Define the issue with a clear and descriptive title.","tags":null,"title":"soul-contributor","type":"projects","url":"/en/projects/soul/contributor/","wordcount":443},{"author":null,"categories":null,"content":" 您可以报告bug，提交一个新的功能增强建议或者直接对以上内容提交改进补丁。\n提交issue  在提交issue之前，请经过充分的搜索，确定该issue不是通过简单的检索即可以解决的问题。 查看issue列表，确定该issue不是一个重复的问题。 新建一个issue并选择您的issue类型。 使用一个清晰并有描述性的标题来定义issue。 根据模板填写必要信息。 在提交issue之后，对该issue分配合适的标签。如：bug，enhancement，discussion等。 请对自己提交的issue保持关注，在讨论中进一步提供必要信息。  开发流程 Fork分支到本地，设置upstream  从soul的repo上fork一个分支到您自己的repo来开始工作，并设置upstream为soul的repo。  git remote add upstream https://github.com/dromara/soul.git  选择issue  请在选择您要修改的issue。如果是您新发现的问题或想提供issue中没有的功能增强，请先新建一个issue并设置正确的标签。 在选中相关的issue之后，请回复以表明您当前正在这个issue上工作。并在回复的时候为自己设置一个deadline，添加至回复内容中。  创建分支  切换到fork的master分支，拉取最新代码，创建本次的分支。  git checkout master git pull upstream master git checkout -b issueNo  注意 ：PR会按照squash的方式进行merge，如果不创建新分支，本地和远程的提交记录将不能保持同步。\n编码  请您在开发过程中遵循soul的 开发规范。并在准备提交pull request之前完成相应的检查。 将修改的代码push到fork库的分支上。  git add 修改代码 git commit -m \u0026#39;commit log\u0026#39; git push origin issueNo  提交PR  发送一个pull request到soul的master分支。 接着导师做CodeReview，然后他会与您讨论一些细节（包括设计，实现，性能等）。当导师对本次修改满意后，会将提交合并到当前开发版本的分支中。 最后，恭喜您已经成为了Soul的贡献者！  删除分支  在导师将pull request合并到soul的master分支中之后，您就可以将远程的分支（origin/issueNo）及与远程分支（origin/issueNo）关联的本地分支（issueNo）删除。  git checkout master git branch -d issueNo git push origin --delete issueNo  注意 为了让您的id显示在contributor列表中，别忘了以下设置：\ngit config --global user.name \u0026amp;quot;username\u0026amp;quot; git config --global user.email \u0026amp;quot;username@mail.com\u0026amp;quot;  常见问题  每次Pull Request(PR)后,你需要执行以下操作,否则,之前PR的提交记录会和这次的提交记录混在一起,具体操作流程如下:  git checkout master git fetch upstream git reset --hard upstream/master git push -f  ","date":-62135596800,"description":"soul-contributor贡献者指南","dir":"projects/soul/contributor/","fuzzywordcount":1100,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"b5c4bb9c7f314ad3153fd1919af6fe95","permalink":"/projects/soul/contributor/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/soul/contributor/","summary":"您可以报告bug，提交一个新的功能增强建议或者直接对以上内容提交改进补丁。 提交issue 在提交issue之前，请经过充分的搜索，确定该iss","tags":null,"title":"soul-contributor","type":"projects","url":"/projects/soul/contributor/","wordcount":1038},{"author":null,"categories":null,"content":" What is the Soul？ 这是一个异步的，高性能的，跨语言的，响应式的API网关。我希望能够有一样东西像灵魂一样，保护您的微服务。参考了Kong，Spring-Cloud-Gateway等优秀的网关后，站在巨人的肩膀上，Soul由此诞生！\nFeatures  支持各种语言(http协议)，支持 dubbo，springcloud协议。\n 插件化设计思想，插件热插拔，易扩展。\n 灵活的流量筛选，能满足各种流量控制。\n 内置丰富的插件支持，鉴权，限流，熔断，防火墙等等。\n 流量配置动态化，性能极高，网关消耗在 1~2ms。\n 支持集群部署，支持 A/B Test，蓝绿发布。\n  架构图 Prerequisite  JDK 1.8+ Maven 3.2.x Git mysql  ","date":-62135596800,"description":"Soul是一个异步的，高性能的，跨语言的，响应式的API网关。希望能够有一样东西像灵魂一样，保护您的微服务。参考了Kong，Spring-Cloud-Gateway等优秀的网关后，站在巨人的肩膀上，Soul由此诞生！","dir":"projects/soul/overview/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"5d30d134c5a14a47c55803eebfb34cd1","permalink":"/projects/soul/overview/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/overview/","summary":"What is the Soul？ 这是一个异步的，高性能的，跨语言的，响应式的API网关。我希望能够有一样东西像灵魂一样，保护您的微服务。参考了Kong，Sp","tags":null,"title":"soul介绍","type":"projects","url":"/projects/soul/overview/","wordcount":267},{"author":null,"categories":null,"content":" 说明  本文主要介绍如果对soul进行优化  本身消耗  soul本身所有的操作，都是基于jvm内存来匹配，本身消耗时间大概在 1-3 ms左右。  底层netty调优  soul内置依赖 spring-webflux 而其底层是使用的netty\n 我们可以自定义netty的相关参数来对soul 进行优化,以下是示例：\n  @Bean public NettyReactiveWebServerFactory nettyReactiveWebServerFactory() { NettyReactiveWebServerFactory webServerFactory = new NettyReactiveWebServerFactory(); webServerFactory.addServerCustomizers(new EventLoopNettyCustomizer()); return webServerFactory; } private static class EventLoopNettyCustomizer implements NettyServerCustomizer { @Override public HttpServer apply(final HttpServer httpServer) { return httpServer .tcpConfiguration(tcpServer -\u0026amp;gt; tcpServer .runOn(LoopResources.create(\u0026amp;quot;soul-netty\u0026amp;quot;, 1, DEFAULT_IO_WORKER_COUNT, true), false) .selectorOption(ChannelOption.SO_REUSEADDR, true) .selectorOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .option(ChannelOption.TCP_NODELAY, true) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)); } }   这个类在 soul-bootstrap中已经内置，在压测的时候，可以根据自己的需求来进行优化设置。\n 业务线程模型可以看线程模型\n  ","date":-62135596800,"description":"soul性能优化","dir":"projects/soul/soul-optimize/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"ff4a6aecd7f5d6781cfe3d90159825f7","permalink":"/projects/soul/soul-optimize/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/soul-optimize/","summary":"说明 本文主要介绍如果对soul进行优化 本身消耗 soul本身所有的操作，都是基于jvm内存来匹配，本身消耗时间大概在 1-3 ms左右。 底层netty","tags":null,"title":"soul性能优化","type":"projects","url":"/projects/soul/soul-optimize/","wordcount":238},{"author":null,"categories":null,"content":" description  Users can customize the signature authentication algorithm to achieve verification.  extension  The default implementation is org.dromara.soul.plugin.sign.service.DefaultSignService。\n Declare a new class named \u0026amp;ldquo;A\u0026amp;rdquo; and implements org.dromara.soul.plugin.api.SignService。\n  public interface SignService { /** * Sign verify pair. * * @param exchange the exchange * @return the pair */ Pair\u0026amp;lt;Boolean, String\u0026amp;gt; signVerify(ServerWebExchange exchange); }   When returning ture in Pair, the sign verification passes. If there\u0026amp;rsquo;s false, the String in Pair will be return to the frontend to show.\n Register defined class as a Spring Bean.\n  @Bean public SignService a() { return new A }  ","date":-62135596800,"description":"specify sign plugins for examination","dir":"projects/soul/custom-sign-algorithm/","fuzzywordcount":100,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"7ac872a2a536afa677e45888ddaaf15a","permalink":"/en/projects/soul/custom-sign-algorithm/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/custom-sign-algorithm/","summary":"description  Users can customize the signature authentication algorithm to achieve verification.  extension  The default implementation is org.dromara.soul.plugin.sign.service.DefaultSignService。\n Declare a new class named \u0026ldquo;A\u0026rdquo; and implements org.dromara.soul.plugin.api.SignService。\n  public interface SignService { /** * Sign verify pair. * * @param exchange the exchange * @return the pair */ Pair\u0026lt;Boolean, String\u0026gt; signVerify(ServerWebExchange exchange); }   When returning ture in Pair, the sign verification passes. If there\u0026rsquo;s false, the String in Pair will be return to the frontend to show.","tags":null,"title":"specify sign plugins for examination","type":"projects","url":"/en/projects/soul/custom-sign-algorithm/","wordcount":91},{"author":null,"categories":null,"content":" Features  this article is a guide about how to integrate Spring Cloud with soul gateway quickly.\n pls enable springCloud plug-in in soul-admin background.\n Pls start soul-admin successfully beofore integrating , and Environement Setup is Ok.\n  Configure soul gateway as Spring Cloud proxy  add these dependencies in gateway\u0026amp;rsquo;s pom.xml:  \u0026amp;lt;!--soul springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul springCloud plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   If you use eureka as SpringCloud registry center.\n add these dependencies:    \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in gateway\u0026amp;rsquo;s yaml file:   eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ #your eureka address instance: prefer-ip-address: true   if you use nacos as Spring Cloud registry center.\n add these dependencies:    \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-alibaba-nacos-discovery\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.1.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in gateway\u0026amp;rsquo;s yaml file:   spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 # your nacos address   restart your gateway service.  SpringCloud integration with gateway.  add these dependencies in your project：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in your yaml file:  soul: springcloud: admin-url: http://localhost:9095 context-path: /springcloud appName: http # adminUrl: \u0026#39;ip + port\u0026#39; of your soul-admin project, pls note \u0026#39;http://\u0026#39; is necessary. # contextPath: your project\u0026#39;s route prefix through soul gateway, such as /order ，/product etc，gateway will route based on it. # appName：your project name,the default value is`spring.application.name`.   add the annotation @SoulSpringCloudClient in your controller interface.\n you can apply the annotation to class-level in a controller.the name of the path variable is prefix and \u0026amp;lsquo;/**\u0026amp;rsquo; will apply proxy for entire interfaces.\n example （1）：both /test/payment and …","date":-62135596800,"description":"springCloud with soul gateway","dir":"projects/soul/spring-cloud-proxy/","fuzzywordcount":600,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"71e8a21eb41c78d677cb4a728456319e","permalink":"/en/projects/soul/spring-cloud-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/projects/soul/spring-cloud-proxy/","summary":"Features  this article is a guide about how to integrate Spring Cloud with soul gateway quickly.\n pls enable springCloud plug-in in soul-admin background.\n Pls start soul-admin successfully beofore integrating , and Environement Setup is Ok.\n  Configure soul gateway as Spring Cloud proxy  add these dependencies in gateway\u0026rsquo;s pom.xml:  \u0026lt;!--soul springCloud plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--soul springCloud plugin end--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.","tags":null,"title":"springCloud with soul gateway","type":"projects","url":"/en/projects/soul/spring-cloud-proxy/","wordcount":522},{"author":null,"categories":null,"content":" 说明  此篇文章是教你如何将springCloud接口，快速接入到soul网关。\n 请在 soul-admin 后台将 springCloud 插件设置为开启。\n 接入前，请正确的启动 soul-admin以及搭建环境 Ok。\n  引入网关 springCloud的插件支持  在网关的 pom.xml 文件中引入如下依赖。  \u0026amp;lt;!--soul springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul springCloud plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   如果你使用 eureka 作为 springCloud的注册中心\n 新增如下依赖：   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-eureka-client\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在网关的yml文件中 新增如下配置：  eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ # 你的eureka地址 instance: prefer-ip-address: true   如果你使用 nacos 作为 springCloud的注册中心\n 新增如下依赖：   \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;com.alibaba.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-alibaba-nacos-discovery\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.1.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在网关的yml文件中 新增如下配置：  spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 # 你的nacos地址   重启你的网关服务。  SpringCloud服务接入网关。  在你提供服务的项目中，引入如下依赖：  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-client-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在你的yml文件中新增如下配置：  soul: springcloud: admin-url: http://localhost:9095 context-path: /springcloud full: true # adminUrl: 为你启动的soul-admin 项目的ip + 端口，注意要加http:// # contextPath: 为你的这个mvc项目在soul网关的路由前缀，这个你应该懂意思把？ 比如/order ，/product 等等，网关会根据你的这个前缀来进行路由. # full: 设置true 代表代理你的整个服务，false表示代理你其中某几个controller   在你的 controller的接口上加上 @SoulSpringCloudClient 注解\n 你可以把注解加到 Controller 类上面, 里面的path属性则为前缀，如果含有 /** 代表你的整个接口需要被网关代理\n 举列子 （1）： 代表 /test/payment, /test/findByUserId 都会被网关代理。\n   @RestController @RequestMapping(\u0026amp;quot;/test\u0026amp;quot;) @SoulSpringCloudClient(path = \u0026amp;quot;/test/**\u0026amp;quot;) public class HttpTestController { @PostMapping(\u0026amp;quot;/payment\u0026amp;quot;) public UserDTO post(@RequestBody final UserDTO userDTO) { return userDTO; } @GetMapping(\u0026amp;quot;/findByUserId\u0026amp;quot;) public UserDTO findByUserId(@RequestParam(\u0026amp;quot;userId\u0026amp;quot;) final String userId) { UserDTO userDTO = new UserDTO(); …","date":-62135596800,"description":"springCloud接入soul网关","dir":"projects/soul/spring-cloud-proxy/","fuzzywordcount":1400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"71e8a21eb41c78d677cb4a728456319e","permalink":"/projects/soul/spring-cloud-proxy/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/soul/spring-cloud-proxy/","summary":"说明 此篇文章是教你如何将springCloud接口，快速接入到soul网关。 请在 soul-admin 后台将 springCloud 插件设置为开启。 接入前，请正确的启动 soul-ad","tags":null,"title":"springCloud接入soul网关","type":"projects","url":"/projects/soul/spring-cloud-proxy/","wordcount":1389},{"author":null,"categories":null,"content":" 环境准备  JDK 1.8+ Maven 3.2.x Git redis mysql  代码拉取  \u0026amp;gt; git clone https://github.com/yu199195/Raincat.git \u0026amp;gt; cd Raincat \u0026amp;gt; mvn -DskipTests clean install -U  ### 执行demo 模块的sql语句。\nsql语句\n使用你的工具 idea 或者eclipse 打开项目。 修改raincat-manager项目下，application.yml中的redis配置 tx: manager: netty : port: 9998 serialize: kryo maxConnection: 100 maxThreads : 16 delayTime : 5 heartTime : 20 redis : cluster : false hostName : 192.168.1.91 port: 6379 password : foobaredbbexONE123  启动raincat-manager （执行TxManagerApplication中的main方法） 修改alipay项目的application.yml中的数据库配置 spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://192.168.1.98:3306/alipay?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: root password: 123456 application: name: alipay-service   修改 applicationContext.xml中的数据库配置  \u0026amp;lt;bean id=\u0026amp;quot;txTransactionBootstrap\u0026amp;quot; class=\u0026amp;quot;org.dromara.raincat.core.bootstrap.TxTransactionBootstrap\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;txManagerUrl\u0026amp;quot; value=\u0026amp;quot;http://127.0.0.1:8761\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serializer\u0026amp;quot; value=\u0026amp;quot;kryo\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;nettySerializer\u0026amp;quot; value=\u0026amp;quot;kryo\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;compensation\u0026amp;quot; value=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;compensationCacheType\u0026amp;quot; value=\u0026amp;quot;db\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;txDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;bean class=\u0026amp;quot;org.dromara.raincat.common.config.TxDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;url\u0026amp;quot; value=\u0026amp;quot;jdbc:mysql://192.168.1.98:3306/tx?useUnicode=true\u0026amp;amp;amp;characterEncoding=utf8\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;driverClassName\u0026amp;quot; value=\u0026amp;quot;com.mysql.jdbc.Driver\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;username\u0026amp;quot; value=\u0026amp;quot;root\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;password\u0026amp;quot; value=\u0026amp;quot;123456\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;   启动Alipay项目。（执行AliPayApplication中的main方法）  其他项目类似，启动wechat项目，启动pay项目。 访问 http://127.0.0.1:8881/swagger-ui.html ","date":-62135596800,"description":"springcloud快速体验","dir":"projects/raincat/quick-start-springcloud/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"71206e349fc0414678c4644538cd58b3","permalink":"/projects/raincat/quick-start-springcloud/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/raincat/quick-start-springcloud/","summary":"环境准备 JDK 1.8+ Maven 3.2.x Git redis mysql 代码拉取 \u0026gt; git clone https://github.com/yu199195/Raincat.git \u0026gt; cd Raincat \u0026gt; mvn -DskipTests clean install -U ### 执行demo 模块的sql语句。 sql语句 使用你的工具 idea 或者eclipse 打开项目。","tags":null,"title":"springcloud快速体验","type":"projects","url":"/projects/raincat/quick-start-springcloud/","wordcount":379},{"author":null,"categories":null,"content":" 说明  该插件是用来将http协议 转成springCloud协议 的核心。  引入网关 springCloud的插件支持  在网关的 pom.xml 文件中引入如下依赖。  \u0026amp;lt;!--soul springCloud plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-httpclient\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul springCloud plugin end--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-commons\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.cloud\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-cloud-starter-netflix-ribbon\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.0.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; springCloud，设置为开启。\n 插件需要配合依赖 starter 进行使用，具体请看：springCloud用户。\n 选择器和规则，请详细看：选择器规则。\n  详解  应用名称：就是你根据条件匹配以后，需要调用的你的具体的应用名称。\n soul会从springCloud的注册中心上面，根据应用名称获取对应的服务真实ip地址，发起http代理调用。\n  ","date":-62135596800,"description":"springcloud插件","dir":"projects/soul/spring-cloud-plugin/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"804a8247c5ac2055858fdc625ee12087","permalink":"/projects/soul/spring-cloud-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/spring-cloud-plugin/","summary":"说明 该插件是用来将http协议 转成springCloud协议 的核心。 引入网关 springCloud的插件支持 在网关的 pom.xml 文件中引入如下依赖。 \u0026lt;!--soul","tags":null,"title":"springcloud插件","type":"projects","url":"/projects/soul/spring-cloud-plugin/","wordcount":272},{"author":null,"categories":null,"content":" 首先启动raincat-manager，具体怎么启动参考 启动manager jar包依赖，在你的服务端添加jar包，并在需要参与分布式事务的方法上添加 @TxTransaction注解 \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;raincat-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.0.0-RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  Spring XML方式配置 TxTransactionBootstrap \u0026amp;lt;context:component-scan base-package=\u0026amp;quot;org.dromara.*\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;txTransactionBootstrap\u0026amp;quot; class=\u0026amp;quot;org.dromara.raincat.core.bootstrap.TxTransactionBootstrap\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;txManagerUrl\u0026amp;quot; value=\u0026amp;quot;http://localhost:8761\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;serializer\u0026amp;quot; value=\u0026amp;quot;kryo\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;nettySerializer\u0026amp;quot; value=\u0026amp;quot;kryo\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;compensation\u0026amp;quot; value=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;compensationCacheType\u0026amp;quot; value=\u0026amp;quot;db\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;txDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;bean class=\u0026amp;quot;org.dromara.raincat.common.config.TxDbConfig\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;url\u0026amp;quot; value=\u0026amp;quot;jdbc:mysql://192.168.1.98:3306/tx?useUnicode=true\u0026amp;amp;amp;characterEncoding=utf8\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;driverClassName\u0026amp;quot; value=\u0026amp;quot;com.mysql.jdbc.Driver\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;username\u0026amp;quot; value=\u0026amp;quot;root\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;property name=\u0026amp;quot;password\u0026amp;quot; value=\u0026amp;quot;123456\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt; \u0026amp;lt;/property\u0026amp;gt; \u0026amp;lt;/bean\u0026amp;gt;  Spring boot start方式配置 TxTransactionBootstrap  首先依赖raincat 提供的spring-boot-starter-springcloud\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;raincat-spring-boot-starter-springcloud\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.0.0-RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   配置 application.yml  org: dromara: raincat: txManagerUrl: http://localhost:8761 serializer: kroy nettySerializer: kroy compensation: true compensationCacheType : db txDbConfig : driverClassName : com.mysql.jdbc.Driver url : jdbc:mysql://192.168.1.98:3306/tx?useUnicode=true\u0026amp;amp;amp;characterEncoding=utf8 username : root password : 123456  txManagerUrl：填写你启动的txManager的ip端口，注意添加http://\n serializer： 是指事务日志的序列化方式\n nettySerializer： 与txManager通信对象的序列化方法，注意与txManager中的序列化方式配置一样。\n compensation ：是否需要补偿，极端情况下，服务自身会进行补偿。\n compensationCacheType： 存储日志类型，当然还有支持redis，mongo，zookeeper等等，具体可以参考 配置详解。\n  配置扫描raincat包，与开启AOP代理（XML方式配置的时候必须加上，starter方式不需要）。 如果有任何问题可以参考springcloud-sample ","date":-62135596800,"description":"springcloud用户指南","dir":"projects/raincat/springcloud-user/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"6ef36d9985c1b5af000cb0ec7b7f0d83","permalink":"/projects/raincat/springcloud-user/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/raincat/springcloud-user/","summary":"首先启动raincat-manager，具体怎么启动参考 启动manager jar包依赖，在你的服务端添加jar包，并在需要参与分布式事务的方","tags":null,"title":"springcloud用户指南","type":"projects","url":"/projects/raincat/springcloud-user/","wordcount":542},{"author":null,"categories":null,"content":" 环境准备  JDK 1.8+ Maven 3.2.x Git Zookeeper  代码拉取  \u0026amp;gt; git clone https://github.com/dromara/hmily.git \u0026amp;gt; cd hmily \u0026amp;gt; mvn -DskipTests clean install -U  执行demo 模块的sql语句。 sql语句\n建立tars节点 根据此文在当前tars平台建立\n- 应用名:TestInventory,服务名称:InventoryApp,Obj名:InventoryObj,端口29740的节点。\n- 应用名:HmilyAccount,服务名称:AccountApp,Obj名:AccountObj,端口10386的节点。\n在完成节点的建立后，分别到hmily-demo-tars-springboot-account和hmily-demo-tars-springboot-inventory目录下执行mvn clean package命令打包并按照此文在两个前面建立的节点上使用打包的成果物进行节点发布。\n使用你的工具 idea 打开项目，找到hmily-demo-tars项目。 修改项目配置（hmily-demo-tars-account为列子）  修改业务数据库(account项目为列子)  spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://改成你的ip+端口/hmily_account?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: #改成你的用户名 password: #改成你的密码   修改 hmily.yml,这里使用mysql来存储  repository: database: driverClassName: com.mysql.jdbc.Driver url : jdbc:mysql://改成你的ip+端口/hmily?useUnicode=true\u0026amp;amp;characterEncoding=utf8 username: root #改成你的用户名 password: #改成你的密码   将rescouces目录下的config.conf后缀文件里的192.168.41.102全局替换成tars平台ip,并在启动参数中添加-Dconfig=该文件的路径\n run TarsHmilyAccountApplication.java\n  启动hmily-demo-tars-springboot-inventory 参考上述。 启动hmily-demo-tars-springboot-order 参考上述。 访问：http://127.0.0.1:18087/swagger-ui.html。 ","date":-62135596800,"description":"tars快速体验","dir":"projects/hmily/quick-start-tars/","fuzzywordcount":900,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"76bbac5c6c6575e871bc59f8373e9890","permalink":"/projects/hmily/quick-start-tars/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/quick-start-tars/","summary":"环境准备 JDK 1.8+ Maven 3.2.x Git Zookeeper 代码拉取 \u0026gt; git clone https://github.com/dromara/hmily.git \u0026gt; cd hmily \u0026gt; mvn -DskipTests clean install -U 执行demo 模块的sql语句。 sql语句 建立tars节点 根据此文在当前tars平台建立","tags":null,"title":"tars快速体验","type":"projects","url":"/projects/hmily/quick-start-tars/","wordcount":848},{"author":null,"categories":null,"content":" Tars用户指南  引入jar包\n 引入hmily配置\n 在需要进行Hmily分布式事务的自动生成的Servant接口方法上加上 @Hmily 标识。\n 在具体的实现方法上（服务提供端），加上@HmilyTCC or HmilyTAC 注解\n  引入依赖 Spring-Namespace\n 引入依赖\n  \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-tars\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在xml中进行如下配置\n\u0026amp;lt;!--配置扫码hmily框架的包--\u0026amp;gt; \u0026amp;lt;context:component-scan base-package=\u0026amp;quot;org.dromara.hmily.*\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;!--设置开启aspectj-autoproxy--\u0026amp;gt; \u0026amp;lt;aop:aspectj-autoproxy expose-proxy=\u0026amp;quot;true\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;!--配置Hmily启动的bean参数--\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;hmilyApplicationContextAware\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.spring.HmilyApplicationContextAware\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;hmilyCommunicatorBeanPostProcessor\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.tars.spring.TarsHmilyCommunicatorBeanPostProcessor\u0026amp;quot;/\u0026amp;gt; \u0026amp;lt;bean id=\u0026amp;quot;tarsHmilyStartupBean\u0026amp;quot; class=\u0026amp;quot;org.dromara.hmily.tars.spring.TarsHmilyFilterStartupBean\u0026amp;quot;/\u0026amp;gt;  Spring-Boot\n 引入依赖\nxml \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;hmily-spring-boot-starter-tars\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;{last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;    引入Hmily配置  在项目的 resource 新建文件名为: hmily.ym 配置文件。\n 具体的参数配置可以参考配置详解,本地配置模式, zookeeper配置模式, nacos配置模式,apollo配置模式\n  实现接口上添加注解 上述我们已经完成了集成，下面将讲述具体的实现。\nTCC模式  对@Hmily 标识的接口方法的具体实现上，加上@HmilyTCC(confirmMethod = \u0026amp;quot;confirm\u0026amp;quot;, cancelMethod = \u0026amp;quot;cancel\u0026amp;quot;)\n confirmMethod : 确认方法名称，该方法参数列表与返回类型应与标识方法一致。\n cancelMethod : 回滚方法名称，该方法参数列表与返回类型应与标识方法一致。\n TCC模式应该保证 confirm 和 cancel 方法的幂等性，用户需要自行去开发这个2个方法，所有的事务的确认与回滚，完全由用户决定。Hmily框架只是负责来进行调用\n  public class HelloServiceImpl implements HelloService { @HmilyTCC(confirmMethod = \u0026amp;quot;sayConfrim\u0026amp;quot;, cancelMethod = \u0026amp;quot;sayCancel\u0026amp;quot;) public void say(String hello) { System.out.println(\u0026amp;quot;hello world\u0026amp;quot;); } public void sayConfrim(String hello) { System.out.println(\u0026amp;quot; confirm hello world\u0026amp;quot;); } public void sayCancel(String hello) { System.out.println(\u0026amp;quot; cancel hello world\u0026amp;quot;); } }  重要注意事项 异常  try, confirm, cancel 方法的所有异常不要自行catch 任何异常都应该抛出给 Hmily框架处理。  ","date":-62135596800,"description":"tars用户指南","dir":"projects/hmily/user-tars/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"6ab504fb449aa59762cf68f052d17f16","permalink":"/projects/hmily/user-tars/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/hmily/user-tars/","summary":"Tars用户指南 引入jar包 引入hmily配置 在需要进行Hmily分布式事务的自动生成的Servant接口方法上加上 @Hmily 标识。 在具体的实现方法","tags":null,"title":"tars用户指南","type":"projects","url":"/projects/hmily/user-tars/","wordcount":623},{"author":null,"categories":null,"content":" description  This article gives an introduction to thread models in soul and usage in various scenarios.  io and work thread  spring-webflux is one of dependencies of soul, and it uses Netty thread model in lower layer.  business thread  Use scheduling thread to execute by default.\n A fixed thread pool manages business threads, the number of threads is count in this formula: cpu * 2 + 1.\n  type switching  reactor.core.scheduler.Schedulers.\n -Dsoul.scheduler.type=fixed is a default config. If set to other value, a flexible thread pool will take place it.Schedulers.elastic().\n -Dsoul.work.threads = xx is for configuring number of threads, the default value calculates in following formula cpu * 2 + 1 with a minimum of 16 threads.\n  ","date":-62135596800,"description":"thread model","dir":"projects/soul/thread/","fuzzywordcount":200,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"1b10d5087b7f48d39726ce58347610d5","permalink":"/en/projects/soul/thread/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/thread/","summary":"description  This article gives an introduction to thread models in soul and usage in various scenarios.  io and work thread  spring-webflux is one of dependencies of soul, and it uses Netty thread model in lower layer.  business thread  Use scheduling thread to execute by default.\n A fixed thread pool manages business threads, the number of threads is count in this formula: cpu * 2 + 1.","tags":null,"title":"thread model","type":"projects","url":"/en/projects/soul/thread/","wordcount":114},{"author":null,"categories":null,"content":" Features  Data synchronization is the key of gateway high performance, which is to sync \u0026amp;lsquo;soul-admin\u0026amp;rsquo; config data into the JVM memory of soul cluster.\n Implementation principles, pls refer to：dataSync。\n In the article, the gateway is the environment you setup. please refer to：Environment Setup.\n  Websocket sync（default method，recommend）  gateway setting（note:restart）\n Add these dependencies in pom.xml：\n\u0026amp;lt;!--soul data sync start use websocket--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-websocket\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in springboot yaml file: yaml soul : sync: websocket : urls: ws://localhost:9095/websocket #urls: address of soul-admin，multi-address will be splitted with (,).    soul-admin config, enable this parameter --soul.sync.websocket=\u0026#39;\u0026#39; in soul admin, then restart service.\nsoul: sync: websocket:   When the connection is established, getting the full data once,then adding and upating data subsequently, which is a good performance.\n Support disconnection and reconnection (default 30 sec).\n  zookeeper sync  gateway setting（note: restart）\n Add these dependencies in pom.xml:\n  \u0026amp;lt;!--soul data sync start use zookeeper--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   Add these dependencies in springboot yaml file:\nsoul : sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000 #url: config with your zk address, used by the cluster environment, splitted with (,).   soul-admin config: configure the soul-admin\u0026amp;rsquo;s starting parameter with --soul.sync.zookeeper.url=\u0026#39;your address\u0026#39;,then restart the service. yaml soul: sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000    It is good to use ZooKeeper synchronization mechanism with high timeliness, but we also have to deal with the unstable environment of ZK, cluster brain splitting and other problems.\n  Http long-polling sync  gateway setting（note:restart）\n Add these dependencies in pom.xml：   \u0026amp;lt;!--soul data sync start use http--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-http\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   add these config values in your springboot yaml file:\nsoul : sync: http: url: http://localhost:9095 #url: config with your soul-admin\u0026#39;s ip and port url, pls use (,) to split multi-admin cluster environment.   soul-admin config, configure the soul-admin\u0026amp;rsquo;s starting parameter with --soul.sync.http=\u0026#39;\u0026#39;, then restart service. yaml soul: sync: http:   HTTP long-polling makes the gateway lightweight, but less time-sensitive.\n It pulls according to the group key, if the …","date":-62135596800,"description":"use different data-sync strategy.","dir":"projects/soul/use-data-sync/","fuzzywordcount":500,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"e7345f74a43610757808df61ffafa48e","permalink":"/en/projects/soul/use-data-sync/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/en/projects/soul/use-data-sync/","summary":"Features  Data synchronization is the key of gateway high performance, which is to sync \u0026lsquo;soul-admin\u0026rsquo; config data into the JVM memory of soul cluster.\n Implementation principles, pls refer to：dataSync。\n In the article, the gateway is the environment you setup. please refer to：Environment Setup.\n  Websocket sync（default method，recommend）  gateway setting（note:restart）\n Add these dependencies in pom.xml：\n\u0026lt;!--soul data sync start use websocket--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-sync-data-websocket\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${last.","tags":null,"title":"use different data-sync strategy.","type":"projects","url":"/en/projects/soul/use-data-sync/","wordcount":449},{"author":null,"categories":null,"content":" 说明  waf插件，是网关的用来对流量实现防火墙功能的核心实现。  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理-\u0026amp;gt; waf 设置为开启。\n 如果用户不想使用此功能，请在admin后台停用此插件。\n 插件编辑里面新增配置模式。\n{\u0026amp;quot;model\u0026amp;quot;:\u0026amp;quot;black\u0026amp;quot;} # 默认为黑名单模式，设置值为 mixed 则为混合模式，下面会专门进行讲解  插件使用  在网关的 pom.xml 文件中添加 waf 的支持。 xml \u0026amp;lt;!-- soul waf plugin start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-plugin-waf\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!-- soul waf plugin end--\u0026amp;gt;   选择器和规则，请详细看：选择器规则\n 当 module 设置为 black 模式的时候，只有匹配的流量才会执行拒绝策略，不匹配的，直接会跳过。\n 当 module 设置为 mixed 模式的时候，所有的流量都会通过 waf插件，针对不同的匹配流量，用户可以设置是 拒绝，还是通过。\n   场景  waf插件也是soul的前置插件，主要用来拦截非法请求，或者异常请求，并且给与相关的拒绝策略。\n 当面对重放攻击时，你可以根据ip或者host来进行匹配，拦截掉非法的ip与host，设置reject策略。\n 关于如何确定 ip 与 host 值，请看ip与host\n  ","date":-62135596800,"description":"waf插件","dir":"projects/soul/waf-plugin/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"d175f0c39ea54f421cd2d98ad556c59a","permalink":"/projects/soul/waf-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/waf-plugin/","summary":"说明 waf插件，是网关的用来对流量实现防火墙功能的核心实现。 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理-\u0026gt; waf 设置为开启。 如果用户不想使用此功能，请在adm","tags":null,"title":"waf插件","type":"projects","url":"/projects/soul/waf-plugin/","wordcount":390},{"author":null,"categories":null,"content":" 说明  soul网关是支持 websocket的代理。\n websocket支持中，使用了divide插件。\n  插件设置  在 soul-admin \u0026amp;ndash;\u0026amp;gt; 插件管理 \u0026amp;ndash;\u0026amp;gt; divide，设置为开启。\n 在网关的 pom.xml 文件中新增依赖 ```xml  org.dromara soul-spring-boot-starter-plugin-divide ${last.version} \n   org.dromara soul-spring-boot-starter-plugin-httpclient ${last.version} \n## 请求路径 * 使用soul代理websocket的时候，其请求路径为（例子）：`ws://localhost:9195/?module=ws\u0026amp;amp;method=/websocket\u0026amp;amp;rpcType=websocket`。 ```yaml 参数详解: 1.localhost:8080 是soul启动的ip和端口。 2.module（必填）：值是你用来匹配selector的关键 3.method （参数）: 你的 websocket路径，同时也用做匹配rule 4.rpcType ：websocket 必填，且必须为websocket   在 divide插件中选择器新增一条配置，如下   在这一条选择器下新增一条 规则 ：   总结，这个时候注意看你的路径 ws://localhost:9195/?module=ws\u0026amp;amp;method=/websocket\u0026amp;amp;rpcType=websocket。  它就会被你新增的选择器规则匹配，然后代理的的真实websocket地址为：127.0.0.1:8080/websocket，这样soul就进行的websocket的代理。\n你就可以进行和websocket服务进行通信了，就是这么简单。\n 最后再说一句，module，method 命名和值，你完全可以自己来决定，我的只是列子，只要选择器 和规则能够匹配就行。\n  ","date":-62135596800,"description":"websocket支持","dir":"projects/soul/websocket-plugin/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"46f34e44018715aa860dfb5871c3b53d","permalink":"/projects/soul/websocket-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/soul/websocket-plugin/","summary":"说明 soul网关是支持 websocket的代理。 websocket支持中，使用了divide插件。 插件设置 在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; divide，设置","tags":null,"title":"websocket支持","type":"projects","url":"/projects/soul/websocket-plugin/","wordcount":618},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"使用该指南您可以快速部署应用到 CloudMesh ，对服务进行访问，通过监控查看流量，体验服务治理、Sidecar管理和对服务的新版本进行灰度发布等实用功能。","dir":"guides/kc-cloud-mesh-demo/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"e389a65e6736e909718275cd76505525","permalink":"/guides/kc-cloud-mesh-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/guides/kc-cloud-mesh-demo/","summary":"","tags":null,"title":"使用 CloudMesh 轻松实践 Service Mesh","type":"guides","url":"/guides/kc-cloud-mesh-demo/","wordcount":0},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"本指南将基于 SOFAStack 快速构建一个微服务。","dir":"guides/sofastack-quick-start/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"78bfd4806a86dc15ac86eee16fb85c82","permalink":"/guides/sofastack-quick-start/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/guides/sofastack-quick-start/","summary":"","tags":null,"title":"使用 SOFAStack 快速构建微服务","type":"guides","url":"/guides/sofastack-quick-start/","wordcount":0},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"该指南将向您展示如何使用开源分布式事务框架 Seata 的 AT 模式、TCC 模式解决业务数据的最终一致性问题。 ","dir":"guides/kc-seata-demo/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"60071a0eb44bf0901fb187eefd63ccdb","permalink":"/guides/kc-seata-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/guides/kc-seata-demo/","summary":"","tags":null,"title":"使用 Seata 保障支付一致性","type":"guides","url":"/guides/kc-seata-demo/","wordcount":0},{"author":null,"categories":null,"content":" 说明  数据同步是指将 soul-admin 配置的数据，同步到 soul 集群中的JVM内存里面，是网关高性能的关键。\n 实现原理，请看：数据同步。\n 文中所说的网关，是指你搭建的网关环境，请看：搭建环境。\n  websocket同步（默认方式，推荐）  网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：\n\u0026amp;lt;!--soul data sync start use websocket--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-websocket\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 springboot的 yml 文件中进行如下配置: yaml soul : sync: websocket : urls: ws://localhost:9095/websocket #urls:是指 soul-admin的地址，如果有多个，请使用（,）分割.    soul-admin 配置，或在 soul-admin 启动参数中设置 --soul.sync.websocket=\u0026#39;\u0026#39;，然后重启服务。\nsoul: sync: websocket:   当建立连接以后会全量获取一次数据，以后的数据都是增量的更新与新增，性能好。\n 支持断线重连 （默认30秒）。\n  zookeeper同步  网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：\n  \u0026amp;lt;!--soul data sync start use zookeeper--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-zookeeper\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 springboot的 yml 文件中进行如下配置:\nsoul : sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000 #url: 配置成你的zk地址，集群环境请使用（,）分隔   soul-admin 配置, 或在 soul-admin 启动参数中设置 --soul.sync.zookeeper.url=\u0026#39;你的地址\u0026#39;,然后重启服务。 yaml soul: sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000    使用zookeeper同步机制也是非常好的,时效性也高，我们生产环境使用的就是这个，但是也要处理zk环境不稳定，集群脑裂等问题.\n  http长轮询同步  网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：   \u0026amp;lt;!--soul data sync start use http--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-http\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 springboot的 yml 文件中进行如下配置:\nsoul : sync: http: url: http://localhost:9095 #url: 配置成你的 soul-admin的 ip与端口地址，多个admin集群环境请使用（,）分隔。   soul-admin 配置, 或在 soul-admin 启动参数中设置 --soul.sync.http=\u0026#39;\u0026#39;,然后重启服务。 yaml soul: sync: http:   http长轮询使得网关很轻量，时效性略低。\n 其根据分组key来拉取，如果数据量过大，过多，会有一定的影响。 什么意思呢？就是一个组下面的一个小地方更改，会拉取整个的组数据。\n 在soul-admin 集群时候，可能会有bug。\n  nacos同步  网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：\n\u0026amp;lt;!--soul data sync start use nacos--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-nacos\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在 springboot的 yml 文件中进行如下配置:\nsoul : sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c acm: enabled: false endpoint: acm.aliyun.com namespace: accessKey: secretKey: #url: 配置成你的nacos地址，集群环境请使用（,）分隔。 # 其他参数配置，请参考naocs官网。    soul-admin 配置, 或在 soul-admin 启动参数中使用 -- 的方式一个一个传值。\nsoul : sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c acm: enabled: false endpoint: acm.aliyun.com namespace: accessKey: secretKey:   ","date":-62135596800,"description":"使用不同的数据同步策略","dir":"projects/soul/use-data-sync/","fuzzywordcount":1000,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"e7345f74a43610757808df61ffafa48e","permalink":"/projects/soul/use-data-sync/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/soul/use-data-sync/","summary":"说明 数据同步是指将 soul-admin 配置的数据，同步到 soul 集群中的JVM内存里面，是网关高性能的关键。 实现原理，请看：数据同步。 文中所说的网关，是指你搭建的网","tags":null,"title":"使用不同的数据同步策略","type":"projects","url":"/projects/soul/use-data-sync/","wordcount":974},{"author":null,"categories":null,"content":" 说明  本篇主要讲解在soul网关中元数据的概念，设计，以及如何对接。  技术方案  在数据库中，新增了一张表，然后通过数据同步的方案，会把这张表的数据同步到网关JVM内存。\n 表结构如下：\nCREATE TABLE IF NOT EXISTS `meta_data` ( `id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;id\u0026#39;, `app_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;应用名称\u0026#39;, `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;路径,不能重复\u0026#39;, `path_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;路径描述\u0026#39;, `rpc_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;rpc类型\u0026#39;, `service_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;服务名称\u0026#39;, `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;方法名称\u0026#39;, `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;参数类型 多个参数类型 逗号隔开\u0026#39;, `rpc_ext` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT \u0026#39;rpc的扩展信息，json格式\u0026#39;, `date_created` datetime(0) NOT NULL COMMENT \u0026#39;创建时间\u0026#39;, `date_updated` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT \u0026#39;更新时间\u0026#39;, `enabled` tinyint(4) NOT NULL DEFAULT 0 COMMENT \u0026#39;启用状态\u0026#39;, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;   元数据设计，目前最主要的是对dubbo的泛化调用上进行使用。\n 我重点讲一下 path 字段，在请求网关的时候，会根据你的path字段来匹配到一条数据，然后进行后续的流程.\n 重点讲一下 rpc_ext字段，如果是dubbo类型的服务接口，如果服务接口设置了group和version字段的时候，会存在这个字段。\n dubbo 类型 字段结构是 如下，那么存储的就是json格式的字符串。\n  public static class RpcExt { private String group; private String version; private String loadbalance; private Integer retries; private Integer timeout; }   元数据存储  每个dubbo接口方法，对应一条元数据。\n springcloud协议，只会存储一条数据， path为 /contextPath/**。\n http服务，则不会有任何数据。\n  ","date":-62135596800,"description":"元数据概念设计","dir":"projects/soul/meta-data/","fuzzywordcount":700,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"e4bb78fd2e6f8f05d641328371f2cd29","permalink":"/projects/soul/meta-data/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/soul/meta-data/","summary":"说明 本篇主要讲解在soul网关中元数据的概念，设计，以及如何对接。 技术方案 在数据库中，新增了一张表，然后通过数据同步的方案，会把这张表的数据","tags":null,"title":"元数据概念设计","type":"projects","url":"/projects/soul/meta-data/","wordcount":611},{"author":null,"categories":null,"content":" raincat-admin 启动教程  启动前提：分布式事务项目已经部署并且运行起来，用户根据自己的RPC框架进行使用 dubbo 用户 springcloud 用户  启动方式一：自己打包进行部署。  首先用户使用的JDK必须是1.8+ 本地安装了git ,maven ，执行以下命令\ngit clone https://github.com/yu199195/Raincat.git maven clean install  使用你的开发工具打开项目，比如idea Eclipse\n  修改application.yml server: port: 8888 context-path: /admin spring: application: name: raincat-admin profiles: active: db tx: admin : userName : admin password : admin redis: hostName: localhost port : 6379 #password: cluster : false # nodes: 127.0.0.1:70001;127.0.1:7002 # redirects: 20   userName，password 是你登录的用户名与密码。\n reids配置为你的txManager的redis配置。\n spring.profiles.active 是你激活的方式，意思就是你采用什么方式来存储日志的，就激活什么方式，然后修改对应的yml。比如这里使用的db那么我们找到application-db.yml\n  recover: application: list : alipay-service,wechat-service,pay-service serializer : support: kryo retry : max: 10 db: driver : com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/tx?useUnicode=true\u0026amp;amp;amp;characterEncoding=utf8 username: root password: 123456   application.list是指你微服务的applicationName，用逗号分隔。\n serializer : 事务日志的序列化方式\n retry.max ： 最大重试次数。\n  修改index.html \u0026amp;lt;!--href 修改成你的ip 端口--\u0026amp;gt; \u0026amp;lt;a id=\u0026amp;quot;serverIpAddress\u0026amp;quot; style=\u0026amp;quot;display: none\u0026amp;quot; href=\u0026amp;quot;http://192.168.1.132:8888/admin\u0026amp;quot;\u0026amp;gt;  运行 AdminApplication 中的main方法。 在浏览器访问 http://ip:port/admin ,输入用户名，密码登录。 启动方式二：从maven中心仓库获取adminjar包 . \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;raincat-admin\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.0.0-RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   创建config文件夹，创建application.yml等，然后修改启动。  ","date":-62135596800,"description":"启动raincat-admin","dir":"projects/raincat/admin-starter/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"6bae554a4c091ab0842f51371a4cccb6","permalink":"/projects/raincat/admin-starter/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/raincat/admin-starter/","summary":"raincat-admin 启动教程 启动前提：分布式事务项目已经部署并且运行起来，用户根据自己的RPC框架进行使用 dubbo 用户 springcloud 用户 启动方式一：自己打包进行部署。 首先用户使","tags":null,"title":"启动raincat-admin","type":"projects","url":"/projects/raincat/admin-starter/","wordcount":538},{"author":null,"categories":null,"content":" 启动raincat-manager 方式一：自己拉取代码编译：https://github.com/yu199195/Raincat  修改application.yml 中的redis配置 yml transactionWaitMaxTime: 500 redisSaveMaxTime: 3000 tx: manager: netty : port: 9998 serialize: kryo maxConnection: 100 maxThreads : 16 delayTime : 5 heartTime : 20 redis : cluster : false hostName : 192.168.1.91 port: 6379 password : foobaredbbexONE123  * transactionWaitMaxTime 事务最大等待时间 * redisSaveMaxTime redis存储最大等待时间 * tx:manager:netty 解释 * port 是只netty长连接的netty端口（可以自行修改） * serialize netty自定义序列化协议（推荐使用kroy这个要与客户端的序列化协议对应） * maxConnection 最大长连接数量 * maxThreads netty work线程数量 * heartTime 心跳时间（单位秒） ### 启动方式二：直接从maven中央仓库获取raincat-manager jar包。 * 建立config目录，新增applicationyml配置文件并修改。覆盖jar包里面的applicationyml。具体的请参考springboot配置文件读取顺序。  ","date":-62135596800,"description":"启动raincat-manager","dir":"projects/raincat/raincat-manager-starter/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"2543da84e28af091114bec655a3487b0","permalink":"/projects/raincat/raincat-manager-starter/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/raincat/raincat-manager-starter/","summary":"启动raincat-manager 方式一：自己拉取代码编译：https://github.com/yu199195/Raincat 修改app","tags":null,"title":"启动raincat-manager","type":"projects","url":"/projects/raincat/raincat-manager-starter/","wordcount":382},{"author":null,"categories":null,"content":" 团队成员（排名不分先后）    名字 github 角色 所在公司     肖宇 yu199195 VP 京东   张永伦 tuohai666 committer 京东   赵俊 cherrylzhao committer 联通   陈斌 prFor committer 某创业公司   李浪 cysy-lli committer 携程   汤煜冬 tydhot committer perfma    ","date":-62135596800,"description":"团队介绍","dir":"projects/hmily/team/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"7d27bab44ea88b422afcda3ff9b66b36","permalink":"/projects/hmily/team/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/team/","summary":"团队成员（排名不分先后） 名字 github 角色 所在公司 肖宇 yu199195 VP 京东 张永伦 tuohai666 committer 京东 赵俊 cherrylzhao committer 联通 陈斌 prFor committer 某创业公司 李浪 cysy-lli committer 携程 汤煜冬 tydhot committer perfma","tags":null,"title":"团队介绍","type":"projects","url":"/projects/hmily/team/","wordcount":61},{"author":null,"categories":null,"content":" 团队成员（排名不分先后） |名字 | github | 角色 | 所在公司 | |:\u0026amp;mdash;\u0026amp;mdash;\u0026amp;ndash; |:\u0026amp;mdash;\u0026amp;ndash; |:\u0026amp;mdash;\u0026amp;mdash;-: |:\u0026amp;mdash;\u0026amp;mdash;-:| |肖宇 |yu199195 | VP | 京东 | |张永伦 |tuohai666 | PMC | 京东 | |邓力铭 |dengliming | PMC | 某创业公司 | |汤昱东 |tydhot | PMC | perfma | |张磊 |SaberSola | PMC | 哈罗 | |陈斌 |prFor | PMC | 某创业公司 | |黄晓峰 |huangxfchn | committer | shein | |梁自强 |241600489 | committer | 滴滴 | |庄浩潮 |dmsolr | committer | 欢聚时代（YY） | |蒋晓峰 |SteNicholas | committer | 阿里云 | |丁剑明 |nuo-promise | committer | 某创业公司 |\n","date":-62135596800,"description":"团队介绍","dir":"projects/soul/team/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"42ecc8eaa96819548d640c00c6bae90b","permalink":"/projects/soul/team/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/team/","summary":"团队成员（排名不分先后） |名字 | github | 角色 | 所在公司 | |:\u0026mdash;\u0026mdash;\u0026ndash; |:\u0026mdash;\u0026ndash; |:\u0026mdash;\u0026mdash;-: |:\u0026mdash;\u0026mdash;-:| |肖宇 |yu199195 | VP | 京东 | |张永伦 |tuohai666 | PMC | 京东 | |邓力铭 |dengliming | PMC | 某创业公司 | |汤昱东 |tydhot","tags":null,"title":"团队介绍","type":"projects","url":"/projects/soul/team/","wordcount":162},{"author":null,"categories":null,"content":"","date":-62135596800,"description":"使用该指南您可以体验到快速创建 Serveless 应用、根据业务请求秒级 0-1-N 自动伸缩、通过日志查看器快速排错、按时间触发应用等产品新功能。","dir":"guides/kc-serverless-demo/","fuzzywordcount":100,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"f355d1b598fed47b730bd74ad25f3683","permalink":"/guides/kc-serverless-demo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/guides/kc-serverless-demo/","summary":"","tags":null,"title":"基于 Serverless 轻松构建云上应用","type":"guides","url":"/guides/kc-serverless-demo/","wordcount":0},{"author":null,"categories":null,"content":" 说明  本文主要讲解其他语言的http服务如何接入网关。\n 如何自定义开发 soul-http-client\n  自定义开发  请求方式：POST\n 请求路径\n http://soul-admin/soul-client/springmvc-register soul-admin，表示为 admin的 ip + port  请求参数\n soul网关默认的需要参数，通过body里面传，json类型。\n{ \u0026amp;quot;appName\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //应用名称 必填 \u0026amp;quot;context\u0026amp;quot;: \u0026amp;quot;/xxx\u0026amp;quot;, //请求前缀 必填 \u0026amp;quot;path\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //路径需要唯一 必填 \u0026amp;quot;pathDesc\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //路径描述 \u0026amp;quot;rpcType\u0026amp;quot;: \u0026amp;quot;http\u0026amp;quot;, //rpc类型 必填 \u0026amp;quot;host\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //服务host 必填 \u0026amp;quot;port\u0026amp;quot;: xxx, //服务端口 必填 \u0026amp;quot;ruleName\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //可以同path一样 必填 \u0026amp;quot;enabled\u0026amp;quot;: \u0026amp;quot;true\u0026amp;quot;, //是否开启 \u0026amp;quot;registerMetaData\u0026amp;quot;: \u0026amp;quot;true\u0026amp;quot; //是否需要注册元数据 }   ","date":-62135596800,"description":"多语言http客户端","dir":"projects/soul/developer-soul-client/","fuzzywordcount":300,"kind":"page","lang":"en","lastmod":1611505634,"objectID":"edcbca19cf9442e7687c0972e0747f41","permalink":"/en/projects/soul/developer-soul-client/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/en/projects/soul/developer-soul-client/","summary":"说明 本文主要讲解其他语言的http服务如何接入网关。 如何自定义开发 soul-http-client 自定义开发 请求方式：POST 请求路径 http://soul-admin/soul-client/springmvc-register soul-admin，表示为 adm","tags":null,"title":"多语言http客户端","type":"projects","url":"/en/projects/soul/developer-soul-client/","wordcount":222},{"author":null,"categories":null,"content":" 说明  本文主要讲解其他语言的http服务如何接入网关。\n 如何自定义开发 soul-http-client\n  自定义开发  请求方式：POST\n 请求路径\n http://soul-admin/soul-client/springmvc-register soul-admin，表示为 admin的 ip + port  请求参数\n soul网关默认的需要参数，通过body里面传，json类型。\n{ \u0026amp;quot;appName\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //应用名称 必填 \u0026amp;quot;context\u0026amp;quot;: \u0026amp;quot;/xxx\u0026amp;quot;, //请求前缀 必填 \u0026amp;quot;path\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //路径需要唯一 必填 \u0026amp;quot;pathDesc\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //路径描述 \u0026amp;quot;rpcType\u0026amp;quot;: \u0026amp;quot;http\u0026amp;quot;, //rpc类型 必填 \u0026amp;quot;host\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //服务host 必填 \u0026amp;quot;port\u0026amp;quot;: xxx, //服务端口 必填 \u0026amp;quot;ruleName\u0026amp;quot;: \u0026amp;quot;xxx\u0026amp;quot;, //可以同path一样 必填 \u0026amp;quot;enabled\u0026amp;quot;: \u0026amp;quot;true\u0026amp;quot;, //是否开启 \u0026amp;quot;registerMetaData\u0026amp;quot;: \u0026amp;quot;true\u0026amp;quot; //是否需要注册元数据 }   ","date":-62135596800,"description":"多语言http客户端","dir":"projects/soul/developer-soul-client/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"edcbca19cf9442e7687c0972e0747f41","permalink":"/projects/soul/developer-soul-client/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/developer-soul-client/","summary":"说明 本文主要讲解其他语言的http服务如何接入网关。 如何自定义开发 soul-http-client 自定义开发 请求方式：POST 请求路径 http://soul-admin/soul-client/springmvc-register soul-admin，表示为 adm","tags":null,"title":"多语言http客户端","type":"projects","url":"/projects/soul/developer-soul-client/","wordcount":222},{"author":null,"categories":null,"content":" 说明  字典管理主要用来维护和管理公用数据字典  表设计  sql sql CREATE TABLE IF NOT EXISTS `soul_dict` ( `id` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;主键id\u0026#39;, `type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;类型\u0026#39;, `dict_code` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;字典编码\u0026#39;, `dict_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \u0026#39;字典名称\u0026#39;, `dict_value` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;字典值\u0026#39;, `desc` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT \u0026#39;字典描述或备注\u0026#39;, `sort` int(4) NOT NULL COMMENT \u0026#39;排序\u0026#39;, `enabled` tinyint(4) DEFAULT NULL COMMENT \u0026#39;是否开启\u0026#39;, `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;  * 目前使用场景是插件处理配置data_type=3下拉框时使用 假如sentinel插件处理字段中的degradeRuleGrade 那么新增规则时，编辑degradeRuleGrade字段时会自动从字典表查出type=degradeRuleGrade的所有字典作为下拉选项。  ","date":-62135596800,"description":"字典管理详解","dir":"projects/soul/dictionary-management/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"e863725978b7cf19ab005f1950deae5d","permalink":"/projects/soul/dictionary-management/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/dictionary-management/","summary":"说明 字典管理主要用来维护和管理公用数据字典 表设计 sql sql CREATE TABLE IF NOT EXISTS `soul_dict` ( `id` varchar(128) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '主键id', `type` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '类型', `dict_code` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '字典编","tags":null,"title":"字典管理","type":"projects","url":"/projects/soul/dictionary-management/","wordcount":314},{"author":null,"categories":null,"content":" 说明  在soul-admin后台，每个插件都用handle（json格式）字段来表示不同的处理，而插件处理是就是用来管理编辑json里面的自定义处理字段。 该功能主要是用来支持插件处理模板化配置的  表设计  sql\nCREATE TABLE IF NOT EXISTS `plugin_handle` ( `id` varchar(128) NOT NULL, `plugin_id` varchar(128) NOT NULL COMMENT \u0026#39;插件id\u0026#39;, `field` varchar(100) NOT NULL COMMENT \u0026#39;字段\u0026#39;, `label` varchar(100) DEFAULT NULL COMMENT \u0026#39;标签\u0026#39;, `data_type` smallint(6) NOT NULL DEFAULT \u0026#39;1\u0026#39; COMMENT \u0026#39;数据类型 1 数字 2 字符串 3 下拉框\u0026#39;, `type` smallint(6) NULL COMMENT \u0026#39;类型,1 表示选择器，2 表示规则\u0026#39;, `sort` int(4) NULL COMMENT \u0026#39;排序\u0026#39;, `ext_obj` varchar(1024) DEFAULT NULL COMMENT \u0026#39;额外配置（json格式数据）\u0026#39;, `date_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, `date_updated` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \u0026#39;更新时间\u0026#39;, PRIMARY KEY (`id`), UNIQUE KEY `plugin_id_field_type` (`plugin_id`,`field`,`type`) ) ENGINE=InnoDB;  使用教程 比如开发springCloud插件时规则表需要存一些配置到handle字段，配置对应的实体类如下：\npublic class SpringCloudRuleHandle implements RuleHandle { /** * this remote uri path. */ private String path; /** * timeout is required. */ private long timeout = Constants.TIME_OUT; } }   第一步、我们可以直接在插件管理界面 http://localhost:9095/#/system/plugin 点击编辑插件处理 第二步、新增一个字符串类型字段path和一个数字类型的timeout\n第三步、在插件规则配置页面新增规则时就可以直接输入path、timeout然后提交保存到handle字段了\n_注意：如果配置了data_type为3 选择框，则规则新增页面里输入框下拉选择是通过field字段去字典表（soul_dict）查出所有可选项出来展示选择_。\n 比如sentinel插件包含多种数据类型的字段，如下图：  ","date":-62135596800,"description":"插件处理详解","dir":"projects/soul/plugin-handle-explanation/","fuzzywordcount":600,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"7dfecb0b1e78397da38ffb4a5d4efd4d","permalink":"/projects/soul/plugin-handle-explanation/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/projects/soul/plugin-handle-explanation/","summary":"说明 在soul-admin后台，每个插件都用handle（json格式）字段来表示不同的处理，而插件处理是就是用来管理编辑json里面的自定","tags":null,"title":"插件处理详解","type":"projects","url":"/projects/soul/plugin-handle-explanation/","wordcount":563},{"author":null,"categories":null,"content":" 说明  插件是 soul 网关的核心执行者，每个插件在开启的情况下，都会对匹配的流量，进行自己的处理。\n 在soul 网关里面，插件其实分为2 类：\n 一类是单一职责的调用链，不能对流量进行自定义的筛选。\n 另一类，能对匹配的流量，执行自己的职责调用链。\n  用户可以参考 soul-plugin 模块，新增自己的插件处理，如果有好的公用插件，请把代码提交上来。\n  单一职责插件  引入如下依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-plugin-api\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;  用户新增一个类 A，直接实现 org.dromara.soul.plugin.api.SoulPlugin\n  public interface SoulPlugin { /** * Process the Web request and (optionally) delegate to the next * {@code WebFilter} through the given {@link SoulPluginChain}. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026amp;lt;Void\u0026amp;gt;} to indicate when request processing is complete */ Mono\u0026amp;lt;Void\u0026amp;gt; execute(ServerWebExchange exchange, SoulPluginChain chain); /** * return plugin order . * This attribute To determine the plugin execution order in the same type plugin. * * @return int order */ int getOrder(); /** * acquire plugin name. * this is plugin name define you must Provide the right name. * if you impl AbstractSoulPlugin this attribute not use. * * @return plugin name. */ default String named() { return \u0026amp;quot;\u0026amp;quot;; } /** * plugin is execute. * if return true this plugin can not execute. * * @param exchange the current server exchange * @return default false. */ default Boolean skip(ServerWebExchange exchange) { return false; } }   接口方法详细说明\n execute() 方法为核心的执行方法，用户可以在里面自由的实现自己想要的功能。\n getOrder() 指定插件的排序。\n named() 指定插件的名称。\n skip() 在特定的条件下，该插件是否被跳过。\n  注册成Spring的bean，参考如下，或者直接在实现类上加 @Component 注解。\n  @Bean public SoulPlugin a() { return new A(); }  匹配流量处理插件  引入如下依赖：\n\u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-plugin-base\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   新增一个类A，继承 org.dromara.soul.plugin.base.AbstractSoulPlugin\n 以下是参考：\n  /** * This is your custom plugin. * He is running in after before plugin, implement your own functionality. * extends AbstractSoulPlugin so you must user soul-admin And add related plug-in development. * * @author xiaoyu(Myth) */ public class CustomPlugin extends AbstractSoulPlugin { /** * return plugin order . * The same plugin he executes in the same order. * * @return int */ @Override public int getOrder() { return 0; } /** * acquire plugin name. * return you custom plugin name. * It must be the same name as the plug-in you added in the admin background. * * @return plugin name. */ @Override public String named() { return \u0026amp;quot;soul\u0026amp;quot;; } /** * plugin is execute. * Do I need to skip. * if you need skip return true. * * @param exchange the current server exchange * @return default false. */ @Override public Boolean skip(final ServerWebExchange exchange) { return false; } @Override protected Mono\u0026amp;lt;Void\u0026amp;gt; doExecute(ServerWebExchange exchange, SoulPluginChain chain, SelectorZkDTO selector, RuleZkDTO rule) { …","date":-62135596800,"description":"插件扩展","dir":"projects/soul/custom-plugin/","fuzzywordcount":1200,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"ea7d6dfc24653d73e785007935508cf7","permalink":"/projects/soul/custom-plugin/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/projects/soul/custom-plugin/","summary":"说明 插件是 soul 网关的核心执行者，每个插件在开启的情况下，都会对匹配的流量，进行自己的处理。 在soul 网关里面，插件其实分为2 类： 一类是单一职责","tags":null,"title":"插件扩展","type":"projects","url":"/projects/soul/custom-plugin/","wordcount":1174},{"author":null,"categories":null,"content":" 说明  本篇主要讲解数据库同步的三种方式，以及原理  前言 网关是流量请求的入口，在微服务架构中承担了非常重要的角色，网关高可用的重要性不言而喻。在使用网关的过程中，为了满足业务诉求，经常需要变更配置，比如流控规则、路由规则等等。因此，网关动态配置是保障网关高可用的重要因素。那么，Soul 网关又是如何支持动态配置的呢？\n使用过 Soul 的同学都知道，Soul 的插件全都是热插拔的，并且所有插件的选择器、规则都是动态配置，立即生效，不需要重启服务。但是我们在使用 Soul 网关过程中，用户也反馈了不少问题\n 依赖 zookeeper，这让使用 etcd、consul、nacos 注册中心的用户很是困扰 依赖 redis、influxdb，我还没有使用限流插件、监控插件，为什么需要这些  因此，我们对 Soul 进行了局部重构，历时两个月的版本迭代，我们发布了 2.0 版本\n 数据同步方式移除了对 zookeeper 的强依赖，新增 http 长轮询 以及 websocket 限流插件与监控插件实现真正的动态配置，由之前的 yml 配置，改为 admin 后台用户动态配置  1.可能有人会问我，配置同步为什么不使用配置中心呢？ 答：首先，引入配置中心，会增加很多额外的成本，不光是运维，而且会让 Soul 变得很重；另外，使用配置中心，数据格式不可控，不便于 soul-admin 进行配置管理。\n2.可能还有人会问？动态配置更新？每次我查数据库，或者redis不就行了吗？拿到的就是最新的，哪里那么多事情呢？ 答：soul作为网关，为了提供更高的响应速度，所有的配置都缓存在JVM的Hashmap中，每次请求都走的本地缓存，速度非常快。所以本文也可以理解为分布式环境中，内存同步的三种方式。\n原理分析 先来张高清无码图，下图展示了 Soul 数据同步的流程，Soul 网关在启动时，会从从配置服务同步配置数据，并且支持推拉模式获取配置变更信息，并且更新本地缓存。而管理员在管理后台，变更用户、规则、插件、流量配置，通过推拉模式将变更信息同步给 Soul 网关，具体是 push 模式，还是 pull 模式取决于配置。关于配置同步模块，其实是一个简版的配置中心。 在 1.x 版本中，配置服务依赖 zookeeper 实现，管理后台将变更信息 push 给网关。而 2.x 版本支持 webosocket、http、zookeeper，通过 soul.sync.strategy 指定对应的同步策略，默认使用 http 长轮询同步策略，可以做到秒级数据同步。但是，有一点需要注意的是，soul-web 和 soul-admin 必须使用相同的同步机制。\n如下图所示，soul-admin 在用户发生配置变更之后，会通过 EventPublisher 发出配置变更通知，由 EventDispatcher 处理该变更通知，然后根据配置的同步策略(http、weboscket、zookeeper)，将配置发送给对应的事件处理器\n 如果是 websocket 同步策略，则将变更后的数据主动推送给 soul-web，并且在网关层，会有对应的 WebsocketCacheHandler 处理器处理来处 admin 的数据推送 如果是 zookeeper 同步策略，将变更数据更新到 zookeeper，而 ZookeeperSyncCache 会监听到 zookeeper 的数据变更，并予以处理 如果是 http 同步策略，soul-web 主动发起长轮询请求，默认有 90s 超时时间，如果 soul-admin 没有数据变更，则会阻塞 http 请求，如果有数据发生变更则响应变更的数据信息，如果超过 60s 仍然没有数据变更则响应空数据，网关层接到响应后，继续发起 http 请求，反复同样的请求   zookeeper同步 基于 zookeeper 的同步原理很简单，主要是依赖 zookeeper 的 watch 机制，soul-web 会监听配置的节点，soul-admin 在启动的时候，会将数据全量写入 zookeeper，后续数据发生变更时，会增量更新 zookeeper 的节点，与此同时，soul-web 会监听配置信息的节点，一旦有信息变更时，会更新本地缓存。\nsoul 将配置信息写到zookeeper节点，是通过精细设计的。\nwebsocket同步 websocket 和 zookeeper 机制有点类似，将网关与 admin 建立好 websocket 连接时，admin 会推送一次全量数据，后续如果配置数据发生变更，则将增量数据通过 websocket 主动推送给 soul-web\n使用websocket同步的时候，特别要注意断线重连，也叫保持心跳。soul使用java-websocket 这个第三方库来进行websocket连接。\npublic class WebsocketSyncCache extends WebsocketCacheHandler { /** * The Client. */ private WebSocketClient client; public WebsocketSyncCache(final SoulConfig.WebsocketConfig websocketConfig) { ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1, SoulThreadFactory.create(\u0026amp;quot;websocket-connect\u0026amp;quot;, true)); client = new WebSocketClient(new URI(websocketConfig.getUrl())) { @Override public void onOpen(final ServerHandshake serverHandshake) { //.... } @Override public void onMessage(final String result) { //.... } }; //进行连接 client.connectBlocking(); //使用调度线程池进行断线重连，30秒进行一次 executor.scheduleAtFixedRate(() -\u0026amp;gt; { if (client != null \u0026amp;amp;\u0026amp;amp; client.isClosed()) { client.reconnectBlocking(); } }, 10, 30, TimeUnit.SECONDS); }  http长轮询 zookeeper、websocket 数据同步的机制比较简单，而 http 同步会相对复杂一些。Soul 借鉴了 Apollo、Nacos 的设计思想，取其精华，自己实现了 http 长轮询数据同步功能。注意，这里并非传统的 ajax 长轮询！\nhttp 长轮询机制如上所示，soul-web 网关请求 admin 的配置服务，读取超时时间为 90s，意味着网关层请求配置服务最多 …","date":-62135596800,"description":"数据同步设计","dir":"projects/soul/data-sync/","fuzzywordcount":2900,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"44541232a1c4007603f020e22e1b918f","permalink":"/projects/soul/data-sync/","publishdate":"0001-01-01T00:00:00Z","readingtime":6,"relpermalink":"/projects/soul/data-sync/","summary":"说明 本篇主要讲解数据库同步的三种方式，以及原理 前言 网关是流量请求的入口，在微服务架构中承担了非常重要的角色，网关高可用的重要性不言而喻。在使","tags":null,"title":"数据同步设计","type":"projects","url":"/projects/soul/data-sync/","wordcount":2841},{"author":null,"categories":null,"content":" 插件采用数据库设计，来存储插件，选择器，规则配置数据，以及对应关系。\n 数据库表UML类图:\n   设计详解:\n 一个插件对应多个选择器，一个选择器对应多个规则。\n 一个选择器对应多个匹配条件，一个规则对应多个匹配条件。\n 每个规则在对应插件下，不同的处理表现为handle字段，handle字段就是一个json字符串。具体的可以在admin使用过程中进行查看。\n   ","date":-62135596800,"description":"数据库设计","dir":"projects/soul/database-design/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"8f46db9ca33a0c500e83211cca567d46","permalink":"/projects/soul/database-design/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/database-design/","summary":"插件采用数据库设计，来存储插件，选择器，规则配置数据，以及对应关系。 数据库表UML类图: 设计详解: 一个插件对应多个选择器，一个选择器对应多个","tags":null,"title":"数据库设计","type":"projects","url":"/projects/soul/database-design/","wordcount":169},{"author":null,"categories":null,"content":" 说明  本文主要介绍soul的文件上传下载的支持。  文件上传  默认限制文件大小为10M。\n 如果想修改，在启动服务的时候，使用--file.size = 30，为int 类型。\n 你之前怎么上传文件，还是怎么上传。\n  文件下载  soul支持流的方式进行下载，你之前的接口怎么写的，还是怎么写，根本不需要变。  ","date":-62135596800,"description":"文件上传下载","dir":"projects/soul/file-and-image/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"7a88c55afa64c43801dafd3964bdbf01","permalink":"/projects/soul/file-and-image/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/file-and-image/","summary":"说明 本文主要介绍soul的文件上传下载的支持。 文件上传 默认限制文件大小为10M。 如果想修改，在启动服务的时候，使用--file.size = 3","tags":null,"title":"文件上传下载","type":"projects","url":"/projects/soul/file-and-image/","wordcount":139},{"author":null,"categories":null,"content":" 术语  发起者：全局事务的发起者，在一个请求链路资源方法里面，最先需要对分布式资源进行事务处理的地方，在Hmily框架里面 可以表示为：一个请求最先遇到 @HmilyTCC or @HmilyTAC 注解的方法，该所属方法应用被称为发起者。\n 参与者：分布式服务或者资源，需要与其他服务一起参与到一次分布式事务场景下。在Hmily框架里面，表现为一个RPC框架的接口被加上@Hmily注解。\n 协调者：用来协调分布式事务到底是commit，还是 rollback的角色，他可以是远程的，也可以是本地的，可以是中心化的，也可以是去中心化的。在Hmily框架里面的协调者是本地去中心化的角色。\n TCC ：Try, Confirm, Cancel 3个阶段的简称。\n TAC ：Try Auto Cancel的简称。Try阶段预留资源后，会由框架自动生成反向的操作资源的行为。\n  ","date":-62135596800,"description":"术语","dir":"projects/hmily/term/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"8a22c263ed5f16b93fa1175383094d9d","permalink":"/projects/hmily/term/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/term/","summary":"术语 发起者：全局事务的发起者，在一个请求链路资源方法里面，最先需要对分布式资源进行事务处理的地方，在Hmily框架里面 可以表示为：一个请求最","tags":null,"title":"术语","type":"projects","url":"/projects/hmily/term/","wordcount":327},{"author":null,"categories":null,"content":" 说明  本文是说明，如果网关前面有一层nginx 的时候，如何获取正确的ip与端口。\n 获取正确的之后，在插件以及选择器中，可以根据 ip，与host来进行匹配。\n  默认实现  在soul网关自带实现为：org.dromara.soul.web.forwarde.ForwardedRemoteAddressResolver。\n 它需要你在 nginx 设置 X-Forwarded-For，以便来或者正确的 ip 与 host。\n  扩展实现  新增一个类A，实现org.dromara.soul.plugin.api.RemoteAddressResolver  public interface RemoteAddressResolver { /** * Resolve inet socket address. * * @param exchange the exchange * @return the inet socket address */ default InetSocketAddress resolve(ServerWebExchange exchange) { return exchange.getRequest().getRemoteAddress(); } }   把你新增的实现类注册成为spring的bean，如下  @Bean public SignService a() { return new A }  ","date":-62135596800,"description":"正确获取Ip与host","dir":"projects/soul/custom-parsing-ip-and-host/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"7c452779344f84418d0b5890de4a2be3","permalink":"/projects/soul/custom-parsing-ip-and-host/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/custom-parsing-ip-and-host/","summary":"说明 本文是说明，如果网关前面有一层nginx 的时候，如何获取正确的ip与端口。 获取正确的之后，在插件以及选择器中，可以根据 ip，与host来","tags":null,"title":"正确获取Ip与host","type":"projects","url":"/projects/soul/custom-parsing-ip-and-host/","wordcount":321},{"author":null,"categories":null,"content":" 说明  soul 2.2.0以后都是基于插件化可插拔的思想，本文是说明如何基于soul搭建属于你自己网关。\n 请确保你的机器安装了JDK 1.8+，Mysql 5.0 + 。\n  启动 Soul-Admin  下载soul-admin.jar包，并启动。 ```yaml \u0026amp;gt; wget https://yu199195.github.io/jar/soul-admin.jar   java -jar soul-admin.jar \u0026amp;ndash;spring.datasource.url=\u0026amp;ldquo;jdbc:mysql://你的url:3306/soul?useUnicode=true\u0026amp;amp;characterEncoding=utf-8\u0026amp;amp;useSSL=false\u0026amp;rdquo;\n\u0026amp;ndash;spring.datasource.username=\u0026amp;lsquo;you username\u0026amp;rsquo; \u0026amp;ndash;spring.datasource.password=\u0026amp;lsquo;you password\u0026amp;rsquo;\n * 访问 `http://localhost:9095/index.html ` 默认的用户名： admin 密码:123456。 ## 搭建自己的网关（推荐） * 首先你新建一个空的springboot项目，可以参考 soul-bootstrap. 也可以在spring官网:[https://spring.io/quickstart] * 引入如下jar包： ```xml \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-webflux\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.springframework.boot\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;spring-boot-starter-actuator\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;2.2.2.RELEASE\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul gateway start--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-gateway\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt; \u0026amp;lt;!--soul data sync start use websocket--\u0026amp;gt; \u0026amp;lt;dependency\u0026amp;gt; \u0026amp;lt;groupId\u0026amp;gt;org.dromara\u0026amp;lt;/groupId\u0026amp;gt; \u0026amp;lt;artifactId\u0026amp;gt;soul-spring-boot-starter-sync-data-websocket\u0026amp;lt;/artifactId\u0026amp;gt; \u0026amp;lt;version\u0026amp;gt;${last.version}\u0026amp;lt;/version\u0026amp;gt; \u0026amp;lt;/dependency\u0026amp;gt;   在你的 application.yaml 文件中加上如下配置： ```yaml spring: main: allow-bean-definition-overriding: true  management: health: defaults: enabled: false soul : sync: websocket : urls: ws://localhost:9095/websocket //设置成你的soul-admin地址 ``` * 你的项目环境搭建完成，启动你的项目。\n","date":-62135596800,"description":"环境搭建","dir":"projects/soul/soul-set-up/","fuzzywordcount":500,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"b1ffa97596d36706e58789420d76db64","permalink":"/projects/soul/soul-set-up/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/soul-set-up/","summary":"说明 soul 2.2.0以后都是基于插件化可插拔的思想，本文是说明如何基于soul搭建属于你自己网关。 请确保你的机器安装了JDK 1.8+，Mysql","tags":null,"title":"环境搭建","type":"projects","url":"/projects/soul/soul-set-up/","wordcount":457},{"author":null,"categories":null,"content":" 说明  本文主要介绍soul的线程模型，以及各种场景的使用。  io与work线程  soul内置依赖 spring-webflux 而其底层是使用的netty，这一块只要是使用的netty线程模型。  业务线程  默认使用调度线程来执行。\n 默认使用固定的线程池来执行，其线程数为 cpu * 2 + 1。\n  切换类型  reactor.core.scheduler.Schedulers。\n 可以使用 -Dsoul.scheduler.type=fixed 这个是默认。 设置其他的值 就会使用弹性线程池来执行Schedulers.elastic()。\n 可以使用 -Dsoul.work.threads = xx 来指定线程数量，默认为 cpu * 2 + 1，最小为16个线程。\n  ","date":-62135596800,"description":"线程模型","dir":"projects/soul/thread/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"1b10d5087b7f48d39726ce58347610d5","permalink":"/projects/soul/thread/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/thread/","summary":"说明 本文主要介绍soul的线程模型，以及各种场景的使用。 io与work线程 soul内置依赖 spring-webflux 而其底层是使用的netty，这一块只要是使用的n","tags":null,"title":"线程模型","type":"projects","url":"/projects/soul/thread/","wordcount":241},{"author":null,"categories":null,"content":" 说明  用户可以自定义签名认证算法来实现验证。  扩展  默认的实现为 org.dromara.soul.plugin.sign.service.DefaultSignService。\n 新增一个类 A 实现 org.dromara.soul.plugin.api.SignService。\n  public interface SignService { /** * Sign verify pair. * * @param exchange the exchange * @return the pair */ Pair\u0026amp;lt;Boolean, String\u0026amp;gt; signVerify(ServerWebExchange exchange); }   Pair中返回true，表示验证通过，为false的时候，会把String中的信息输出到前端。\n 把你新增的实现类注册成为spring的bean，如下\n  @Bean public SignService a() { return new A }  ","date":-62135596800,"description":"自定义sign插件检验","dir":"projects/soul/custom-sign-algorithm/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"7ac872a2a536afa677e45888ddaaf15a","permalink":"/projects/soul/custom-sign-algorithm/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/custom-sign-algorithm/","summary":"说明 用户可以自定义签名认证算法来实现验证。 扩展 默认的实现为 org.dromara.soul.plugin.sign.service.Defa","tags":null,"title":"自定义sign插件检验","type":"projects","url":"/projects/soul/custom-sign-algorithm/","wordcount":240},{"author":null,"categories":null,"content":" 说明  本文是说明基于soul网关返回自定义的数据个数。\n 网关需要统一的返回格式，而每个公司都有自己定义的一套，所以需要对次进行扩展。\n  默认实现  默认的实现为 org.dromara.soul.plugin.api.result.DefaultSoulResult\n 返回的数据格式如下：\n  public class SoulDefaultEntity implements Serializable { private static final long serialVersionUID = -2792556188993845048L; private Integer code; private String message; private Object data; }   返回的json 格式如下：\n{ \u0026amp;quot;code\u0026amp;quot;: -100, //返回码, \u0026amp;quot;message\u0026amp;quot;: \u0026amp;quot;您的参数错误,请检查相关文档!\u0026amp;quot;, //提示字段 \u0026amp;quot;data\u0026amp;quot;: null // 具体的数据 }  扩展  新增一个类 A 实现 org.dromara.soul.plugin.api.result.SoulResult  public interface SoulResult\u0026amp;lt;T\u0026amp;gt; { /** * Success t. * * @param code the code * @param message the message * @param object the object * @return the t */ T success(int code, String message, Object object); /** * Error t. * * @param code the code * @param message the message * @param object the object * @return the t */ T error(int code, String message, Object object); }  其他 泛型 T 为你自定义的数据格式，返回它就好\n 把你新增的实现类注册成为spring的bean，如下\n  @Bean public SoulResult a() { return new A(); }  ","date":-62135596800,"description":"自定义网关返回数据格式","dir":"projects/soul/custom-result/","fuzzywordcount":400,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"a8aa2a84984dc4749833c69cfab55ba0","permalink":"/projects/soul/custom-result/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/custom-result/","summary":"说明 本文是说明基于soul网关返回自定义的数据个数。 网关需要统一的返回格式，而每个公司都有自己定义的一套，所以需要对次进行扩展。 默认实现 默认","tags":null,"title":"自定义网关返回数据格式","type":"projects","url":"/projects/soul/custom-result/","wordcount":309},{"author":null,"categories":null,"content":" 说明  选择器和规则是soul网关中最灵魂的东西。掌握好它，你可以对任何流量进行管理。\n 本篇主要详解soul网关中，选择器与规则的概念，以及如何使用。\n  大体理解  一个插件有多个选择器，一个选择器对应多种规则。选择器相当于是对流量的第一次筛选，规则就是最终的筛选。\n 我们想象一下，在一个插件里面，我们是不是希望根据我们的配置，达到满足条件的流量，我们插件才去执行它？\n 选择器和规则就是为了让流量在满足特定的条件下，才去执行我们想要的，这个你首先头脑要点数。\n 数据结构可以参考之前的 数据库设计\n  选择器  选择器详解：\n 名称：为你的选择器起一个容易分辨的名字 类型：custom flow 是自定义流量。full flow 是全流量。自定义流量就是请求会走你下面的匹配方式与条件。全流量则不走。 匹配方式：and 或者or 是指下面多个条件是按照and 还是or的方式来组合。 条件：  uri：是指你根据uri的方式来筛选流量，match的方式支持模糊匹配（/**） header：是指根据请求头里面的字段来筛选流量。 query：是指根据uri的查询条件来进行筛选流量。 ip：是指根据你请求的真实ip，来筛选流量。 host：是指根据你请求的真实host，来筛选流量。 post：建议不要使用。 条件匹配：  match：模糊匹配，建议和uri条件搭配，支持 restful风格的匹配。（/test/**） =：前后值相等，才能匹配。 regEx：正则匹配，表示前面一个值去匹配后面的正则表达式。 like：字符串模糊匹配。\n   是否开启：打开才会生效 打印日志：打开的时候，当匹配上的时候，会打印匹配日志。 执行顺序：当多个选择器的时候，执行顺序小的优先执行。   上述图片中表示:当请求的uri前缀是 /test，并且header 头上 module 字段值为test 的时候，会转发到 1.1.1.1:8080 这个服务。\n 选择器建议：可以uri 条件， match 前缀 （/contextPath），进行第一道流量筛选。\n  规则  当流量经过选择器匹配成功之后，会进入规则来进行最终的流量匹配。\n 规则是对流量最终执行逻辑的确认。\n 规则详解：\n 名称：为你的规则起一个容易分辨的名字 匹配方式：and 或者or 是指下面多个条件是按照and 还是or。 条件：  uri：是指你根据uri的方式来筛选流量，match的方式支持模糊匹配（/**） header：是指根据请求头里面的字段来筛选流量。 query：是指根据uri的查询条件来进行筛选流量。 ip：是指根据你请求的真实ip，来筛选流量。 host：是指根据你请求的真实host，来筛选流量。 post：建议不要使用。 条件匹配:  match : 模糊匹配，建议和uri条件搭配，支持 restful风格的匹配。（/test/**） = : 前后值相等，才能匹配。 regEx : 正则匹配，表示前面一个值去匹配后面的正则表达式。 like ：字符串模糊匹配。   是否开启：打开才会生效。 打印日志：打开的时候，当匹配上的时候，会打印匹配日志。 执行顺序：当多个规则的时候，执行顺序小的优先执行。 处理：每个插件的规则处理不一样，具体的差有具体的处理，具体请查看每个对应插件的处理。  上图表示：当 uri 等于 /http/order/save 的时候该规则被匹配，就会执行该规则中，负载策略是 random。\n 联合选择器，我们来表述一下：当一个 请求的 uri 为 /http/order/save，会通过 random 的方式，转发到 1.1.1.1:8080。\n 规则建议：可以uri 条件， match 最真实的uri路径，进行流量的最终筛选 。\n  条件详解  uri 匹配 （推荐）\n uri匹配是根据你请求路径中的uri来进行匹配，在接入网关的时候，前端几乎不用做任何更改。\n 当使用 match 方式匹配时候，同 springmvc 模糊匹配原理相同。\n 在选择器中，推荐使用uri中的前缀来进行匹配，而在规则中，则使用具体路径来进行匹配。\n 该匹配方式的时候，在匹配字段名称可以任意填写，匹配字段值需要正确填写。\n  header 匹配\n header是根据你的http 请求头中的字段值来匹配。   query 匹配\n 这个是根据你的uri中的查询参数来进行匹配，比如 /test?a=1\u0026amp;amp;\u0026amp;amp;b=2 ，那么可以选择该匹配方式。\n 上述就可以新增一个条件，选取 query方式 , a = 1 。\n  ip匹配\n 这个是根据 http调用方的 ip来进行匹配。\n 尤其是在waf插件里面，如果发现一个ip地址有攻击，可以新增一条匹配条件，填上该ip，拒绝该ip的访问。\n 如果在soul前面使用了nginx代理，为了获取正确的ip，你可能要参考 dev-iphost\n  host匹配\n 这个是根据 http调用方的host来进行匹配。\n 尤其是在waf插件里面，如果发现一个host地址有攻击，可以新增一条匹配条件，填上该host，拒绝该host的访问。\n 如果在soul前面使用了nginx代理，为了获取正确的host，你可能要参考 dev-iphost\n  post匹配\n 不推荐使用。   ","date":-62135596800,"description":"选择器规则详解","dir":"projects/soul/selector-and-rule/","fuzzywordcount":1900,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"895f00be71b81b881903c5d1173025f2","permalink":"/projects/soul/selector-and-rule/","publishdate":"0001-01-01T00:00:00Z","readingtime":4,"relpermalink":"/projects/soul/selector-and-rule/","summary":"说明 选择器和规则是soul网关中最灵魂的东西。掌握好它，你可以对任何流量进行管理。 本篇主要详解soul网关中，选择器与规则的概念，以及如何使","tags":null,"title":"选择器规则详解","type":"projects","url":"/projects/soul/selector-and-rule/","wordcount":1885},{"author":null,"categories":null,"content":" 说明  本篇是对admin后台操作数据以后，同步到网关的流程介绍。  使用  用户可以在 soul-admin 后台任意修改数据，并马上同步到网关的jvm内存中。\n 同步soul的插件数据，选择器，规则数据，元数据，签名数据等等。\n 所有插件的选择器，规则都是动态配置，立即生效，不需要重启服务。\n 下面是数据流程图：   作用  用户所有的配置都可以动态的更新，任何修改不需要重启服务。\n 使用了本地缓存，在高并发的时候，提供高效的性能。\n  ","date":-62135596800,"description":"配置流程介绍","dir":"projects/soul/config/","fuzzywordcount":200,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"bfc2353dc4f9a2d42ba75eb2e8734faa","permalink":"/projects/soul/config/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/soul/config/","summary":"说明 本篇是对admin后台操作数据以后，同步到网关的流程介绍。 使用 用户可以在 soul-admin 后台任意修改数据，并马上同步到网关的jvm内存中。 同步soul","tags":null,"title":"配置流程介绍","type":"projects","url":"/projects/soul/config/","wordcount":190},{"author":null,"categories":null,"content":" 我引用了jar包，发现启动不了，报错怎么办？  答：这种需要你自己去定位问题，查看是否按照文档来进行配置，环境是否正确，是否有依赖冲突问题，实在解决不了，可以在github上提供issue， 我们团队会进行技术支持。  微服务异常，事务没回滚怎么办？  答：首先，你可以去查看日志记录，如果日志记录存在，那在你配置的调度时间之后，会执行回滚。  编译源码，发现缺少get，set方法怎么办？  答：源码使用了lombok，你可能需要在你的开发工具，安装对应的插件。（没有set get方法并不影响运行的）。  ","date":-62135596800,"description":"问题描述","dir":"projects/hmily/faq/","fuzzywordcount":300,"kind":"page","lang":"zh","lastmod":1611505634,"objectID":"291ff6f051e39fe15edb0c08d62aef12","permalink":"/projects/hmily/faq/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/projects/hmily/faq/","summary":"我引用了jar包，发现启动不了，报错怎么办？ 答：这种需要你自己去定位问题，查看是否按照文档来进行配置，环境是否正确，是否有依赖冲突问题，实在","tags":null,"title":"问题","type":"projects","url":"/projects/hmily/faq/","wordcount":241}]