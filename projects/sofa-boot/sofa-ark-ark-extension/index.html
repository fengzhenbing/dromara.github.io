<!doctype html><html><head><title>Ark 扩展机制 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/><img class=logo src=/img/logo.png></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/guides/><span>指南</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/projects/>项目</a>
<a class=navbar-item href=/guides/>指南</a>
<a class=navbar-item href=/blog/>博客</a>
<a class=navbar-item href=/activities/>活动</a>
<a class=navbar-item href=/community/>社区</a>
<a class=navbar-item href=/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item></div></div></div></nav></header><div class=ss-layout-container><aside class="ss-layout-aside -left ss-card -soft-hidden"></aside><main class="ss-layout-main -card"><div class=ss-meta><div class=container><h1 class=title>Ark 扩展机制</h1><a class="edit-button -hidden-mobile" href=https://github.com/dromara/edit/master/content/zh/projects/sofa-boot/sofa-ark-ark-extension/index.md>编辑</a></div><div class=meta>更新时间: 2021-01-24</div></div><article class=typo><p>Ark 容器和 Ark Plugin 在运行时由不同的类加载器加载，不能使用常规的 ServiceLoader 提供 SPI 扩展，SOFAArk 自定义扩展点 SPI 机制， Ark Plugin 实现 SPI 机制，考虑到 Biz 卸载问题，Ark Biz 暂时不支持该 SPI 机制，只适用于 Ark Plugin 之间。</p><h3 id=声明扩展接口>声明扩展接口</h3><p>使用注解 <code>@Extensible</code> 声明扩展接口，注解定义如下：</p><pre><code class=language-java>@Target({ ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Extensible {

    /**
     * return specify extensible file name, default value is the
     * full name of interface.
     */
    String file() default &quot;&quot;;

    /**
     * return whether this a singleton, with a single, shared instance
     * returned on all calls, default value is true.
     */
    boolean singleton() default true;
}
</code></pre><ul><li><code>file</code> 用于声明 SPI 扩展文件名，默认为接口全类名</li><li><code>singleton</code> 用于声明加载扩展类是否为单例模式</li></ul><h3 id=声明扩展实现>声明扩展实现</h3><p>使用注解 <code>@Extension</code> 声明扩展实现，注解定义如下：</p><pre><code class=language-java>@Target({ ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Extension {
    /**
     * extension name
     */
    String value();

    /**
     * extension order, Higher values are interpreted as lower priority.
     * As a consequence, the object with the lowest value has the highest
     * priority.
     */
    int order() default 100;
}
</code></pre><ul><li><code>value</code> 用于定义扩展实现名称，例如不同的插件扩展同一个接口，可能会取不同的名字。</li><li><code>order</code> 用于决定具体扩展实现的生效顺序</li></ul><p>运行时，对于同一个接口的扩展实现生效规则如下：
+ 规则一：名称相同的扩展实现，只会返回优先级高的扩展实现类，order 数字越小，优先级越高
+ 规则二：名称不相同的扩展实现，则返回一个对应的 List 列表，每个名称返回优先级最高的扩展实现</p><h3 id=加载-spi-实现类>加载 SPI 实现类</h3><p>正常情况下，我们使用 ServiceLoader 加载 SPI 接口实现；SOFAArk 提供了工具类 <code>ArkServiceLoader</code> 用于加载扩展实现，工具类定义了两个简单的方法：</p><pre><code class=language-java>public class ArkServiceLoader {
    private static ExtensionLoaderService extensionLoaderService;

    // 方法一
    public static &lt;T&gt; T loadExtension(Class&lt;T&gt; interfaceType, String extensionName) {
        return extensionLoaderService.getExtensionContributor(interfaceType, extensionName);
    }

    // 方法二
    public static &lt;T&gt; List&lt;T&gt; loadExtension(Class&lt;T&gt; interfaceType) {
        return extensionLoaderService.getExtensionContributor(interfaceType);
    }
}
</code></pre><ul><li>方法一：用于加载指定接口和名称的扩展实现，返回单个结果。参考上述规则一</li><li>方法二：用于加载指定接口的扩展实现，返回列表结果。参考上述规则二</li></ul><p>需要注意下，定义 SPI 接口的插件需要导出该接口，负责实现 SPI 接口的插件需要导入该接口。另外 SOFAArk 容器本身也会定义部分用于插件扩展实现的 SPI 接口，例如 <code>ClassLoaderHook</code></p><h3 id=为什么不支持-biz-的-spi-扩展实现加载>为什么不支持 Biz 的 SPI 扩展实现加载</h3><p>考虑到 Biz 会动态的安装和卸载，如果支持 Biz 的扩展实现加载，生命周期容易引起混乱，暂时不考虑支持。如果确实存在 Ark Plugin 需要主动触发 Ark Biz 的逻辑调用，可以通过 SOFAArk 内部事件机制。</p><h3 id=sofaark-默认扩展点>SOFAArk 默认扩展点</h3><p>SOFAArk 容器目前提供了唯一一个扩展点 <code>ClassLoaderHook</code>，用于其他插件提供扩展实现，自定义类/资源加载逻辑。<code>ClassLoaderHooker</code> 接口定义如下，用于扩展 BizClassLoader 和 PluginClassLoader 类(资源）加载逻辑：</p><pre><code class=language-java>@Extensible
public interface ClassLoaderHook&lt;T&gt; {

    Class&lt;?&gt; preFindClass(String name, ClassLoaderService classLoaderService, T t)
                                                                                  throws ClassNotFoundException;


    Class&lt;?&gt; postFindClass(String name, ClassLoaderService classLoaderService, T t)
                                                                                   throws ClassNotFoundException;


    URL preFindResource(String name, ClassLoaderService classLoaderService, T t);


    URL postFindResource(String name, ClassLoaderService classLoaderService, T t);


    Enumeration&lt;URL&gt; preFindResources(String name, ClassLoaderService classLoaderService, T t)
                                                                                              throws IOException;

    Enumeration&lt;URL&gt; postFindResources(String name, ClassLoaderService classLoaderService, T t)
                                                                                               throws IOException;
}
</code></pre><p>通过在插件中扩展该 SPI 接口实现，可以自定义 PluginClassLoader 和 BizClassLoader 的类/资源的加载逻辑。</p><h4 id=扩展实现-pluginclassloader-加载逻辑>扩展实现 PluginClassLoader 加载逻辑</h4><p>定义对 PluginClassLoader 的扩展实现，需要指定 extension 名为 <code>plugin-classloader-hook</code>; 这是因为目前 SOFAArk 的策略只允许一个Plugin ClassLoaderHook 扩展实现生效，如果同时定义多个扩展类，优先级最高的生效。</p><pre><code class=language-java>@Extension(&quot;plugin-classloader-hook&quot;)
public class TestPluginClassLoaderHook implements ClassLoaderHook&lt;Plugin&gt; {
}
</code></pre><h4 id=扩展实现-bizclassloader-加载逻辑>扩展实现 BizClassLoader 加载逻辑</h4><p>定义对 BizClassLoader 的扩展实现，需要指定 extension 名为 <code>biz-classloader-hook</code>; 理由同上，目前 SOFAArk 的策略只允许一个Biz ClassLoaderHook 扩展实现生效，如果同时定义多个扩展类，优先级最高的生效。</p><pre><code class=language-java>@Extension(&quot;biz-classloader-hook&quot;)
public class TestBizClassLoaderHook implements ClassLoaderHook&lt;Biz&gt; {
}
</code></pre><h2 id=classloaderhook-使用案例>ClassLoaderHook 使用案例</h2><p>这里以 BizClassLoaderHook 为例，来实现 <strong>模块中的类委托给基座加载 </strong>，这种可以完全将所有依赖都打在基座（宿主）应用中，模块中可以什么依赖都不带，完全是纯的业务代码；带来的好处是，一个模块最终打出的包大小会非常小，在动态操作模块时，可以极大的提高性能。</p><p>例如有一个 sofa-dashboard-ark-facade 包，这个包本身就是由宿主应用提供，那么模块在引入这个包时就可以不再需要将 sofa-dashboard-ark-facade 打在自己的 biz 包里面。
这里将 sofa-dashboard-ark-facade 的 dependency 的 scope 改为 provided，使得打包时，不将 sofa-dashboard-ark-facade 打到模块 biz 中。然后通过 ClassLoaderHook 机制将
sofa-dashboard-ark-facade 包中提供的类委托给宿主来加载。具体过程如下：</p><pre><code class=language-xml>&lt;dependency&gt;
    &lt;groupId&gt;com.glmapper.bridge.boot&lt;/groupId&gt;
    &lt;artifactId&gt;sofa-dashboard-ark-facade&lt;/artifactId&gt;
    &lt;!-- sofa-dashboard-ark-facade 不打包进去，使用宿主里面提供的--&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><h3 id=在模块中提供-hook-实现>在模块中提供 hook 实现</h3><p>在模块代码中新建一个 DelegateMasterBizClassLoaderHook 类，如下：</p><pre><code class=language-java>@Extension(&quot;biz-classloader-hook&quot;)
public class DelegateMasterBizClassLoaderHook implements ClassLoaderHook&lt;Biz&gt; {

    @Override
    public Class&lt;?&gt; preFindClass(String name, ClassLoaderService classLoaderService, Biz biz) throws ClassNotFoundException {
        return null;
    }

    @Override
    public Class&lt;?&gt; postFindClass(String name, ClassLoaderService classLoaderService, Biz biz) throws ClassNotFoundException {
        // 按包名组织
        if (name.startsWith(&quot;io.sofastack.ark.biz.facade&quot;)){
            ClassLoader masterBizClassLoader = ArkClient.getMasterBiz().getBizClassLoader();
            return bizClassLoader.loadClass(name);
        }
        return null;
    }

    @Override
    public URL preFindResource(String name, ClassLoaderService classLoaderService, Biz biz) {
        // 资源也要委托
        if (name.startsWith(&quot;io/sofastack/ark/biz/facade&quot;)) {
            ClassLoader masterBizClassLoader = ArkClient.getMasterBiz().getBizClassLoader();
            try {
                return bizClassLoader.getResource(name);
            } catch (Exception e) {
                return null;
            }
        }
        return null;
    }

    @Override
    public URL postFindResource(String name, ClassLoaderService classLoaderService, Biz biz) {
        return null;
    }

    @Override
    public Enumeration&lt;URL&gt; preFindResources(String name, ClassLoaderService classLoaderService, Biz biz) throws IOException {
        if (name.startsWith(&quot;io/sofastack/ark/biz/facade&quot;)){
           ClassLoader masterBizClassLoader = ArkClient.getMasterBiz().getBizClassLoader();
            try {
                return bizClassLoader.getResources(name);
            } catch (Exception e) {
                return null;
            }
        }
        return null;
    }

    @Override
    public Enumeration&lt;URL&gt; postFindResources(String name, ClassLoaderService classLoaderService, Biz biz) throws IOException {
        return null;
    }
}

</code></pre><p>在 resources 目录下添加 /META-INF/services/sofa-ark/ 目录，再在 /META-INF/services/sofa-ark/ 添加一个 名为 com.alipay.sofa.ark.spi.service.classloader.ClassLoaderHook 的文件，文件里面内容为 hook 类的全限定名：</p><blockquote><p>io.sofastack.ark.biz.provider.hooks.DelegateMasterBizClassLoaderHook</p></blockquote><p>重新打包，打包之后验证下模块 biz 包，里面已经没有 sofa-dashboard-ark-facade 包，然后重新验证下执行是否正常。</p><h3 id=通过-plugin-提供-hook-实现>通过 plugin 提供 hook 实现</h3><p>不支持，会出现循环应引用问题。模块 BizClassLoader getResources 过程描述：</p><ul><li>1、preFindResource: 当前模块没有实现 hook，所以 preFindResource 不会执行，返回是 null</li><li>2、getInternalResouces</li><li>3、getJdkResource: 加载不到</li><li>4、getExportResource: 这里会尝试使用插件 pluginClassLoader 来加载</li><li>5、pluginClassLoader.getResources</li><li>6、preFindResource: 这里委托给宿主 bizClassLoader 加载，bizClassLoader.getResources -&gt; getInternalResouces-&gt;getExportResource-&gt;pluginClassLoader.getResources-&gt;hook preFindResource -&gt; 委托给宿主 bizClassLoader 加载 -&gt; &hellip;.</li></ul></article></main></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/shuaiqiyu>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/community>社区</a>
<a class=link href=/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=/projects/soul/overview/>Soul</a>
<a class=link href=/projects/hmily/overview/>Hmily</a>
<a class=link href=/projects/raincat/overview/>Raincat</a>
<a class=link href=/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>xiaoyu@apache.org by xiaoyu</a></p></div></footer></body></html>